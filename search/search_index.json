{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AoE2ScenarioParser documentation","text":"<p>This is the documentation page for the AoE2ScenarioParser project. Which is used for editing parts of an <code>aoe2scenario</code> file from Age of Empires 2  Definitive Edition outside the in-game editor.  </p> <p>On this documentation page you can find examples and explanations about certain aspects of the library.</p> <p>In the menu on the left, you can find, among other things:</p> <ol> <li>How to install &amp; set up the parser (Installation)</li> <li>How to read your first scenario (Getting Started)</li> <li>How to make different changes to get you going (Hello World)</li> </ol> <p>In the top menu you can find other sections of this documentation page.</p> <ol> <li>Cheatsheets: This is the most important tab.      Cheatsheets are pages about a certain topic with a lot of examples and possibilities.      Their goal is to give you some insight in what you can achieve with the topics (shown on the left when on that tab)</li> <li>Examples: This page has some short &amp; simple examples for you to see how the parser works.      The list will (eventually) be expanded upon</li> <li>Community: Here you can find community made guides, tools and projects.      If you've created a project, please showcase it in the discord server and it might be added to the list!</li> </ol>"},{"location":"getting_started/","title":"Getting started","text":"<p>Once you have installed the library the fun can begin!  To get started import the library in your python project like so:</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n</code></pre> <p>Define the file you will be reading from and where you will be writing your new file to.  </p> <p>Where to find your scenario files</p> <p>The scenarios can usually be found here: <code>C:\\Users\\&lt;USERNAME&gt;\\Games\\Age of Empires 2 DE\\&lt;STEAMID&gt;\\resources\\_common\\scenario</code> The <code>STEAMID</code> folder is your steam ID and looks something like: <code>12345678901234567</code></p> <pre><code>input_path = \"File/Path/To/Your/Input/kFile.aoe2scenario\"\noutput_path = \"File/Path/To/Your/Output/File.aoe2scenario\"\n</code></pre> <p>Do not overwrite your source scenario</p> <p>It is recommended to not overwrite the file you will be reading for backup reasons.</p> <p>Now create the <code>Scenario</code> object with the filename as parameter.</p> <pre><code>scenario = AoE2DEScenario.from_file(input_path)\n</code></pre>"},{"location":"getting_started/#managers","title":"Managers","text":"<p>You can now edit to your heart's content. Every aspect of the scenario is seperated in managers.  Not all parts are currently supported. The following list shows the current support and use of  all available managers:</p> Manager Description trigger_manager The trigger manager is used for creating, editing and removing Triggers, Conditions, Effects and Variables. unit_manager The unit manager is used for creating, editing and removing Units. This includes buildings and heroes etc. map_manager The map manager is used for changing terrain, elevation or simply getting coordinates for certain types. player_manager The player manager is used to edit player attributes such as civs, starting age, diplomacy, disables etc. xs_manager The XS manager is used to store XS in a script_call effect to make it easily transferable in Multiplayer message_manager The Message manager is used to edit the fields in the Messages tab in the in-game editor. <p>You can access all managers like so:</p> <pre><code>scenario = AoE2DEScenario.from_file(input_path)\n\ntrigger_manager = scenario.trigger_manager\nunit_manager = scenario.unit_manager\n# etc...\n</code></pre> <p>After you're done editing, you can save your work and write it to an <code>aoe2scenario</code> file:</p> <pre><code>scenario.write_to_file(output_path)\n</code></pre>"},{"location":"hello_world/","title":"Hello World Example","text":""},{"location":"hello_world/#intro","title":"Intro","text":"<p>With the information from the getting started page, we can make a \"Hello World\" example. We'll read a scenario, add a trigger, some units and edit some terrain and write it back to a new scenario.</p> <p>This \"hello world\" example assumes you've installed an editor. A great editor (IDE) is PyCharm (Download Community Edition))</p>"},{"location":"hello_world/#step-by-step","title":"Step by step","text":""},{"location":"hello_world/#1-create-the-scenario","title":"1. Create the scenario","text":"<p>Create an empty scenario in the editor and save it as \"hello world\"</p>"},{"location":"hello_world/#2-setup-the-project","title":"2. Setup the project","text":"<p>Create a new project and file (in PyCharm). Name the file <code>hello_world.py</code>, and copy the code below into <code>hello_world.py</code></p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# The path to your scenario folder\ninput_folder = \"C:/path/to/your/scenario/folder/\"\n\n# The scenario object. \nscenario = AoE2DEScenario.from_file(input_folder + \"hello world.aoe2scenario\")\n</code></pre>"},{"location":"hello_world/#3-getting-the-scenario-path","title":"3. Getting the scenario path","text":"<ol> <li>Go to the \"Load Scenario\" menu in-game (Single Player  Editors)</li> <li>Copy the path that is opened when clicking the \"Open Scenario Folder\" button (Bottom right)</li> <li> <p>Paste the folder path in the input_folder string</p> <p>Folder separators</p> <p>If you use <code>\\</code> to separate folders, use 2 per folder (<code>c:\\\\folder\\\\folder\\\\</code>) If you use <code>/</code> to separate folders, 1 is enough (<code>c:/folder/folder/</code>) </p> </li> <li> <p>Remember to add a <code>/</code> or <code>\\\\</code> at the end of the string too</p> </li> </ol>"},{"location":"hello_world/#4-test-if-it-works","title":"4. Test if it works","text":"<p>Run the python code by pressing Ctrl+Shift+F10</p> <p>Executing python code in PyCharm</p> <p>Ctrl+Shift+F10 executes the current file in PyCharm. More info here.</p> <p>You should get a console output that looks like this:</p> <pre><code>Reading file: 'YOUR FILE PATH' \nReading scenario file finished successfully.\n############### Attributes ###############\n&gt;&gt;&gt; Game version: 'DE'\n&gt;&gt;&gt; Scenario version: 1.43\n##########################################\nLoading scenario structure finished successfully.\nParsing scenario file...\n    \u2714 FileHeader\n    \u2714 DataHeader\n...\n</code></pre>"},{"location":"hello_world/#5-adding-a-trigger","title":"5. Adding a trigger","text":"<p>Now let's add a trigger with a <code>Display Instructions</code> effect that reads \"Hello World\"</p> <ol> <li> <p>Add the following code to <code>hello_world.py</code></p> <pre><code># Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time\ntrigger_manager = scenario.trigger_manager\n\n# Save the created trigger\nhello_world_trigger = trigger_manager.add_trigger(\"Hello World Trigger\")\n# Add display_instructions effect to the new trigger\nhello_world_trigger.new_effect.display_instructions(\n    display_time=11,\n    message=\"Hello World\"\n)\n</code></pre> </li> <li> <p>Now let's check it out in game. Add the following code:</p> <pre><code>scenario.write_to_file(input_folder + \"hello world output.aoe2scenario\")\n</code></pre> <p>This will save the changes made to the scenario to a new file specified at the given path. </p> </li> <li> <p>Run the python code by pressing Shift+F10 (rerun the last file)</p> </li> <li> <p>You should see something like this at the end of your console:</p> <pre><code>...\n    \u2714 Triggers\n    \u2714 Files\nFile writing finished successfully.\nFile successfully written to: 'YOUR OUTPUT FILE PATH'\nProcess finished with exit code 0\n</code></pre> </li> <li> <p>Check out the \"hello world output\" scenario in-game and test it!</p> </li> </ol>"},{"location":"hello_world/#6-adding-units","title":"6. Adding units","text":"<ol> <li>Remove the <code>scenario.write_to_file(...)</code> line, we'll add it back later</li> <li> <p>Let's add the <code>unit_manager</code> to the script where we added the trigger manager:</p> <pre><code>unit_manager = scenario.unit_manager\n</code></pre> </li> <li> <p>Now let's add the code to add some units to the end of the script:</p> <pre><code>unit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.MILITIA.ID,              x=15, y=12)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.MAN_AT_ARMS.ID,          x=15, y=13)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.LONG_SWORDSMAN.ID,       x=15, y=14)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.TWO_HANDED_SWORDSMAN.ID, x=15, y=15)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.CHAMPION.ID,             x=15, y=16)\n</code></pre> <p>Take a look at the code, maybe you can see what it does?</p> </li> <li> <p>We add one unit per unit from the militia line to the editor, one per tile.</p> <p>Note</p> <p>These units are placed using whole numbers (called: integers, <code>x=15, y=12</code>), if you want units to spawn in the middle of a tile, use <code>.5</code> after the integer, like so: <code>x=15.5, y=12.5</code></p> </li> <li> <p>You can also see the above code uses <code>PlayerId</code> and <code>UnitInfo</code> objects.</p> <pre><code>PlayerId.ONE         # The number representing player one (1)\nUnitInfo.MILITIA.ID  # The number representing a militia unit (74)\n</code></pre> <p>Datasets</p> <p>These are datasets, A Dataset is an Enum Class that contains the constants used by the game like unit IDs, etc. These are essential to producing a scenario. Read more about them here.</p> </li> <li> <p>Let's import the datasets using the code below. Add these lines to the top of your file.</p> <pre><code>from AoE2ScenarioParser.datasets.players import PlayerId\nfrom AoE2ScenarioParser.datasets.units import UnitInfo\n</code></pre> </li> </ol>"},{"location":"hello_world/#7-changing-the-map","title":"7. Changing the map","text":"<ol> <li> <p>And now as final change let's add a hill and change the size of the map. First add the <code>map_manager</code>:</p> <p><pre><code>map_manager = scenario.map_manager\n</code></pre> Place it with the <code>unit_manager</code> and the <code>trigger_manager</code></p> </li> <li> <p>Now let's add the code for the hill:</p> <pre><code>map_manager.set_elevation(elevation=3, x1=10, y1=10, x2=20, y2=20)\n</code></pre> <p>The in-game max elevation is 7, that's equivelant to <code>elevation=6</code> in the parser. This is because <code>elevation=0</code> is elevation 1 in the editor. Using the parser you can go as large as you want, although above ~20  without UHD and ~15 with UHD the camera starts clipping into the hill. </p> </li> <li> <p>And finally let's shrink the map size to <code>40x40</code> tiles</p> <pre><code>map_manager.map_size = 40\n</code></pre> <p>Max map size limit</p> <p>The limit of a scenario is set to the size of a ludikrous map (<code>480x480</code>). Going over this limit will cause the game to crash.</p> </li> <li> <p>Now let's add the writing to file back:</p> <pre><code>scenario.write_to_file(input_folder + \"hello world output.aoe2scenario\")\n</code></pre> </li> <li> <p>Run the python code by pressing Shift+F10 again and check out the scenario!</p> </li> </ol>"},{"location":"hello_world/#complete-code-block","title":"Complete code block","text":"<p>Your code should look something like the below block. You can find more examples &amp; explanation on the cheatsheets and the examples page.</p> <pre><code>from AoE2ScenarioParser.datasets.players import PlayerId\nfrom AoE2ScenarioParser.datasets.units import UnitInfo\nfrom AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# The path to your scenario folder\ninput_folder = \"C:/path/to/your/scenario/folder/\"\n\n# The scenario object.\nscenario = AoE2DEScenario.from_file(input_folder + \"hello world.aoe2scenario\")\n\n# Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time\ntrigger_manager = scenario.trigger_manager\nunit_manager = scenario.unit_manager\nmap_manager = scenario.map_manager\n\n# Save the created trigger\nhello_world_trigger = trigger_manager.add_trigger(\"Hello World Trigger\")\n# Add display_instructions effect to the new trigger\nhello_world_trigger.new_effect.display_instructions(\n    display_time=11,\n    message=\"Hello World\"\n)\n\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.MILITIA.ID,              x=15, y=12)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.MAN_AT_ARMS.ID,          x=15, y=13)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.LONG_SWORDSMAN.ID,       x=15, y=14)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.TWO_HANDED_SWORDSMAN.ID, x=15, y=15)\nunit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.CHAMPION.ID,             x=15, y=16)\n\nmap_manager.set_elevation(elevation=3, x1=10, y1=10, x2=20, y2=20)\nmap_manager.map_size = 40\n\nscenario.write_to_file(input_folder + \"hello world output.aoe2scenario\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>You can install the project using pip:</p> <pre><code>pip install AoE2ScenarioParser\n</code></pre> <p>Or install it manually by cloning the git repo.</p> <p>Note</p> <p>This method requires you to install the dependencies and all updates manually too.</p> <pre><code>git clone https://github.com/KSneijders/AoE2ScenarioParser.git\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>This project is made in Python 3. You'll need Python 3.8 or newer to be able to run it properly.</p> <p>To see the project dependencies, please check the requirements.txt file in the project.</p> <p>Note</p> <p>All these dependencies should install automatically when using the above pip command.</p>"},{"location":"installation/#updating","title":"Updating","text":"<p>To update the library using pip when you have an older version, use the following command:</p> <pre><code>pip install --no-cache-dir --upgrade AoE2ScenarioParser\n</code></pre> <p>To view the changes between versions, visit the GitHub page and check the changelog.md file.</p>"},{"location":"installation/#rollback-or-update-to-specific-versions","title":"Rollback or update to specific versions","text":"<p>To change your installation to a specific version (i.e. when you have issues with the current build), use the following command:</p> <pre><code>pip install \"AoE2ScenarioParser==&lt;VERSION&gt;\" --force-reinstall\n</code></pre> <p>Where <code>&lt;VERSION&gt;</code> is the version you want (e.g. <code>0.1.47</code>)</p>"},{"location":"support/","title":"Support","text":"<p>If you find a bug please report it as a GitHub issue on the github issue board. If you have any questions regarding the parser, join the discord!</p>"},{"location":"api_docs/aoe2_de_scenario/","title":"AoE2DEScenario","text":""},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario-attributes","title":"Attributes","text":""},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario-classes","title":"Classes","text":""},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario","title":"<code>AoE2DEScenario</code>","text":"<p>               Bases: <code>AoE2Scenario</code></p> <p>Used to represent a scenario with version &gt;= 1.36 (DE). It is the main class that is exposed to the user of the API.</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_de_scenario.py</code> <pre><code>class AoE2DEScenario(AoE2Scenario):\n    \"\"\"\n    Used to represent a scenario with version &gt;= 1.36 (DE). It is the main class that is exposed to the user of the API.\n    \"\"\"\n\n    @property\n    def trigger_manager(self) -&gt; TriggerManagerDE:\n        \"\"\"The trigger manager of the scenario\"\"\"\n        return self._object_manager.managers['Trigger']\n\n    @property\n    def unit_manager(self) -&gt; UnitManagerDE:\n        \"\"\"The unit manager of the scenario\"\"\"\n        return self._object_manager.managers['Unit']\n\n    @property\n    def map_manager(self) -&gt; MapManagerDE:\n        \"\"\"The map manager of the scenario\"\"\"\n        return self._object_manager.managers['Map']\n\n    @property\n    def xs_manager(self) -&gt; XsManagerDE:\n        \"\"\"The XS manager of the scenario\"\"\"\n        return self._object_manager.managers['Xs']\n\n    @property\n    def player_manager(self) -&gt; PlayerManager:\n        \"\"\"The player manager of the scenario\"\"\"\n        return self._object_manager.managers['Player']\n\n    @property\n    def message_manager(self) -&gt; MessageManager:\n        return self._object_manager.managers['Message']\n\n    @classmethod\n    def from_file(cls: Type[S], path: str, game_version: str = \"DE\", name: str = \"\") -&gt; S:\n        \"\"\"\n        Creates and returns an instance of the AoE2DEScenario class from the given scenario file\n\n        Args:\n            path: The path to the scenario file to create the object from\n            game_version: The version of the game to create the object for\n            name: The name given to this scenario (defaults to the filename without extension)\n\n        Returns:\n            An instance of the AoE2DEScenario class which is the object representation of the given scenario file\n        \"\"\"\n        return super().from_file(path=path, game_version=game_version, name=name)\n</code></pre>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario-attributes","title":"Attributes","text":""},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.map_manager","title":"<code>map_manager: MapManagerDE</code>  <code>property</code>","text":"Type: <code>MapManagerDE</code> <p>The map manager of the scenario</p>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.message_manager","title":"<code>message_manager: MessageManager</code>  <code>property</code>","text":"Type: <code>MessageManager</code>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.player_manager","title":"<code>player_manager: PlayerManager</code>  <code>property</code>","text":"Type: <code>PlayerManager</code> <p>The player manager of the scenario</p>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.trigger_manager","title":"<code>trigger_manager: TriggerManagerDE</code>  <code>property</code>","text":"Type: <code>TriggerManagerDE</code> <p>The trigger manager of the scenario</p>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.unit_manager","title":"<code>unit_manager: UnitManagerDE</code>  <code>property</code>","text":"Type: <code>UnitManagerDE</code> <p>The unit manager of the scenario</p>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.xs_manager","title":"<code>xs_manager: XsManagerDE</code>  <code>property</code>","text":"Type: <code>XsManagerDE</code> <p>The XS manager of the scenario</p>"},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario-functions","title":"Functions","text":""},{"location":"api_docs/aoe2_de_scenario/#AoE2ScenarioParser.scenarios.aoe2_de_scenario.AoE2DEScenario.from_file","title":"<code>def from_file(...)</code>  <code>classmethod</code>","text":"<p>Creates and returns an instance of the AoE2DEScenario class from the given scenario file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the scenario file to create the object from</p> required <code>game_version</code> <code>str</code> <p>The version of the game to create the object for</p> <code>'DE'</code> <code>name</code> <code>str</code> <p>The name given to this scenario (defaults to the filename without extension)</p> <code>''</code> <p>Returns:</p> Type Description <code>S</code> <p>An instance of the AoE2DEScenario class which is the object representation of the given scenario file</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_de_scenario.py</code> <pre><code>@classmethod\ndef from_file(cls: Type[S], path: str, game_version: str = \"DE\", name: str = \"\") -&gt; S:\n    \"\"\"\n    Creates and returns an instance of the AoE2DEScenario class from the given scenario file\n\n    Args:\n        path: The path to the scenario file to create the object from\n        game_version: The version of the game to create the object for\n        name: The name given to this scenario (defaults to the filename without extension)\n\n    Returns:\n        An instance of the AoE2DEScenario class which is the object representation of the given scenario file\n    \"\"\"\n    return super().from_file(path=path, game_version=game_version, name=name)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/","title":"AoE2Scenario","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario-attributes","title":"Attributes","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.Func","title":"<code>Func: TypeVar = TypeVar('Func', bound='Callable[[Any], Any]')</code>  <code>module-attribute</code>","text":"Type: <code>TypeVar</code>                           Value: <code>TypeVar('Func', bound='Callable[[Any], Any]')</code> <p>A type variable (generic) that represents a function</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.S","title":"<code>S: TypeVar = TypeVar('S', bound='AoE2Scenario')</code>  <code>module-attribute</code>","text":"Type: <code>TypeVar</code>                           Value: <code>TypeVar('S', bound='AoE2Scenario')</code> <p>A type variable (generic) that represents an instance of the AoE2Scenario class or any of its  subclasses (e.g. <code>AoE2DEScenario</code>)</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario-classes","title":"Classes","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario","title":"<code>AoE2Scenario</code>","text":"<p>All scenario objects are derived from this class</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>class AoE2Scenario:\n    \"\"\"All scenario objects are derived from this class\"\"\"\n\n    @property\n    def trigger_manager(self) -&gt; TriggerManager:\n        \"\"\"The trigger manager of the scenario\"\"\"\n        return self._object_manager.managers['Trigger']\n\n    @property\n    def unit_manager(self) -&gt; UnitManager:\n        \"\"\"The unit manager of the scenario\"\"\"\n        return self._object_manager.managers['Unit']\n\n    @property\n    def map_manager(self) -&gt; MapManager:\n        \"\"\"The map manager of the scenario\"\"\"\n        return self._object_manager.managers['Map']\n\n    @property\n    def player_manager(self) -&gt; PlayerManager:\n        \"\"\"The player manager of the scenario\"\"\"\n        return self._object_manager.managers['Player']\n\n    @property\n    def message_manager(self) -&gt; MessageManager:\n        \"\"\"The message manager of the scenario\"\"\"\n        return self._object_manager.managers['Message']\n\n    def on_write(self, func: Func) -&gt; Func:\n        \"\"\"Register a function to be called on write (intended to be used as a decorator)\"\"\"\n        self._on_write_funcs.append(func)\n        return func\n\n    @property\n    def scenario_version_tuple(self) -&gt; tuple[int, ...]:\n        return tuple(map(int, self.scenario_version.split('.')))\n\n    def __init__(\n        self,\n        game_version: str,\n        scenario_version: str,\n        source_location: str,\n        name: str,\n        variant: ScenarioVariant | None = None\n    ):\n        # Scenario meta info\n        self.game_version: str = game_version\n        self.scenario_version: str = scenario_version\n        self.source_location: str = source_location\n        self._variant: ScenarioVariant | None = variant\n        self._time_start: float = time.time()\n\n        # Actual scenario content\n        self.structure: Dict = {}\n        self.sections: Dict[str, AoE2FileSection] = {}\n        self._object_manager: AoE2ObjectManager | None = None\n\n        # For Scenario Store functionality\n        self.name: str = name\n        self.uuid: UUID = uuid4()\n        store.register_scenario(self)\n\n        # Actions through the scenario\n        self.new: ObjectFactory = ObjectFactory(self.uuid)\n        self.actions: ScenarioActions = ScenarioActions(self.uuid)\n\n        # Used in debug functions\n        self._file = None\n        self._file_header = None\n        self._decompressed_file_data = None\n\n        # Callbacks\n        self._on_write_funcs = []\n\n    @classmethod\n    def from_file(\n        cls: Type[S],\n        path: str,\n        game_version: str,\n        name: str = \"\"\n    ) -&gt; S:\n        \"\"\"\n        Creates and returns an instance of the AoE2Scenario class from the given scenario file\n\n        Args:\n            path: The path to the scenario file to create the object from\n            game_version: The version of the game to create the object for\n            name: The name given to this scenario (defaults to the filename without extension)\n\n        Returns:\n            An instance of the AoE2Scenario class (or any of its subclasses) which is the object representation of\n                the given scenario file\n        \"\"\"\n        python_version_check()\n\n        filepath = Path(path)\n        if not filepath.is_file():\n            raise ValueError(f\"Unable to read file from path '{filepath}'\")\n\n        name = name or filepath.stem\n\n        s_print(f\"Reading file: \" + color_string(f\"'{path}'\", \"magenta\"), final=True, time=True, newline=True)\n        s_print(\"Reading scenario file...\")\n        igenerator = IncrementalGenerator.from_file(path)\n        s_print(\"Reading scenario file finished successfully.\", final=True, time=True)\n\n        scenario_version = _get_file_version(igenerator)\n        scenario_variant = _get_scenario_variant(igenerator)\n\n        scenario: S = cls(game_version, scenario_version, source_location=path, name=name, variant=scenario_variant)\n\n        variant: str = 'Unknown' if scenario.variant is None else scenario_variant.to_display_name()\n\n        # Log game and scenario version\n        s_print(\"\\n############### Attributes ###############\", final=True, color=\"blue\")\n        s_print(f\"&gt;&gt;&gt; Game version: '{scenario.game_version}'\", final=True, color=\"blue\")\n        s_print(f\"&gt;&gt;&gt; Scenario version: {scenario.scenario_version}\", final=True, color=\"blue\")\n        s_print(f\"&gt;&gt;&gt; Scenario variant: '{variant}'\", final=True, color= \"blue\")\n        s_print(\"##########################################\", final=True, color=\"blue\")\n\n        s_print(f\"Loading scenario structure...\", time=True, newline=True)\n        scenario._load_structure()\n        _initialise_version_dependencies(scenario.game_version, scenario.scenario_version)\n        s_print(f\"Loading scenario structure finished successfully.\", final=True, time=True)\n\n        # scenario._initialize(igenerator)\n        s_print(\"Parsing scenario file...\", final=True, time=True)\n        scenario._load_header_section(igenerator)\n        scenario._load_content_sections(igenerator)\n        s_print(f\"Parsing scenario file finished successfully.\", final=True, time=True)\n        scenario.igenerator = igenerator\n\n        scenario._object_manager = AoE2ObjectManager(scenario.uuid)\n        scenario._object_manager.setup()\n\n        return scenario\n\n    @staticmethod\n    def get_scenario(\n        uuid: UUID = None,\n        obj: 'AoE2Object' = None,\n        name: str = None\n    ) -&gt; S:\n        \"\"\"\n        Get scenario through a UUID, a related object or the name of a scenario.\n\n        Args:\n            uuid: The UUID of the scenario\n            obj: An object related to a scenario\n            name: The name of a scenario\n\n        Returns:\n            The scenario based on the given identifier, or `None`\n        \"\"\"\n        return store.get_scenario(uuid=uuid, obj=obj, name=name)\n\n    def _load_structure(self) -&gt; None:\n        \"\"\"\n        Loads the structure json for the scenario and game version specified into self.structure\n\n        Raises:\n            ValueError: if the game or scenario versions are not set\n        \"\"\"\n        if self.game_version == \"???\" or self.scenario_version == \"???\":\n            raise ValueError(\"Both game and scenario version need to be set to load structure\")\n        self.structure = _get_structure(self.game_version, self.scenario_version)\n\n    def _load_header_section(self, raw_file_igenerator: IncrementalGenerator) -&gt; None:\n        \"\"\"\n        Reads and adds the header file section to the sections dict of the scenario.\n\n        The header is stored decompressed and is the first thing in the scenario file. It is meta data for the scenario\n        file and thus needs to be read before everything else (also the reason why its stored decompressed).\n\n        Args:\n            raw_file_igenerator: The generator to read the header section from\n        \"\"\"\n        header = self._create_and_load_section('FileHeader', raw_file_igenerator)\n        self._file_header = raw_file_igenerator.file_content[:raw_file_igenerator.progress]\n        self._add_to_sections(header)\n\n    def _load_content_sections(self, raw_file_igenerator: IncrementalGenerator) -&gt; None:\n        \"\"\"\n        Reads and adds all the remaining file sections from the structure file to the sections dict of the\n        scenario.\n\n        The sections after the header are compressed and are first decompressed using the -zlib.MAX_WBITS algorithm.\n\n        Args:\n            raw_file_igenerator: The generator to read the file sections from\n        \"\"\"\n        self._decompressed_file_data = _decompress_bytes(raw_file_igenerator.get_remaining_bytes())\n\n        data_igenerator = IncrementalGenerator(name='Scenario Data', file_content=self._decompressed_file_data)\n\n        for section_name in self.structure.keys():\n            if section_name == \"FileHeader\":\n                continue\n            try:\n                section = self._create_and_load_section(section_name, data_igenerator)\n                self._add_to_sections(section)\n            except (ValueError, TypeError) as e:\n                print(f\"\\n[{e.__class__.__name__}] AoE2Scenario.parse_file: \\n\\tSection: {section_name}\\n\")\n                self.write_error_file(trail_generator=data_igenerator)\n                raise e\n\n    def _create_and_load_section(self, name: str, igenerator: IncrementalGenerator) -&gt; AoE2FileSection:\n        \"\"\"\n        Initialises a file section from its name and fills its retrievers with data from the given generator\n\n        Args:\n            name: The name of the file section\n            igenerator: The generator to fill the data from\n\n        Returns:\n            An AoE2FileSection representing the given section name with its data initialised from the generator\n        \"\"\"\n        s_print(f\"\\t\ud83d\udd04 Parsing {name}...\", color=\"yellow\")\n        section = AoE2FileSection.from_structure(name, self.structure.get(name), self.uuid)\n        s_print(f\"\\t\ud83d\udd04 Gathering {name} data...\", color=\"yellow\")\n        section.set_data_from_generator(igenerator)\n        s_print(f\"\\t\u2714 {name}\", final=True, color=\"green\")\n        return section\n\n    def _add_to_sections(self, section: AoE2FileSection) -&gt; None:\n        \"\"\"\n        Adds the given section to the sections dictionary\n\n        Args:\n            section: The section to add to the sections dictionary\n        \"\"\"\n        self.sections[section.name] = section\n\n    def remove_store_reference(self) -&gt; None:\n        \"\"\"\n        This function is **DEPRECATED**. No replacement is necessary as the store now uses weak references.\n        You can safely remove the call to this function.\n\n        --- Legacy docstring ---\n\n        Removes the reference to this scenario object from the scenario store. Useful (~a must) when reading many\n        scenarios in a row without needing earlier ones. Python likes to take up a lot of memory.\n        Removing all references to an object will cause the memory to be cleared up.\n\n        Warning: Remove all other references too!\n            When using this function it's important to remove all other references to the scenario.\n            So if save it in a dict or list, remove it from it.\n            If you have variables referencing this scenario that you won't need anymore (and won't overwrite) delete\n            them using: `del varname`.\n        \"\"\"\n        warn(\"This function is DEPRECATED as the store now uses weak references. \\n\"\n             \"You can safely remove the call to this function.\", DeprecationWarning)\n        store.remove_scenario(self.uuid)\n\n    def commit(self) -&gt; None:\n        \"\"\"Commit the changes to the retriever backend made within the managers.\"\"\"\n        self._object_manager.reconstruct()\n\n    \"\"\" ##########################################################################################\n    ####################################### Write functions ######################################\n    ########################################################################################## \"\"\"\n\n    def write_to_file(self, filename: str, skip_reconstruction: bool = False) -&gt; None:\n        \"\"\"\n        Writes the scenario to a new file with the given filename\n\n        Args:\n            filename: The location to write the file to\n            skip_reconstruction: If reconstruction should be skipped. If true, this will ignore all changes made\n                using the managers (For example all changes made using trigger_manager).\n\n        Raises:\n            ValueError: if the setting DISABLE_ERROR_ON_OVERWRITING_SOURCE is not disabled and the source filename is\n                the same as the filename being written to\n        \"\"\"\n        self._write_from_structure(filename, skip_reconstruction)\n\n    def _write_from_structure(self, filename: str, skip_reconstruction: bool = False) -&gt; None:\n        \"\"\"\n        Writes the scenario to a new file with the given filename\n\n        Args:\n            filename: The location to write the file to\n            skip_reconstruction: If reconstruction should be skipped. If true, this will ignore all changes made\n                using the managers (For example all changes made using trigger_manager).\n\n        Raises:\n            ValueError: if the setting DISABLE_ERROR_ON_OVERWRITING_SOURCE is not disabled and the source filename is\n                the same as the filename being written to\n        \"\"\"\n        if settings.ALLOW_OVERWRITING_SOURCE and self.source_location == filename:\n            raise ValueError(\"Overwriting the source scenario file is discouraged &amp; disallowed. \")\n\n        for func in self._on_write_funcs:\n            func(self)\n\n        # Update the internal file name to match the output filename\n        self._update_internal_filename(filename)\n\n        if not skip_reconstruction:\n            self.commit()\n\n        self._validate_scenario_variant()\n\n        s_print(\"File writing from structure started...\", final=True, time=True, newline=True)\n        binary = _get_file_section_data(self.sections.get('FileHeader'))\n\n        binary_list_to_be_compressed = []\n        for file_part in self.sections.values():\n            if file_part.name == \"FileHeader\":\n                continue\n            binary_list_to_be_compressed.append(_get_file_section_data(file_part))\n\n        compressed = _compress_bytes(b''.join(binary_list_to_be_compressed))\n\n        with open(filename, 'wb') as f:\n            f.write(binary + compressed)\n\n        etime = round(time.time() - self._time_start, 2)\n        s_print(\"File writing finished successfully.\", final=True, time=True)\n        s_print(f\"File successfully written to: \" + color_string(f\"'{filename}'\", \"magenta\"), final=True, time=True)\n        s_print(f\"Execution time from scenario read: {etime}s\", final=True, time=True)\n\n    def write_error_file(self, filename: str = \"error_file.txt\", trail_generator: IncrementalGenerator = None) -&gt; None:\n        \"\"\"\n        Outputs the contents of the entire scenario file in a readable format. An example of the format is given below::\n\n            ########################### units (1954 * struct:UnitStruct)\n            ############ UnitStruct ############  [STRUCT]\n            00 00 70 42                 x (1 * f32): 60.0\n            00 00 70 42                 y (1 * f32): 60.0\n            00 00 00 00                 z (1 * f32): 0.0\n            52 05 00 00                 reference_id (1 * s32): 1362\n            89 02                       unit_const (1 * u16): 649\n            02                          status (1 * u8): 2\n            00 00 00 00                 rotation (1 * f32): 0.0\n            00 00                       initial_animation_frame (1 * u16): 0\n            ff ff ff ff                 garrisoned_in_id (1 * s32): -1\n\n        Args:\n            filename: The filename to write the error file to\n            trail_generator: Write all the bytes remaining in this generator as a trail\n        \"\"\"\n        self._debug_byte_structure_to_file(filename=filename, trail_generator=trail_generator)\n\n    \"\"\" #############################################\n    ############### Variant functions ###############\n    ############################################# \"\"\"\n\n    @property\n    def variant(self) -&gt; ScenarioVariant:\n        return self._variant\n\n    @variant.setter\n    def variant(self, value: None | str | int | ScenarioVariant):\n        if value is None:\n            self._variant = None\n            return\n        elif isinstance(value, ScenarioVariant):\n            self._variant = value\n        elif isinstance(value, int):\n            self._variant = ScenarioVariant(value)\n        elif isinstance(value, str):\n            self._variant = ScenarioVariant[value.upper()]\n        else:\n            raise ValueError(f\"Incorrect value used for setting scenario variant: '{value}'\")\n\n        self._update_variant_retrievers()\n        self._validate_scenario_variant()\n\n    def _validate_scenario_variant(self):\n        if self.variant is None:\n            self._warn_variant_unknown()\n            return\n\n        # If the header has been adjusted manually (solution before this functionality went live)\n        if self.sections[\"FileHeader\"].unknown_value_2 != self.variant.value:\n            self.variant = self.sections[\"FileHeader\"].unknown_value_2\n\n        if self.variant == ScenarioVariant.ROR and self.scenario_version_tuple &lt; (1, 49):\n            raise UnsupportedVersionError(\n                f\"\\n\\nScenarios with a version below 1.49 (currently: {self.scenario_version}) cannot be written as \"\n                f\"Return of Rome scenarios.\\n\"\n                \"Upgrade the scenario by saving it in the in-game editor before converting it.\"\n            )\n\n        if self.variant not in [ScenarioVariant.AOE2, ScenarioVariant.ROR] and settings.SHOW_VARIANT_WARNINGS:\n            applicants = self.variant.applicants()\n            name = self.variant.name\n\n            warn(\n                f\"Having the scenario variant set to '{name}' (applies to: '{applicants}') will cause the scenario \"\n                f\"to not be visible within the Definitive Edition.\\n\"\n                f\"If this is unintentional, you can set `scenario.variant` to 'aoe2' or 'ror'`\\n\"\n                f\"If this is intentional, you can disable this warning using the \"\n                f\"setting: `SHOW_VARIANT_WARNINGS`\", IncorrectVariantWarning\n            )\n\n    def _warn_variant_unknown(self):\n        if not settings.SHOW_VARIANT_WARNINGS:\n            return\n\n        warn(\n            f\"The current scenario variant is unknown. It's possible this will cause the scenario to be hidden.\\n\"\n            f\"If this is unintentional, you can set `scenario.variant` to 'aoe2' or 'ror' to make sure it's visible.\\n\"\n            f\"If this is intentional, you can disable this warning using the \"\n            f\"setting: `SHOW_VARIANT_WARNINGS`\", IncorrectVariantWarning\n        )\n\n    def _update_variant_retrievers(self):\n        if self.variant.value == self.sections[\"FileHeader\"].unknown_value_2:\n            return\n\n        dlcs = {\n            ScenarioVariant.LEGACY: [],\n            ScenarioVariant.AOE2: [2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n            ScenarioVariant.ROR: [11]\n        }[self.variant]\n\n        self.sections[\"FileHeader\"].unknown_value_2 = self.variant.value\n        self.sections[\"FileHeader\"].amount_of_unknown_numbers = len(dlcs)\n        self.sections[\"FileHeader\"].unknown_numbers = dlcs\n\n    def _update_internal_filename(self, filename: str) -&gt; None:\n        self.sections['DataHeader'].filename = Path(filename).stem\n\n    \"\"\" #############################################\n    ################ Debug functions ################\n    ############################################# \"\"\"\n\n    def _debug_compare(\n            self,\n            other: AoE2Scenario,\n            filename: str = \"differences.txt\",\n            commit: bool = False,\n            *,\n            allow_multiple_versions: bool = False\n    ) -&gt; None:\n        \"\"\"\n        Compare a scenario to a given scenario and report the differences found\n\n        Args:\n            other: The scenario to compare it to\n            filename: The debug file to write the differences to (Defaults to \"differences.txt\")\n            commit: If the scenarios need to commit their manager changes before comparing (Defaults to False)\n            allow_multiple_versions: Allow comparison between multiple versions. (Please note that this is not tested\n                thoroughly at all)\n        \"\"\"\n        debug_compare(self, other, filename, commit, allow_multiple_versions=allow_multiple_versions)\n\n    def _debug_write_from_source(self, filename: str, datatype: str, write_bytes: bool = True) -&gt; None:\n        \"\"\"\n        Writes the decompressed scenario file as bytes or as hex text\n\n        Args:\n            filename: The filename to write to\n            datatype: these are flags that indicate which parts of the file to include in the output. 'd' for\n                decompressed file data, 'f' for the file, and 'h' for the header. Note: Only 'd' actually works at this\n                time\n            write_bytes: boolean to determine if the file needs to be written as bytes or hex text form\n        \"\"\"\n        s_print(\"File writing from source started with attributes \" + datatype + \"...\")\n        file = open(filename, \"wb\" if write_bytes else \"w\")\n        selected_parts = []\n        for t in datatype:\n            if t == \"f\":\n                selected_parts.append(self._file)\n            elif t == \"h\":\n                selected_parts.append(self._file_header)\n            elif t == \"d\":\n                selected_parts.append(self._decompressed_file_data)\n        parts = None\n        for part in selected_parts:\n            if parts is None:\n                parts = part\n                continue\n            parts += part\n        file.write(parts if write_bytes else create_textual_hex(parts.hex()))\n        file.close()\n        s_print(\"File writing finished successfully.\")\n\n    def _debug_byte_structure_to_file(self, filename, trail_generator: IncrementalGenerator = None, commit=False):\n        \"\"\"\n        Outputs the contents of the entire scenario file in a readable format. An example of the format is given below::\n\n            ########################### units (1954 * struct:UnitStruct)\n            ############ UnitStruct ############  [STRUCT]\n            00 00 70 42                 x (1 * f32): 60.0\n            00 00 70 42                 y (1 * f32): 60.0\n            00 00 00 00                 z (1 * f32): 0.0\n            52 05 00 00                 reference_id (1 * s32): 1362\n            89 02                       unit_const (1 * u16): 649\n            02                          status (1 * u8): 2\n            00 00 00 00                 rotation (1 * f32): 0.0\n            00 00                       initial_animation_frame (1 * u16): 0\n            ff ff ff ff                 garrisoned_in_id (1 * s32): -1\n\n        Args:\n            filename: The filename to write the error file to\n            trail_generator: Write all the bytes remaining in this generator as a trail\n            commit: If the managers should commit their changes before writing this file.\n        \"\"\"\n        if commit and hasattr(self, '_object_manager'):\n            self.commit()\n\n        s_print(\"Writing structure to file...\", final=True, time=True, newline=True)\n\n        result = []\n        for section in self.sections.values():\n            s_print(f\"\\t\ud83d\udd04 Writing {section.name}...\", color=\"yellow\")\n            result.append(section.get_byte_structure_as_string())\n            s_print(f\"\\t\u2714 {section.name}\", final=True, color=\"green\")\n\n        if trail_generator is not None:\n            s_print(\"\\tWriting trail...\")\n            trail = trail_generator.get_remaining_bytes()\n\n            result.append(f\"\\n\\n{'#' * 27} TRAIL ({len(trail)})\\n\\n\")\n            result.append(create_textual_hex(trail.hex(), space_distance=2, enter_distance=24))\n            s_print(\"\\tWriting trail finished successfully.\", final=True)\n\n        with open(filename, 'w', encoding=settings.MAIN_CHARSET) as f:\n            f.write(''.join(result))\n        s_print(\"Writing structure to file finished successfully.\", final=True, time=True)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario-attributes","title":"Attributes","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.actions","title":"<code>actions: ScenarioActions = ScenarioActions(self.uuid)</code>  <code>instance-attribute</code>","text":"Type: <code>ScenarioActions</code>                           Value: <code>ScenarioActions(self.uuid)</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.game_version","title":"<code>game_version: str = game_version</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>game_version</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.map_manager","title":"<code>map_manager: MapManager</code>  <code>property</code>","text":"Type: <code>MapManager</code> <p>The map manager of the scenario</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.message_manager","title":"<code>message_manager: MessageManager</code>  <code>property</code>","text":"Type: <code>MessageManager</code> <p>The message manager of the scenario</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.name","title":"<code>name: str = name</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>name</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.new","title":"<code>new: ObjectFactory = ObjectFactory(self.uuid)</code>  <code>instance-attribute</code>","text":"Type: <code>ObjectFactory</code>                           Value: <code>ObjectFactory(self.uuid)</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.player_manager","title":"<code>player_manager: PlayerManager</code>  <code>property</code>","text":"Type: <code>PlayerManager</code> <p>The player manager of the scenario</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.scenario_version","title":"<code>scenario_version: str = scenario_version</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>scenario_version</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.scenario_version_tuple","title":"<code>scenario_version_tuple: tuple[int, ...]</code>  <code>property</code>","text":"Type: <code>tuple[int, ...]</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.sections","title":"<code>sections: Dict[str, AoE2FileSection] = {}</code>  <code>instance-attribute</code>","text":"Type: <code>Dict[str, AoE2FileSection]</code>                           Value: <code>{}</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.source_location","title":"<code>source_location: str = source_location</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>source_location</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.structure","title":"<code>structure: Dict = {}</code>  <code>instance-attribute</code>","text":"Type: <code>Dict</code>                           Value: <code>{}</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.trigger_manager","title":"<code>trigger_manager: TriggerManager</code>  <code>property</code>","text":"Type: <code>TriggerManager</code> <p>The trigger manager of the scenario</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.unit_manager","title":"<code>unit_manager: UnitManager</code>  <code>property</code>","text":"Type: <code>UnitManager</code> <p>The unit manager of the scenario</p>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.uuid","title":"<code>uuid: UUID = uuid4()</code>  <code>instance-attribute</code>","text":"Type: <code>UUID</code>                           Value: <code>uuid4()</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.variant","title":"<code>variant: ScenarioVariant</code>  <code>property</code> <code>writable</code>","text":"Type: <code>ScenarioVariant</code>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario-functions","title":"Functions","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>game_version</code> <code>str</code>  - required <code>scenario_version</code> <code>str</code>  - required <code>source_location</code> <code>str</code>  - required <code>name</code> <code>str</code>  - required <code>variant</code> <code>ScenarioVariant | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def __init__(\n    self,\n    game_version: str,\n    scenario_version: str,\n    source_location: str,\n    name: str,\n    variant: ScenarioVariant | None = None\n):\n    # Scenario meta info\n    self.game_version: str = game_version\n    self.scenario_version: str = scenario_version\n    self.source_location: str = source_location\n    self._variant: ScenarioVariant | None = variant\n    self._time_start: float = time.time()\n\n    # Actual scenario content\n    self.structure: Dict = {}\n    self.sections: Dict[str, AoE2FileSection] = {}\n    self._object_manager: AoE2ObjectManager | None = None\n\n    # For Scenario Store functionality\n    self.name: str = name\n    self.uuid: UUID = uuid4()\n    store.register_scenario(self)\n\n    # Actions through the scenario\n    self.new: ObjectFactory = ObjectFactory(self.uuid)\n    self.actions: ScenarioActions = ScenarioActions(self.uuid)\n\n    # Used in debug functions\n    self._file = None\n    self._file_header = None\n    self._decompressed_file_data = None\n\n    # Callbacks\n    self._on_write_funcs = []\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.commit","title":"<code>def commit(...)</code>","text":"<p>Commit the changes to the retriever backend made within the managers.</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def commit(self) -&gt; None:\n    \"\"\"Commit the changes to the retriever backend made within the managers.\"\"\"\n    self._object_manager.reconstruct()\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.from_file","title":"<code>def from_file(...)</code>  <code>classmethod</code>","text":"<p>Creates and returns an instance of the AoE2Scenario class from the given scenario file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the scenario file to create the object from</p> required <code>game_version</code> <code>str</code> <p>The version of the game to create the object for</p> required <code>name</code> <code>str</code> <p>The name given to this scenario (defaults to the filename without extension)</p> <code>''</code> <p>Returns:</p> Type Description <code>S</code> <p>An instance of the AoE2Scenario class (or any of its subclasses) which is the object representation of the given scenario file</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>@classmethod\ndef from_file(\n    cls: Type[S],\n    path: str,\n    game_version: str,\n    name: str = \"\"\n) -&gt; S:\n    \"\"\"\n    Creates and returns an instance of the AoE2Scenario class from the given scenario file\n\n    Args:\n        path: The path to the scenario file to create the object from\n        game_version: The version of the game to create the object for\n        name: The name given to this scenario (defaults to the filename without extension)\n\n    Returns:\n        An instance of the AoE2Scenario class (or any of its subclasses) which is the object representation of\n            the given scenario file\n    \"\"\"\n    python_version_check()\n\n    filepath = Path(path)\n    if not filepath.is_file():\n        raise ValueError(f\"Unable to read file from path '{filepath}'\")\n\n    name = name or filepath.stem\n\n    s_print(f\"Reading file: \" + color_string(f\"'{path}'\", \"magenta\"), final=True, time=True, newline=True)\n    s_print(\"Reading scenario file...\")\n    igenerator = IncrementalGenerator.from_file(path)\n    s_print(\"Reading scenario file finished successfully.\", final=True, time=True)\n\n    scenario_version = _get_file_version(igenerator)\n    scenario_variant = _get_scenario_variant(igenerator)\n\n    scenario: S = cls(game_version, scenario_version, source_location=path, name=name, variant=scenario_variant)\n\n    variant: str = 'Unknown' if scenario.variant is None else scenario_variant.to_display_name()\n\n    # Log game and scenario version\n    s_print(\"\\n############### Attributes ###############\", final=True, color=\"blue\")\n    s_print(f\"&gt;&gt;&gt; Game version: '{scenario.game_version}'\", final=True, color=\"blue\")\n    s_print(f\"&gt;&gt;&gt; Scenario version: {scenario.scenario_version}\", final=True, color=\"blue\")\n    s_print(f\"&gt;&gt;&gt; Scenario variant: '{variant}'\", final=True, color= \"blue\")\n    s_print(\"##########################################\", final=True, color=\"blue\")\n\n    s_print(f\"Loading scenario structure...\", time=True, newline=True)\n    scenario._load_structure()\n    _initialise_version_dependencies(scenario.game_version, scenario.scenario_version)\n    s_print(f\"Loading scenario structure finished successfully.\", final=True, time=True)\n\n    # scenario._initialize(igenerator)\n    s_print(\"Parsing scenario file...\", final=True, time=True)\n    scenario._load_header_section(igenerator)\n    scenario._load_content_sections(igenerator)\n    s_print(f\"Parsing scenario file finished successfully.\", final=True, time=True)\n    scenario.igenerator = igenerator\n\n    scenario._object_manager = AoE2ObjectManager(scenario.uuid)\n    scenario._object_manager.setup()\n\n    return scenario\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.get_scenario","title":"<code>def get_scenario(...)</code>  <code>staticmethod</code>","text":"<p>Get scenario through a UUID, a related object or the name of a scenario.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>UUID</code> <p>The UUID of the scenario</p> <code>None</code> <code>obj</code> <code>'AoE2Object'</code> <p>An object related to a scenario</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of a scenario</p> <code>None</code> <p>Returns:</p> Type Description <code>S</code> <p>The scenario based on the given identifier, or <code>None</code></p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>@staticmethod\ndef get_scenario(\n    uuid: UUID = None,\n    obj: 'AoE2Object' = None,\n    name: str = None\n) -&gt; S:\n    \"\"\"\n    Get scenario through a UUID, a related object or the name of a scenario.\n\n    Args:\n        uuid: The UUID of the scenario\n        obj: An object related to a scenario\n        name: The name of a scenario\n\n    Returns:\n        The scenario based on the given identifier, or `None`\n    \"\"\"\n    return store.get_scenario(uuid=uuid, obj=obj, name=name)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.on_write","title":"<code>def on_write(...)</code>","text":"<p>Register a function to be called on write (intended to be used as a decorator)</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Func</code>  - required Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def on_write(self, func: Func) -&gt; Func:\n    \"\"\"Register a function to be called on write (intended to be used as a decorator)\"\"\"\n    self._on_write_funcs.append(func)\n    return func\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.remove_store_reference","title":"<code>def remove_store_reference(...)</code>","text":"<p>This function is DEPRECATED. No replacement is necessary as the store now uses weak references. You can safely remove the call to this function.</p> <p>--- Legacy docstring ---</p> <p>Removes the reference to this scenario object from the scenario store. Useful (~a must) when reading many scenarios in a row without needing earlier ones. Python likes to take up a lot of memory. Removing all references to an object will cause the memory to be cleared up.</p> Remove all other references too! <p>When using this function it's important to remove all other references to the scenario. So if save it in a dict or list, remove it from it. If you have variables referencing this scenario that you won't need anymore (and won't overwrite) delete them using: <code>del varname</code>.</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def remove_store_reference(self) -&gt; None:\n    \"\"\"\n    This function is **DEPRECATED**. No replacement is necessary as the store now uses weak references.\n    You can safely remove the call to this function.\n\n    --- Legacy docstring ---\n\n    Removes the reference to this scenario object from the scenario store. Useful (~a must) when reading many\n    scenarios in a row without needing earlier ones. Python likes to take up a lot of memory.\n    Removing all references to an object will cause the memory to be cleared up.\n\n    Warning: Remove all other references too!\n        When using this function it's important to remove all other references to the scenario.\n        So if save it in a dict or list, remove it from it.\n        If you have variables referencing this scenario that you won't need anymore (and won't overwrite) delete\n        them using: `del varname`.\n    \"\"\"\n    warn(\"This function is DEPRECATED as the store now uses weak references. \\n\"\n         \"You can safely remove the call to this function.\", DeprecationWarning)\n    store.remove_scenario(self.uuid)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.write_error_file","title":"<code>def write_error_file(...)</code>","text":"<p>Outputs the contents of the entire scenario file in a readable format. An example of the format is given below::</p> <pre><code>########################### units (1954 * struct:UnitStruct)\n############ UnitStruct ############  [STRUCT]\n00 00 70 42                 x (1 * f32): 60.0\n00 00 70 42                 y (1 * f32): 60.0\n00 00 00 00                 z (1 * f32): 0.0\n52 05 00 00                 reference_id (1 * s32): 1362\n89 02                       unit_const (1 * u16): 649\n02                          status (1 * u8): 2\n00 00 00 00                 rotation (1 * f32): 0.0\n00 00                       initial_animation_frame (1 * u16): 0\nff ff ff ff                 garrisoned_in_id (1 * s32): -1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to write the error file to</p> <code>'error_file.txt'</code> <code>trail_generator</code> <code>IncrementalGenerator</code> <p>Write all the bytes remaining in this generator as a trail</p> <code>None</code> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def write_error_file(self, filename: str = \"error_file.txt\", trail_generator: IncrementalGenerator = None) -&gt; None:\n    \"\"\"\n    Outputs the contents of the entire scenario file in a readable format. An example of the format is given below::\n\n        ########################### units (1954 * struct:UnitStruct)\n        ############ UnitStruct ############  [STRUCT]\n        00 00 70 42                 x (1 * f32): 60.0\n        00 00 70 42                 y (1 * f32): 60.0\n        00 00 00 00                 z (1 * f32): 0.0\n        52 05 00 00                 reference_id (1 * s32): 1362\n        89 02                       unit_const (1 * u16): 649\n        02                          status (1 * u8): 2\n        00 00 00 00                 rotation (1 * f32): 0.0\n        00 00                       initial_animation_frame (1 * u16): 0\n        ff ff ff ff                 garrisoned_in_id (1 * s32): -1\n\n    Args:\n        filename: The filename to write the error file to\n        trail_generator: Write all the bytes remaining in this generator as a trail\n    \"\"\"\n    self._debug_byte_structure_to_file(filename=filename, trail_generator=trail_generator)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario.AoE2Scenario.write_to_file","title":"<code>def write_to_file(...)</code>","text":"<p>Writes the scenario to a new file with the given filename</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The location to write the file to</p> required <code>skip_reconstruction</code> <code>bool</code> <p>If reconstruction should be skipped. If true, this will ignore all changes made using the managers (For example all changes made using trigger_manager).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the setting DISABLE_ERROR_ON_OVERWRITING_SOURCE is not disabled and the source filename is the same as the filename being written to</p> Source code in <code>AoE2ScenarioParser/scenarios/aoe2_scenario.py</code> <pre><code>def write_to_file(self, filename: str, skip_reconstruction: bool = False) -&gt; None:\n    \"\"\"\n    Writes the scenario to a new file with the given filename\n\n    Args:\n        filename: The location to write the file to\n        skip_reconstruction: If reconstruction should be skipped. If true, this will ignore all changes made\n            using the managers (For example all changes made using trigger_manager).\n\n    Raises:\n        ValueError: if the setting DISABLE_ERROR_ON_OVERWRITING_SOURCE is not disabled and the source filename is\n            the same as the filename being written to\n    \"\"\"\n    self._write_from_structure(filename, skip_reconstruction)\n</code></pre>"},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario-functions","title":"Functions","text":""},{"location":"api_docs/aoe2_scenario/#AoE2ScenarioParser.scenarios.aoe2_scenario-modules","title":"Modules","text":""},{"location":"api_docs/settings/","title":"Settings","text":"IMPORT THE MODULE, NOT THE VALUES! <p>To change these settings, import the module: <code>from AoE2ScenarioParser import settings</code>. Then you can change the settings like: <code>settings.RAISE_ERROR_ON_WARNING = True</code></p> <p>If you import the values directly like: <code>from ... import RAISE_ERROR_ON_WARNING</code> (not written out because it wouldn't work), change the value would overwrite the reference and not the value which means the change wouldn't transfer to the <code>settings</code> module.</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings-attributes","title":"Attributes","text":""},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.NOTIFY_UNKNOWN_BYTES","title":"<code>NOTIFY_UNKNOWN_BYTES = True</code>  <code>module-attribute</code>","text":"Value: <code>True</code> <p>Show a notification of extra bytes being available at the end of the file, so you can notify the maintainer</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.PRINT_STATUS_UPDATES","title":"<code>PRINT_STATUS_UPDATES = True</code>  <code>module-attribute</code>","text":"Value: <code>True</code> <p>If status updates of what is being read and written should be printed to console</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.ALLOW_OVERWRITING_SOURCE","title":"<code>ALLOW_OVERWRITING_SOURCE = False</code>  <code>module-attribute</code>","text":"Value: <code>False</code> <p>Disable the error being raised when overwriting source scenario</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.ALLOW_DIRTY_RETRIEVER_OVERWRITE","title":"<code>ALLOW_DIRTY_RETRIEVER_OVERWRITE = False</code>  <code>module-attribute</code>","text":"Value: <code>False</code> <p>If it is allowed to overwrite a retriever that is dirty (it has been changed manually)</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.SHOW_VARIANT_WARNINGS","title":"<code>SHOW_VARIANT_WARNINGS = True</code>  <code>module-attribute</code>","text":"Value: <code>True</code> <p>If warnings about incorrect variants should be shown or not</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.MAIN_CHARSET","title":"<code>MAIN_CHARSET = 'utf-8'</code>  <code>module-attribute</code>","text":"Value: <code>'utf-8'</code> <p>The charset used to decode the text in the scenario. If it fails, will try the settings.FALLBACK_CHARSET</p>"},{"location":"api_docs/settings/#AoE2ScenarioParser.settings.FALLBACK_CHARSET","title":"<code>FALLBACK_CHARSET = 'latin-1'</code>  <code>module-attribute</code>","text":"Value: <code>'latin-1'</code> <p>The charset used to decode the text in the scenario when the settings.MAIN_CHARSET fails</p>"},{"location":"api_docs/map/map_manager/","title":"MapManager","text":""},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager-classes","title":"Classes","text":""},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager","title":"<code>MapManager</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of everything map related. This class does not include the logic for DE specific features. For those see: <code>MapManagerDE</code></p> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>class MapManager(AoE2Object):\n    \"\"\"\n    Manager of everything map related.\n    This class does not include the logic for DE specific features.\n    For those see: `MapManagerDE`\n    \"\"\"\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Map\", group=[\n            RetrieverObjectLink(\"map_width\", \"map_width\"),\n            RetrieverObjectLink(\"map_height\", \"map_height\"),\n            RetrieverObjectLink(\"terrain\", \"terrain_data\", process_as_object=TerrainTile),\n        ])\n    ]\n\n    def __init__(\n            self,\n            map_width: int,\n            map_height: int,\n            terrain: List[TerrainTile],\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        self.terrain: List[TerrainTile] = terrain\n        self._map_width: int = map_width\n        self._map_height: int = map_height\n\n    @property\n    def map_width(self) -&gt; int:\n        return self._map_width\n\n    @property\n    def map_height(self) -&gt; int:\n        return self._map_height\n\n    @property\n    def map_size(self) -&gt; int:\n        if self._map_height == self._map_width:\n            return self._map_height\n        else:\n            raise ValueError(\"Map is not a square. Use the attributes 'map_width' and 'map_height' instead.\")\n\n    @map_size.setter\n    def map_size(self, new_size: int):\n        old_size = self._map_width\n        difference = new_size - old_size\n\n        if difference == 0:\n            return\n\n        self._map_width = new_size\n        self._map_height = new_size\n\n        new_terrain = []\n        if difference &lt; 0:\n            # Remove ends of rows (x) &amp; remove final rows entirely (y)\n            for index, chunk in enumerate(list_chuncks(self.terrain, old_size)):\n                if index == new_size:\n                    break\n                new_terrain.extend(chunk[:new_size])\n        elif difference &gt; 0:\n            # Add ends to rows (x) &amp; add entirely new rows  (y)\n            chunk_gen = list_chuncks(self.terrain, old_size)\n            for index in range(new_size):\n                if index &lt; old_size:\n                    row = next(chunk_gen) + [TerrainTile(uuid=self._uuid) for _ in range(difference)]\n                else:\n                    row = [TerrainTile(uuid=self._uuid) for _ in range(new_size)]\n                new_terrain.extend(row)\n        self.terrain = new_terrain\n\n    @property\n    def terrain(self) -&gt; List[TerrainTile]:\n        return self._terrain\n\n    @terrain.setter\n    def terrain(self, value: List[TerrainTile]):\n        sqrt = math.sqrt(len(value))\n        if sqrt % 1 != 0:\n            raise ValueError(f\"Tiles do not represent a square map. (Given tile count: {len(value)})\")\n\n        def reset_indices(lst):\n            tile: TerrainTile\n            for index, tile in enumerate(lst):\n                tile._reset_terrain_index(index)\n\n        reset_indices(value)\n\n        if value is not None:\n            self._terrain = UuidList(\n                uuid=self._uuid,\n                seq=value,\n                on_update_execute_list=reset_indices\n            )\n        self._map_width = int(sqrt)\n        self._map_height = int(sqrt)\n\n    def get_tile(self, x: int = None, y: int = None, i: int = None) -&gt; TerrainTile:\n        \"\"\"\n        Get a tile on the map based on xy coordinates or using the index (`i`)\n\n        Args:\n            x: The x coordinate of the wanted tile (used together with y)\n            y: The y coordinate of the wanted tile (used together with x)\n            i: The index of the wanted tile\n\n        Raises:\n            ValueError: If parameters (`x` and/or `y`) and `i` are all set\n            ValueError: If the index requested is outside the index range of the terrain tiles\n\n        Returns:\n            The requested tile\n        \"\"\"\n        if i and (x or y):\n            raise ValueError(\"Cannot use both xy and i. Choose or XY or I.\")\n        if i is not None:\n            if 0 &lt;= i &lt; self.map_size:\n                return self.terrain[i]\n            else:\n                raise ValueError(\"Parameter i needs to be: 0 &lt;= i &lt; map_size\")\n        return self.terrain[xy_to_i(x, y, self.map_size)]\n\n    def get_tile_safe(self, x: int = None, y: int = None, i: int = None) -&gt; TerrainTile | None:\n        \"\"\"\n        Get a tile on the map based on xy coordinates or using the index (`i`).\n        If the index is outside the map, `None` is returned instead of an error\n\n        Args:\n            x: The x coordinate of the wanted tile (used together with y)\n            y: The y coordinate of the wanted tile (used together with x)\n            i: The index of the wanted tile\n\n        Returns:\n            The requested tile or `None` if it doesn't exist\n        \"\"\"\n        try:\n            return self.get_tile(x, y, i)\n        except (IndexError, ValueError):\n            return None\n\n    def get_square_1d(self, x1: int, y1: int, x2: int, y2: int) -&gt; List[TerrainTile]:\n        \"\"\"\n        Get a square of tiles from the map\n\n        Args:\n            x1: The x1 coordinate of the square\n            y1: The y1 coordinate of the square\n            x2: The x2 coordinate of the square\n            y2: The y2 coordinate of the square\n\n        Returns:\n            1D list of terrain tiles based on given coordinates\n        \"\"\"\n        result = []\n        for row in self._get_square_rows(x1, y1, x2, y2):\n            result.extend(row)\n        return result\n\n    def get_square_2d(self, x1: int, y1: int, x2: int, y2: int) -&gt; List[List[TerrainTile]]:\n        \"\"\"\n        Get a square of tiles from the map\n\n        Args:\n            x1: The x1 coordinate of the square\n            y1: The y1 coordinate of the square\n            x2: The x2 coordinate of the square\n            y2: The y2 coordinate of the square\n\n        Returns:\n            2D list of lists with terrain tiles based on given coordinates\n        \"\"\"\n        result = []\n        for row in self._get_square_rows(x1, y1, x2, y2):\n            result.append(row)\n        return result\n\n    def _get_square_rows(self, x1, y1, x2, y2):\n        row_nums = range(y1, y2 + 1)\n        for row in row_nums:\n            i1 = xy_to_i(x1, row, self.map_size)\n            i2 = xy_to_i(x2, row, self.map_size)\n            tiles = self.terrain[i1:i2 + 1]\n            yield tiles\n\n    def set_elevation(\n            self,\n            elevation: int,\n            x1: int,\n            y1: int,\n            x2: int | None = None,\n            y2: int | None = None\n    ) -&gt; None:\n        \"\"\"\n        Sets elevation like the in-game elevation mechanics. Can set a hill (or single point) to a certain height and\n        all tiles around it are adjusted accordingly.\n\n        If you find that the in-game mechanics work differently than this function please report it.\n\n        Args:\n            elevation: The elevation to create at the coordinates\n            x1: The x coordinate of the west corner\n            y1: The y coordinate of the west corner\n            x2: The x coordinate of the east corner\n            y2: The y coordinate of the east corner\n        \"\"\"\n        x2 = x1 if x2 is None else x2\n        y2 = y1 if y2 is None else y2\n\n        if x1 == x2 and y1 == y2:\n            edge_tiles = source_tiles = [self.get_tile(x1, y1)]\n            xys = [source_tiles[0].xy]\n        else:\n            source_tiles = self.get_square_2d(x1, y1, x2, y2)\n\n            # Reset current elevation within area\n            for row in source_tiles:\n                for tile in row:\n                    tile.elevation = elevation\n\n            xys = set(t.xy for row in source_tiles for t in row)\n            edge_tiles = source_tiles[0] + source_tiles[-1]\n            for i in range(1, len(source_tiles) - 1):\n                edge_tiles.extend([source_tiles[i][0], source_tiles[i][-1]])\n\n        for tile in edge_tiles:\n            self._elevation_tile_recursion(tile, xys)\n\n    def _elevation_tile_recursion(\n            self,\n            source_tile: TerrainTile,\n            xys: Set[Tuple[int, int]],\n            visited: Set[Tuple[int, int]] = None\n    ):\n        \"\"\"\n        Elevation recursive function. Used in the set_elevation function\n\n        Args:\n            source_tile: The tile to check around\n            xys: The XY tuples from the initial square\n            visited: The visited XY tuples with this recursion tree path\n        \"\"\"\n        visited = set() if visited is None else visited.copy()\n        x, y = source_tile.xy\n        visited.add((x, y))\n        for nx, ny in itertools.product(range(-1, 2), repeat=2):\n            new_x, new_y = x + nx, y + ny\n            if (nx or ny) and (new_x, new_y) not in xys and (new_x, new_y) not in visited:\n                other = self.get_tile_safe(new_x, new_y)\n                if other is None:\n                    continue\n                behind = self.get_tile_safe(x + nx * 2, y + ny * 2)\n                if behind is not None and other.elevation &lt; source_tile.elevation == behind.elevation:\n                    other.elevation = source_tile.elevation\n                elif abs(other.elevation - source_tile.elevation) &gt; 1:\n                    other.elevation = source_tile.elevation + int(sign(other.elevation, source_tile.elevation))\n                    self._elevation_tile_recursion(other, xys, visited)\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager-attributes","title":"Attributes","text":""},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.map_height","title":"<code>map_height: int</code>  <code>property</code>","text":"Type: <code>int</code>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.map_size","title":"<code>map_size: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.map_width","title":"<code>map_width: int</code>  <code>property</code>","text":"Type: <code>int</code>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.terrain","title":"<code>terrain: List[TerrainTile]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[TerrainTile]</code>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager-functions","title":"Functions","text":""},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>map_width</code> <code>int</code>  - required <code>map_height</code> <code>int</code>  - required <code>terrain</code> <code>List[TerrainTile]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def __init__(\n        self,\n        map_width: int,\n        map_height: int,\n        terrain: List[TerrainTile],\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    self.terrain: List[TerrainTile] = terrain\n    self._map_width: int = map_width\n    self._map_height: int = map_height\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.get_square_1d","title":"<code>def get_square_1d(...)</code>","text":"<p>Get a square of tiles from the map</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The x1 coordinate of the square</p> required <code>y1</code> <code>int</code> <p>The y1 coordinate of the square</p> required <code>x2</code> <code>int</code> <p>The x2 coordinate of the square</p> required <code>y2</code> <code>int</code> <p>The y2 coordinate of the square</p> required <p>Returns:</p> Type Description <code>List[TerrainTile]</code> <p>1D list of terrain tiles based on given coordinates</p> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def get_square_1d(self, x1: int, y1: int, x2: int, y2: int) -&gt; List[TerrainTile]:\n    \"\"\"\n    Get a square of tiles from the map\n\n    Args:\n        x1: The x1 coordinate of the square\n        y1: The y1 coordinate of the square\n        x2: The x2 coordinate of the square\n        y2: The y2 coordinate of the square\n\n    Returns:\n        1D list of terrain tiles based on given coordinates\n    \"\"\"\n    result = []\n    for row in self._get_square_rows(x1, y1, x2, y2):\n        result.extend(row)\n    return result\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.get_square_2d","title":"<code>def get_square_2d(...)</code>","text":"<p>Get a square of tiles from the map</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>The x1 coordinate of the square</p> required <code>y1</code> <code>int</code> <p>The y1 coordinate of the square</p> required <code>x2</code> <code>int</code> <p>The x2 coordinate of the square</p> required <code>y2</code> <code>int</code> <p>The y2 coordinate of the square</p> required <p>Returns:</p> Type Description <code>List[List[TerrainTile]]</code> <p>2D list of lists with terrain tiles based on given coordinates</p> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def get_square_2d(self, x1: int, y1: int, x2: int, y2: int) -&gt; List[List[TerrainTile]]:\n    \"\"\"\n    Get a square of tiles from the map\n\n    Args:\n        x1: The x1 coordinate of the square\n        y1: The y1 coordinate of the square\n        x2: The x2 coordinate of the square\n        y2: The y2 coordinate of the square\n\n    Returns:\n        2D list of lists with terrain tiles based on given coordinates\n    \"\"\"\n    result = []\n    for row in self._get_square_rows(x1, y1, x2, y2):\n        result.append(row)\n    return result\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.get_tile","title":"<code>def get_tile(...)</code>","text":"<p>Get a tile on the map based on xy coordinates or using the index (<code>i</code>)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate of the wanted tile (used together with y)</p> <code>None</code> <code>y</code> <code>int</code> <p>The y coordinate of the wanted tile (used together with x)</p> <code>None</code> <code>i</code> <code>int</code> <p>The index of the wanted tile</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters (<code>x</code> and/or <code>y</code>) and <code>i</code> are all set</p> <code>ValueError</code> <p>If the index requested is outside the index range of the terrain tiles</p> <p>Returns:</p> Type Description <code>TerrainTile</code> <p>The requested tile</p> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def get_tile(self, x: int = None, y: int = None, i: int = None) -&gt; TerrainTile:\n    \"\"\"\n    Get a tile on the map based on xy coordinates or using the index (`i`)\n\n    Args:\n        x: The x coordinate of the wanted tile (used together with y)\n        y: The y coordinate of the wanted tile (used together with x)\n        i: The index of the wanted tile\n\n    Raises:\n        ValueError: If parameters (`x` and/or `y`) and `i` are all set\n        ValueError: If the index requested is outside the index range of the terrain tiles\n\n    Returns:\n        The requested tile\n    \"\"\"\n    if i and (x or y):\n        raise ValueError(\"Cannot use both xy and i. Choose or XY or I.\")\n    if i is not None:\n        if 0 &lt;= i &lt; self.map_size:\n            return self.terrain[i]\n        else:\n            raise ValueError(\"Parameter i needs to be: 0 &lt;= i &lt; map_size\")\n    return self.terrain[xy_to_i(x, y, self.map_size)]\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.get_tile_safe","title":"<code>def get_tile_safe(...)</code>","text":"<p>Get a tile on the map based on xy coordinates or using the index (<code>i</code>). If the index is outside the map, <code>None</code> is returned instead of an error</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate of the wanted tile (used together with y)</p> <code>None</code> <code>y</code> <code>int</code> <p>The y coordinate of the wanted tile (used together with x)</p> <code>None</code> <code>i</code> <code>int</code> <p>The index of the wanted tile</p> <code>None</code> <p>Returns:</p> Type Description <code>TerrainTile | None</code> <p>The requested tile or <code>None</code> if it doesn't exist</p> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def get_tile_safe(self, x: int = None, y: int = None, i: int = None) -&gt; TerrainTile | None:\n    \"\"\"\n    Get a tile on the map based on xy coordinates or using the index (`i`).\n    If the index is outside the map, `None` is returned instead of an error\n\n    Args:\n        x: The x coordinate of the wanted tile (used together with y)\n        y: The y coordinate of the wanted tile (used together with x)\n        i: The index of the wanted tile\n\n    Returns:\n        The requested tile or `None` if it doesn't exist\n    \"\"\"\n    try:\n        return self.get_tile(x, y, i)\n    except (IndexError, ValueError):\n        return None\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager.MapManager.set_elevation","title":"<code>def set_elevation(...)</code>","text":"<p>Sets elevation like the in-game elevation mechanics. Can set a hill (or single point) to a certain height and all tiles around it are adjusted accordingly.</p> <p>If you find that the in-game mechanics work differently than this function please report it.</p> <p>Parameters:</p> Name Type Description Default <code>elevation</code> <code>int</code> <p>The elevation to create at the coordinates</p> required <code>x1</code> <code>int</code> <p>The x coordinate of the west corner</p> required <code>y1</code> <code>int</code> <p>The y coordinate of the west corner</p> required <code>x2</code> <code>int | None</code> <p>The x coordinate of the east corner</p> <code>None</code> <code>y2</code> <code>int | None</code> <p>The y coordinate of the east corner</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/managers/map_manager.py</code> <pre><code>def set_elevation(\n        self,\n        elevation: int,\n        x1: int,\n        y1: int,\n        x2: int | None = None,\n        y2: int | None = None\n) -&gt; None:\n    \"\"\"\n    Sets elevation like the in-game elevation mechanics. Can set a hill (or single point) to a certain height and\n    all tiles around it are adjusted accordingly.\n\n    If you find that the in-game mechanics work differently than this function please report it.\n\n    Args:\n        elevation: The elevation to create at the coordinates\n        x1: The x coordinate of the west corner\n        y1: The y coordinate of the west corner\n        x2: The x coordinate of the east corner\n        y2: The y coordinate of the east corner\n    \"\"\"\n    x2 = x1 if x2 is None else x2\n    y2 = y1 if y2 is None else y2\n\n    if x1 == x2 and y1 == y2:\n        edge_tiles = source_tiles = [self.get_tile(x1, y1)]\n        xys = [source_tiles[0].xy]\n    else:\n        source_tiles = self.get_square_2d(x1, y1, x2, y2)\n\n        # Reset current elevation within area\n        for row in source_tiles:\n            for tile in row:\n                tile.elevation = elevation\n\n        xys = set(t.xy for row in source_tiles for t in row)\n        edge_tiles = source_tiles[0] + source_tiles[-1]\n        for i in range(1, len(source_tiles) - 1):\n            edge_tiles.extend([source_tiles[i][0], source_tiles[i][-1]])\n\n    for tile in edge_tiles:\n        self._elevation_tile_recursion(tile, xys)\n</code></pre>"},{"location":"api_docs/map/map_manager/#AoE2ScenarioParser.objects.managers.map_manager-functions","title":"Functions","text":""},{"location":"api_docs/map/map_manager_de/","title":"MapManagerDE","text":""},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de-classes","title":"Classes","text":""},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE","title":"<code>MapManagerDE</code>","text":"<p>               Bases: <code>MapManager</code></p> <p>Manager of all DE map related features</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/map_manager_de.py</code> <pre><code>class MapManagerDE(MapManager):\n    \"\"\"Manager of all DE map related features\"\"\"\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Map\", group=[\n            RetrieverObjectLink(\"map_color_mood\"),\n            RetrieverObjectLink(\"collide_and_correct\"),\n            RetrieverObjectLink(\"villager_force_drop\", support=Support(since=1.37)),\n            RetrieverObjectLink(\"map_width\"),\n            RetrieverObjectLink(\"map_height\"),\n            RetrieverObjectLink(\"terrain\", link=\"terrain_data\", process_as_object=TerrainTile),\n        ])\n    ]\n\n    def __init__(self,\n                 map_color_mood: str,\n                 collide_and_correct: bool,\n                 villager_force_drop: bool,\n                 map_width: int,\n                 map_height: int,\n                 terrain: List[TerrainTile],\n                 **kwargs,\n                 ):\n        super().__init__(map_width, map_height, terrain, **kwargs)\n\n        self.map_color_mood: str = map_color_mood\n        self.collide_and_correct: bool = collide_and_correct\n        self.villager_force_drop: bool = villager_force_drop\n</code></pre>"},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE-attributes","title":"Attributes","text":""},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE.collide_and_correct","title":"<code>collide_and_correct: bool = collide_and_correct</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>collide_and_correct</code>"},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE.map_color_mood","title":"<code>map_color_mood: str = map_color_mood</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>map_color_mood</code>"},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE.villager_force_drop","title":"<code>villager_force_drop: bool = villager_force_drop</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>villager_force_drop</code>"},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE-functions","title":"Functions","text":""},{"location":"api_docs/map/map_manager_de/#AoE2ScenarioParser.objects.managers.de.map_manager_de.MapManagerDE.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>map_color_mood</code> <code>str</code>  - required <code>collide_and_correct</code> <code>bool</code>  - required <code>villager_force_drop</code> <code>bool</code>  - required <code>map_width</code> <code>int</code>  - required <code>map_height</code> <code>int</code>  - required <code>terrain</code> <code>List[TerrainTile]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/map_manager_de.py</code> <pre><code>def __init__(self,\n             map_color_mood: str,\n             collide_and_correct: bool,\n             villager_force_drop: bool,\n             map_width: int,\n             map_height: int,\n             terrain: List[TerrainTile],\n             **kwargs,\n             ):\n    super().__init__(map_width, map_height, terrain, **kwargs)\n\n    self.map_color_mood: str = map_color_mood\n    self.collide_and_correct: bool = collide_and_correct\n    self.villager_force_drop: bool = villager_force_drop\n</code></pre>"},{"location":"api_docs/map/terrain_tile/","title":"TerrainTile","text":""},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile-classes","title":"Classes","text":""},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile","title":"<code>TerrainTile</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Object for handling a tile in the map.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/terrain_tile.py</code> <pre><code>class TerrainTile(AoE2Object):\n    \"\"\"Object for handling a tile in the map.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Map\", \"terrain_data[__index__]\", group=[\n            RetrieverObjectLink(\"terrain_id\"),\n            RetrieverObjectLink(\"elevation\"),\n            RetrieverObjectLink(\"layer\"),\n        ]),\n        RetrieverObjectLink(\"_index\", retrieve_history_number=0),\n    ]\n\n    def __init__(self, terrain_id: int = TerrainId.GRASS_1, elevation: int = 0, layer: int = -1, _index: int = - 1,\n                 **kwargs):\n        self.terrain_id: int = terrain_id\n        self.elevation: int = elevation\n        self.layer: int = layer\n        self._index: int = _index\n        self._xy: Optional[Tuple[int, int]] = None\n\n        super().__init__(**kwargs)\n\n    @property\n    def x(self) -&gt; int:\n        \"\"\"The X coordinate of this tile on the map\"\"\"\n        return self.xy[0]\n\n    @property\n    def y(self) -&gt; int:\n        \"\"\"The Y coordinate of this tile on the map\"\"\"\n        return self.xy[1]\n\n    @property\n    def i(self) -&gt; int:\n        \"\"\"The index of this tile on the map\"\"\"\n        return self._index\n\n    @property\n    def xy(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        The X,Y coordinate of this tile on the map\n\n        Returns:\n            A tuple containing two integers representing the XY coordinates\n        \"\"\"\n        if not self._xy:\n            self._xy = i_to_xy(self._index, getters.get_map_size(self._uuid))\n        return self._xy\n\n    def _reset_terrain_index(self, new_index: int):\n        \"\"\"Reset the current terrain index\"\"\"\n        self._index = new_index\n        self._xy = None\n</code></pre>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile-attributes","title":"Attributes","text":""},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.elevation","title":"<code>elevation: int = elevation</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>elevation</code>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.i","title":"<code>i: int</code>  <code>property</code>","text":"Type: <code>int</code> <p>The index of this tile on the map</p>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.layer","title":"<code>layer: int = layer</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>layer</code>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.terrain_id","title":"<code>terrain_id: int = terrain_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>terrain_id</code>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.x","title":"<code>x: int</code>  <code>property</code>","text":"Type: <code>int</code> <p>The X coordinate of this tile on the map</p>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.xy","title":"<code>xy: Tuple[int, int]</code>  <code>property</code>","text":"Type: <code>Tuple[int, int]</code> <p>The X,Y coordinate of this tile on the map</p> <p>Returns:</p> Type Description <code>int</code> <p>A tuple containing two integers representing the XY coordinates</p>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.y","title":"<code>y: int</code>  <code>property</code>","text":"Type: <code>int</code> <p>The Y coordinate of this tile on the map</p>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile-functions","title":"Functions","text":""},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile.TerrainTile.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>terrain_id</code> <code>int</code>  - <code>GRASS_1</code> <code>elevation</code> <code>int</code>  - <code>0</code> <code>layer</code> <code>int</code>  - <code>-1</code> <code>_index</code> <code>int</code>  - <code>-1</code> <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/terrain_tile.py</code> <pre><code>def __init__(self, terrain_id: int = TerrainId.GRASS_1, elevation: int = 0, layer: int = -1, _index: int = - 1,\n             **kwargs):\n    self.terrain_id: int = terrain_id\n    self.elevation: int = elevation\n    self.layer: int = layer\n    self._index: int = _index\n    self._xy: Optional[Tuple[int, int]] = None\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile-functions","title":"Functions","text":""},{"location":"api_docs/map/terrain_tile/#AoE2ScenarioParser.objects.data_objects.terrain_tile-modules","title":"Modules","text":""},{"location":"api_docs/messages/message_manager/","title":"MessageManager","text":""},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager-classes","title":"Classes","text":""},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager","title":"<code>MessageManager</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of the everything message tab related.</p> Source code in <code>AoE2ScenarioParser/objects/managers/message_manager.py</code> <pre><code>class MessageManager(AoE2Object):\n    \"\"\"Manager of the everything message tab related.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Messages\", group=[\n            RetrieverObjectLink(\"instructions\", link=\"ascii_instructions\"),\n            RetrieverObjectLink(\"hints\", link=\"ascii_hints\"),\n            RetrieverObjectLink(\"victory\", link=\"ascii_victory\"),\n            RetrieverObjectLink(\"loss\", link=\"ascii_loss\"),\n            RetrieverObjectLink(\"history\", link=\"ascii_history\"),\n            RetrieverObjectLink(\"scouts\", link=\"ascii_scouts\"),\n\n            RetrieverObjectLink(\"instructions_string_table_id\", link=\"instructions\"),\n            RetrieverObjectLink(\"hints_string_table_id\", link=\"hints\"),\n            RetrieverObjectLink(\"victory_string_table_id\", link=\"victory\"),\n            RetrieverObjectLink(\"loss_string_table_id\", link=\"loss\"),\n            RetrieverObjectLink(\"history_string_table_id\", link=\"history\"),\n            RetrieverObjectLink(\"scouts_string_table_id\", link=\"scouts\"),\n        ]),\n    ]\n\n    def __init__(self,\n                 instructions: str,\n                 hints: str,\n                 victory: str,\n                 loss: str,\n                 history: str,\n                 scouts: str,\n                 instructions_string_table_id: int,\n                 hints_string_table_id: int,\n                 victory_string_table_id: int,\n                 loss_string_table_id: int,\n                 history_string_table_id: int,\n                 scouts_string_table_id: int,\n                 **kwargs\n                 ):\n        super().__init__(**kwargs)\n\n        self.instructions: str = instructions\n        self.hints: str = hints\n        self.victory: str = victory\n        self.loss: str = loss\n        self.history: str = history\n        self.scouts: str = scouts\n        self.instructions_string_table_id: int = instructions_string_table_id\n        self.hints_string_table_id: int = hints_string_table_id\n        self.victory_string_table_id: int = victory_string_table_id\n        self.loss_string_table_id: int = loss_string_table_id\n        self.history_string_table_id: int = history_string_table_id\n        self.scouts_string_table_id: int = scouts_string_table_id\n</code></pre>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager-attributes","title":"Attributes","text":""},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.hints","title":"<code>hints: str = hints</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>hints</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.hints_string_table_id","title":"<code>hints_string_table_id: int = hints_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>hints_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.history","title":"<code>history: str = history</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>history</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.history_string_table_id","title":"<code>history_string_table_id: int = history_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>history_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.instructions","title":"<code>instructions: str = instructions</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>instructions</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.instructions_string_table_id","title":"<code>instructions_string_table_id: int = instructions_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>instructions_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.loss","title":"<code>loss: str = loss</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>loss</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.loss_string_table_id","title":"<code>loss_string_table_id: int = loss_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>loss_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.scouts","title":"<code>scouts: str = scouts</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>scouts</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.scouts_string_table_id","title":"<code>scouts_string_table_id: int = scouts_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>scouts_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.victory","title":"<code>victory: str = victory</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>victory</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.victory_string_table_id","title":"<code>victory_string_table_id: int = victory_string_table_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>victory_string_table_id</code>"},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager-functions","title":"Functions","text":""},{"location":"api_docs/messages/message_manager/#AoE2ScenarioParser.objects.managers.message_manager.MessageManager.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>str</code>  - required <code>hints</code> <code>str</code>  - required <code>victory</code> <code>str</code>  - required <code>loss</code> <code>str</code>  - required <code>history</code> <code>str</code>  - required <code>scouts</code> <code>str</code>  - required <code>instructions_string_table_id</code> <code>int</code>  - required <code>hints_string_table_id</code> <code>int</code>  - required <code>victory_string_table_id</code> <code>int</code>  - required <code>loss_string_table_id</code> <code>int</code>  - required <code>history_string_table_id</code> <code>int</code>  - required <code>scouts_string_table_id</code> <code>int</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/message_manager.py</code> <pre><code>def __init__(self,\n             instructions: str,\n             hints: str,\n             victory: str,\n             loss: str,\n             history: str,\n             scouts: str,\n             instructions_string_table_id: int,\n             hints_string_table_id: int,\n             victory_string_table_id: int,\n             loss_string_table_id: int,\n             history_string_table_id: int,\n             scouts_string_table_id: int,\n             **kwargs\n             ):\n    super().__init__(**kwargs)\n\n    self.instructions: str = instructions\n    self.hints: str = hints\n    self.victory: str = victory\n    self.loss: str = loss\n    self.history: str = history\n    self.scouts: str = scouts\n    self.instructions_string_table_id: int = instructions_string_table_id\n    self.hints_string_table_id: int = hints_string_table_id\n    self.victory_string_table_id: int = victory_string_table_id\n    self.loss_string_table_id: int = loss_string_table_id\n    self.history_string_table_id: int = history_string_table_id\n    self.scouts_string_table_id: int = scouts_string_table_id\n</code></pre>"},{"location":"api_docs/player/player/","title":"PlayerData","text":""},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player-classes","title":"Classes","text":""},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player","title":"<code>Player</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>A class for handling all player information.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/player/player.py</code> <pre><code>class Player(AoE2Object):\n    \"\"\"A class for handling all player information.\"\"\"\n\n    _object_attributes = [\n        'player_id',\n        'starting_age',\n        'lock_civ',\n        'food',\n        'wood',\n        'gold',\n        'stone',\n        'color',\n        'active',\n        'human',\n        'civilization',\n        'architecture_set',\n    ]\n    _object_attributes_non_gaia = [\n        'population_cap',\n        'diplomacy',\n        'initial_camera_x',\n        'initial_camera_y',\n        'allied_victory',\n        'disabled_techs',\n        'disabled_buildings',\n        'disabled_units',\n        'base_priority',\n        'tribe_name',\n        'string_table_name_id',\n    ]\n\n    def __init__(\n            self,\n            player_id: int,\n            starting_age: int,\n            lock_civ: int,\n            lock_personality: int,\n            food: int,\n            wood: int,\n            gold: int,\n            stone: int,\n            color: int,\n            active: bool,\n            human: bool,\n            civilization: int,\n            architecture_set: int,\n\n            # Optionals due to GAIA not having such value\n            population_cap: Optional[int] = None,\n            diplomacy: Optional[List[int]] = None,\n            initial_camera_x: Optional[int] = None,\n            initial_camera_y: Optional[int] = None,\n            allied_victory: Optional[int] = None,\n            disabled_techs: Optional[List[int]] = None,\n            disabled_buildings: Optional[List[int]] = None,\n            disabled_units: Optional[List[int]] = None,\n            tribe_name: Optional[str] = None,\n            base_priority: Optional[int] = None,\n            string_table_name_id: Optional[int] = None,\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        self._player_id: int = player_id\n        self._active: bool = active\n        self.starting_age: int = dataset_or_value(StartingAge, starting_age)\n        self.lock_civ: bool = bool(lock_civ)\n        self.lock_personality: bool = bool(lock_personality)\n        self.food: int = food\n        self.wood: int = wood\n        self.gold: int = gold\n        self.stone: int = stone\n        self.color: int = color\n        self.human: bool = human\n        self.civilization: int | Civilization = dataset_or_value(Civilization, civilization)\n        self.architecture_set: int | Civilization = dataset_or_value(Civilization, architecture_set)\n\n        # Optionals due to GAIA not having such value\n        self.population_cap: Optional[int] = population_cap\n        self.diplomacy: Optional[List[int]] = diplomacy\n        self.initial_camera_x: Optional[int] = initial_camera_x\n        self.initial_camera_y: Optional[int] = initial_camera_y\n        self.allied_victory: Optional[bool] = bool(allied_victory) if allied_victory is not None else None\n        self.disabled_techs: Optional[List[int]] = disabled_techs\n        self.disabled_buildings: Optional[List[int]] = disabled_buildings\n        self.disabled_units: Optional[List[int]] = disabled_units\n        self.tribe_name: Optional[str] = tribe_name\n        self.base_priority: Optional[int] = base_priority\n        self.string_table_name_id: Optional[int] = string_table_name_id\n\n    @property\n    def player_id(self):\n        \"\"\"Read-only value of the player ID\"\"\"\n        return self._player_id\n\n    @property\n    def active(self):\n        \"\"\"Read-only value if this player is active or not\"\"\"\n        return self._active\n\n    def set_player_diplomacy(self, players: PlayerId | int | List[PlayerId | int], diplomacy: DiplomacyState):\n        \"\"\"\n        Set the diplomacy of this player to other players.\n\n        Note: This sets the player diplomacy ONE WAY!\n            This does NOT set the other player's diplomacy to this player to the same diplomacy\n\n        Args:\n            players: The player(s) to change\n            diplomacy: The diplomacy setting to set the player to\n        \"\"\"\n        players: List[PlayerId | int] = listify(players)\n\n        if self.player_id in players:\n            raise ValueError(\"Cannot set diplomacy from and to the same player\")\n\n        for player in players:\n            self.diplomacy[player - 1] = diplomacy\n\n    def _get_object_attrs(self):\n        attrs = self._object_attributes\n        if self.player_id != PlayerId.GAIA:\n            attrs.extend(self._object_attributes_non_gaia)\n        return super()._get_object_attrs() + attrs\n</code></pre>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player-attributes","title":"Attributes","text":""},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.active","title":"<code>active</code>  <code>property</code>","text":"<p>Read-only value if this player is active or not</p>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.allied_victory","title":"<code>allied_victory: Optional[bool] = bool(allied_victory) if allied_victory is not None else None</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[bool]</code>                           Value: <code>bool(allied_victory) if allied_victory is not None else None</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.architecture_set","title":"<code>architecture_set: int | Civilization = dataset_or_value(Civilization, architecture_set)</code>  <code>instance-attribute</code>","text":"Type: <code>int | Civilization</code>                           Value: <code>dataset_or_value(Civilization, architecture_set)</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.base_priority","title":"<code>base_priority: Optional[int] = base_priority</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[int]</code>                           Value: <code>base_priority</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.civilization","title":"<code>civilization: int | Civilization = dataset_or_value(Civilization, civilization)</code>  <code>instance-attribute</code>","text":"Type: <code>int | Civilization</code>                           Value: <code>dataset_or_value(Civilization, civilization)</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.color","title":"<code>color: int = color</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>color</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.diplomacy","title":"<code>diplomacy: Optional[List[int]] = diplomacy</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[List[int]]</code>                           Value: <code>diplomacy</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.disabled_buildings","title":"<code>disabled_buildings: Optional[List[int]] = disabled_buildings</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[List[int]]</code>                           Value: <code>disabled_buildings</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.disabled_techs","title":"<code>disabled_techs: Optional[List[int]] = disabled_techs</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[List[int]]</code>                           Value: <code>disabled_techs</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.disabled_units","title":"<code>disabled_units: Optional[List[int]] = disabled_units</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[List[int]]</code>                           Value: <code>disabled_units</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.food","title":"<code>food: int = food</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>food</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.gold","title":"<code>gold: int = gold</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>gold</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.human","title":"<code>human: bool = human</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>human</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.initial_camera_x","title":"<code>initial_camera_x: Optional[int] = initial_camera_x</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[int]</code>                           Value: <code>initial_camera_x</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.initial_camera_y","title":"<code>initial_camera_y: Optional[int] = initial_camera_y</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[int]</code>                           Value: <code>initial_camera_y</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.lock_civ","title":"<code>lock_civ: bool = bool(lock_civ)</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>bool(lock_civ)</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.lock_personality","title":"<code>lock_personality: bool = bool(lock_personality)</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>bool(lock_personality)</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.player_id","title":"<code>player_id</code>  <code>property</code>","text":"<p>Read-only value of the player ID</p>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.population_cap","title":"<code>population_cap: Optional[int] = population_cap</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[int]</code>                           Value: <code>population_cap</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.starting_age","title":"<code>starting_age: int = dataset_or_value(StartingAge, starting_age)</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>dataset_or_value(StartingAge, starting_age)</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.stone","title":"<code>stone: int = stone</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>stone</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.string_table_name_id","title":"<code>string_table_name_id: Optional[int] = string_table_name_id</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[int]</code>                           Value: <code>string_table_name_id</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.tribe_name","title":"<code>tribe_name: Optional[str] = tribe_name</code>  <code>instance-attribute</code>","text":"Type: <code>Optional[str]</code>                           Value: <code>tribe_name</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.wood","title":"<code>wood: int = wood</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>wood</code>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player-functions","title":"Functions","text":""},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>player_id</code> <code>int</code>  - required <code>starting_age</code> <code>int</code>  - required <code>lock_civ</code> <code>int</code>  - required <code>lock_personality</code> <code>int</code>  - required <code>food</code> <code>int</code>  - required <code>wood</code> <code>int</code>  - required <code>gold</code> <code>int</code>  - required <code>stone</code> <code>int</code>  - required <code>color</code> <code>int</code>  - required <code>active</code> <code>bool</code>  - required <code>human</code> <code>bool</code>  - required <code>civilization</code> <code>int</code>  - required <code>architecture_set</code> <code>int</code>  - required <code>population_cap</code> <code>Optional[int]</code>  - <code>None</code> <code>diplomacy</code> <code>Optional[List[int]]</code>  - <code>None</code> <code>initial_camera_x</code> <code>Optional[int]</code>  - <code>None</code> <code>initial_camera_y</code> <code>Optional[int]</code>  - <code>None</code> <code>allied_victory</code> <code>Optional[int]</code>  - <code>None</code> <code>disabled_techs</code> <code>Optional[List[int]]</code>  - <code>None</code> <code>disabled_buildings</code> <code>Optional[List[int]]</code>  - <code>None</code> <code>disabled_units</code> <code>Optional[List[int]]</code>  - <code>None</code> <code>tribe_name</code> <code>Optional[str]</code>  - <code>None</code> <code>base_priority</code> <code>Optional[int]</code>  - <code>None</code> <code>string_table_name_id</code> <code>Optional[int]</code>  - <code>None</code> <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/player/player.py</code> <pre><code>def __init__(\n        self,\n        player_id: int,\n        starting_age: int,\n        lock_civ: int,\n        lock_personality: int,\n        food: int,\n        wood: int,\n        gold: int,\n        stone: int,\n        color: int,\n        active: bool,\n        human: bool,\n        civilization: int,\n        architecture_set: int,\n\n        # Optionals due to GAIA not having such value\n        population_cap: Optional[int] = None,\n        diplomacy: Optional[List[int]] = None,\n        initial_camera_x: Optional[int] = None,\n        initial_camera_y: Optional[int] = None,\n        allied_victory: Optional[int] = None,\n        disabled_techs: Optional[List[int]] = None,\n        disabled_buildings: Optional[List[int]] = None,\n        disabled_units: Optional[List[int]] = None,\n        tribe_name: Optional[str] = None,\n        base_priority: Optional[int] = None,\n        string_table_name_id: Optional[int] = None,\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    self._player_id: int = player_id\n    self._active: bool = active\n    self.starting_age: int = dataset_or_value(StartingAge, starting_age)\n    self.lock_civ: bool = bool(lock_civ)\n    self.lock_personality: bool = bool(lock_personality)\n    self.food: int = food\n    self.wood: int = wood\n    self.gold: int = gold\n    self.stone: int = stone\n    self.color: int = color\n    self.human: bool = human\n    self.civilization: int | Civilization = dataset_or_value(Civilization, civilization)\n    self.architecture_set: int | Civilization = dataset_or_value(Civilization, architecture_set)\n\n    # Optionals due to GAIA not having such value\n    self.population_cap: Optional[int] = population_cap\n    self.diplomacy: Optional[List[int]] = diplomacy\n    self.initial_camera_x: Optional[int] = initial_camera_x\n    self.initial_camera_y: Optional[int] = initial_camera_y\n    self.allied_victory: Optional[bool] = bool(allied_victory) if allied_victory is not None else None\n    self.disabled_techs: Optional[List[int]] = disabled_techs\n    self.disabled_buildings: Optional[List[int]] = disabled_buildings\n    self.disabled_units: Optional[List[int]] = disabled_units\n    self.tribe_name: Optional[str] = tribe_name\n    self.base_priority: Optional[int] = base_priority\n    self.string_table_name_id: Optional[int] = string_table_name_id\n</code></pre>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player.Player.set_player_diplomacy","title":"<code>def set_player_diplomacy(...)</code>","text":"<p>Set the diplomacy of this player to other players.</p> This sets the player diplomacy ONE WAY! <p>This does NOT set the other player's diplomacy to this player to the same diplomacy</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>PlayerId | int | List[PlayerId | int]</code> <p>The player(s) to change</p> required <code>diplomacy</code> <code>DiplomacyState</code> <p>The diplomacy setting to set the player to</p> required Source code in <code>AoE2ScenarioParser/objects/data_objects/player/player.py</code> <pre><code>def set_player_diplomacy(self, players: PlayerId | int | List[PlayerId | int], diplomacy: DiplomacyState):\n    \"\"\"\n    Set the diplomacy of this player to other players.\n\n    Note: This sets the player diplomacy ONE WAY!\n        This does NOT set the other player's diplomacy to this player to the same diplomacy\n\n    Args:\n        players: The player(s) to change\n        diplomacy: The diplomacy setting to set the player to\n    \"\"\"\n    players: List[PlayerId | int] = listify(players)\n\n    if self.player_id in players:\n        raise ValueError(\"Cannot set diplomacy from and to the same player\")\n\n    for player in players:\n        self.diplomacy[player - 1] = diplomacy\n</code></pre>"},{"location":"api_docs/player/player/#AoE2ScenarioParser.objects.data_objects.player.player-functions","title":"Functions","text":""},{"location":"api_docs/player/player_manager/","title":"PlayerManager","text":""},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager-classes","title":"Classes","text":""},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager","title":"<code>PlayerManager</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of everything player related.</p> Source code in <code>AoE2ScenarioParser/objects/managers/player_manager.py</code> <pre><code>class PlayerManager(AoE2Object):\n    \"\"\"Manager of everything player related.\"\"\"\n\n    # Todo: Implement a DE version separate of this.\n    #  I'll be dealing with this IF support for other game versions will ever happen.\n\n    _link_list = [\n        RetrieverObjectLink(\"_player_count\", \"FileHeader\", \"player_count\"),\n\n        RetrieverObjectLinkGroup(\"DataHeader\", group=[\n            RetrieverObjectLink(\"_tribe_names\", link=\"tribe_names\"),\n            RetrieverObjectLink(\"_string_table_player_names\", link=\"string_table_player_names\"),\n            RetrieverObjectLink(\"_metadata\", link=\"player_data_1\", process_as_object=PlayerMetaData),\n            RetrieverObjectLink(\"_lock_civilizations\", link=\"per_player_lock_civilization\"),\n            RetrieverObjectLink(\"_lock_personalities\", link=\"per_player_lock_personality\", support=Support(since=1.53)),\n        ]),\n\n        RetrieverObjectLink(\"_resources\", \"PlayerDataTwo\", \"resources\", process_as_object=PlayerResources),\n\n        RetrieverObjectLinkGroup(\"Diplomacy\", group=[\n            RetrieverObjectLink(\"_diplomacy\", link=\"per_player_diplomacy\", process_as_object=PlayerDiplomacy),\n            RetrieverObjectLink(\"_allied_victories\", link=\"per_player_allied_victory\"),\n        ]),\n\n        RetrieverObjectLinkGroup(\"Options\", group=[\n            *[\n                RetrieverObjectLink(f\"_disabled_{type_}_ids_player_{i}\", link=f\"disabled_{type_}_ids_player_{i}\")\n                for type_ in [\"tech\", \"building\", \"unit\"] for i in range(1, 9)\n            ],\n            RetrieverObjectLink(\"_starting_ages\", link=\"per_player_starting_age\"),\n            RetrieverObjectLink(\"_base_priorities\", link=\"per_player_base_priority\"),\n        ]),\n\n        RetrieverObjectLink(\"_pop_caps\", \"Map\", \"per_player_population_cap\", support=Support(since=1.44)),\n\n        RetrieverObjectLinkGroup(\"Units\", group=[\n            RetrieverObjectLink(\"_player_data_4\", link=\"player_data_4\", process_as_object=PlayerDataFour),\n            RetrieverObjectLink(\"_player_data_3\", link=\"player_data_3\", process_as_object=PlayerDataThree),\n        ]),\n    ]\n\n    def __init__(\n            self,\n            _player_count: int,\n            _tribe_names: List[str],\n            _string_table_player_names: List[int],\n            _metadata: List[PlayerMetaData],\n            _lock_civilizations: List[int],\n            _lock_personalities: List[int],\n            _resources: List[PlayerResources],\n            _diplomacy: List[PlayerDiplomacy],\n            _allied_victories: List[int],\n            _starting_ages: List[int],\n            _base_priorities: List[int],\n            _pop_caps: List[int],\n            _player_data_4: List[PlayerDataFour],\n            _player_data_3: List[PlayerDataThree],\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        disables = {}\n        for type_ in ['tech', 'building', 'unit']:\n            disables[type_] = [kwargs[f'_disabled_{type_}_ids_player_{p}'] for p in range(1, 9)]\n\n        gaia_first_params = {}\n        no_gaia_params = {\n            'population_cap': [int(pd.population_limit) for pd in _player_data_4],\n            'tribe_name': _tribe_names,\n            'string_table_name_id': _string_table_player_names,\n            'base_priority': _base_priorities,\n            'allied_victory': _allied_victories,\n            'disabled_techs': disables['tech'],\n            'disabled_buildings': disables['building'],\n            'disabled_units': disables['unit'],\n            'initial_camera_x': [pd.initial_camera_x for pd in _player_data_3],\n            'initial_camera_y': [pd.initial_camera_y for pd in _player_data_3],\n            'diplomacy': [d.diplomacy_stance for d in _diplomacy],\n        }\n        gaia_last_params = {\n            'starting_age': _starting_ages,\n            'lock_civ': _lock_civilizations,\n            'lock_personality': _lock_personalities,\n            'food': [r.food for r in _resources],\n            'wood': [r.wood for r in _resources],\n            'gold': [r.gold for r in _resources],\n            'stone': [r.stone for r in _resources],\n            'color': [r.color for r in _resources],\n            'active': [r.active for r in _metadata],\n            'human': [r.human for r in _metadata],\n            'civilization': [r.civilization for r in _metadata],\n            'architecture_set': [r.architecture_set for r in _metadata],\n        }\n\n        param_sets = [(no_gaia_params, None), (gaia_first_params, True), (gaia_last_params, False)]\n        player_attributes: Dict[int, Dict] = {i: {'player_id': PlayerId(i)} for i in range(9)}\n        for param_set, gaia_first in param_sets:\n            for key, lst in param_set.items():\n                _spread_player_attributes(player_attributes, key, lst, gaia_first)\n\n        self.players = [Player(**player_attributes[p]) for p in PlayerId.all()]\n\n    @property\n    def active_players(self) -&gt; int:\n        \"\"\"The amount of players that are active within the scenario\"\"\"\n        return len([player for player in self.players if player.active])\n\n    @active_players.setter\n    def active_players(self, value: int):\n        if not 1 &lt;= value &lt;= 8:\n            raise ValueError(\"Active players value has to be between 1 and 8\")\n        for player_id in PlayerId.all(exclude_gaia=True):\n            setattr(self.players[player_id], '_active', player_id &lt;= value)\n\n    @property\n    def players(self) -&gt; List[Player]:\n        \"\"\"Returns all player objects\"\"\"\n        return self._players\n\n    @players.setter\n    def players(self, value: List[Player]) -&gt; None:\n        \"\"\"Sets player objects\"\"\"\n        self._players = UuidList(self._uuid, value)\n\n    def set_default_starting_resources(self, players: List[PlayerId] = None) -&gt; None:\n        \"\"\"\n        Sets the default starting resources for all players\n\n        Warning: Does NOT take civilizations into account\n            This does not take the current selected civ of this player into account. For example, a player with the\n            Chinese civ selected will still be set to 200 food. Generally speaking, it's recommended to not use this for\n            competitive, normal play. You can select `low` resources in the lobby menu to get 'normal' resources for\n            every civ.\n\n        Args:\n            players: A list of players, defaults to all players (incl GAIA) when left out\n        \"\"\"\n        if players is None:\n            players = PlayerId.all()\n        for player in players:\n            self.players[player].food = 200\n            self.players[player].wood = 200\n            self.players[player].gold = 100\n            self.players[player].stone = 200\n\n    def set_diplomacy_teams(self, *args: List[PlayerId | int], diplomacy: DiplomacyState = DiplomacyState.ALLY) \\\n            -&gt; None:\n        \"\"\"\n        Sets all players in list allied with all others in the same list.\n\n        Args:\n            *args: List(s) with player IDs that'll be set to the given diplomacy value\n            diplomacy: The diplomacy to set the teams to. Defaults to ally.\n\n        Examples:\n            To set diplomacy like a 4v4 in ranked. Two teams of 4 with alternating IDs.\n\n                set_diplomacy_teams([1,3,5,7], [2,4,6,8], diplomacy=DiplomacyState.ALLY)\n        \"\"\"\n        for team in args:\n            for player in team:\n                if player == PlayerId.GAIA:\n                    raise ValueError(\"Gaia cannot be in a team\")\n                self.players[player].set_player_diplomacy([p for p in team if p != player], diplomacy)\n\n    # ###############################################################################################\n    # ################################# Functions for reconstruction ################################\n    # ###############################################################################################\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        if name.startswith('_disabled_'):\n            type_ = name.split('_')[2]\n            return getattr(self.players[int(name[-1])], f\"disabled_{type_}s\")\n\n        return super().__getattribute__(name)\n\n    @property\n    def _player_count(self):\n        \"\"\"Returns number of active players to be stored in the FileHeader\"\"\"\n        return self.active_players\n\n    @property\n    def _allied_victories(self):\n        \"\"\"Returns the allied victory of all players\"\"\"\n        return self._player_attributes_to_list(\"allied_victory\", None, default=0, fill_empty=8)\n\n    @property\n    def _starting_ages(self):\n        \"\"\"Returns the starting age of all players\"\"\"\n        return self._player_attributes_to_list(\"starting_age\", False, default=2, fill_empty=7)\n\n    @property\n    def _lock_civilizations(self):\n        \"\"\"Returns the civ lock bool of all players\"\"\"\n        return self._player_attributes_to_list(\"lock_civ\", False, default=0, fill_empty=7)\n\n    @property\n    def _lock_personalities(self):\n        \"\"\"Returns the civ lock bool of all players\"\"\"\n        return self._player_attributes_to_list(\"lock_personality\", False, default=0, fill_empty=7)\n\n    @property\n    def _pop_caps(self):\n        \"\"\"Returns the population cap of all players\"\"\"\n        return self._player_attributes_to_list(\"population_cap\", None, default=200, fill_empty=8)\n\n    @property\n    def _diplomacy(self):\n        \"\"\"Returns the diplomacy of all players\"\"\"\n        diplomacies = self._player_attributes_to_list(\"diplomacy\", None)\n\n        player_diplomacies = UuidList(self._uuid, [\n            PlayerDiplomacy(diplomacy_stance=diplomacies[i]) for i in range(8)\n        ])\n        player_diplomacies.extend([\n            PlayerDiplomacy(diplomacy_stance=[3] * 16) for _ in range(8)\n        ])\n        return player_diplomacies\n\n    @property\n    def _player_data_4(self):\n        \"\"\"Returns the resource duplicates for all players\"\"\"\n        population_limit = self._player_attributes_to_list(\"population_cap\", None, default=200)\n        food = self._player_attributes_to_list(\"food\", None, default=0)\n        wood = self._player_attributes_to_list(\"wood\", None, default=0)\n        gold = self._player_attributes_to_list(\"gold\", None, default=0)\n        stone = self._player_attributes_to_list(\"stone\", None, default=0)\n\n        return UuidList(self._uuid, [\n            PlayerDataFour(\n                population_limit=float(population_limit[i]),\n                food_duplicate=float(food[i]),\n                wood_duplicate=float(wood[i]),\n                gold_duplicate=float(gold[i]),\n                stone_duplicate=float(stone[i]),\n            ) for i in range(8)\n        ])\n\n    @property\n    def _player_data_3(self) -&gt; List[PlayerDataThree]:\n        \"\"\"Returns the resource objects for all players\"\"\"\n        original_map: Dict[int, str] = {0: 'ally', 1: 'neutral', 3: 'enemy'}\n        mappings: Dict[str, Dict[str, int]] = {\n            'diplomacy_for_interaction': {'self': 0, 'ally': 0, 'neutral': 1, 'enemy': 3, 'gaia': 3},\n            'diplomacy_for_ai_system': {'self': 1, 'ally': 2, 'neutral': 3, 'enemy': 4, 'gaia': 0},\n        }\n\n        initial_camera_x = self._player_attributes_to_list(\"initial_camera_x\", None, default=72)\n        initial_camera_y = self._player_attributes_to_list(\"initial_camera_y\", None, default=72)\n        aok_allied_victory = self._player_attributes_to_list(\"allied_victory\", None, default=0)\n        color = self._player_attributes_to_list(\"color\", False, default=1)\n        diplomacies: List[List[int]] = self._player_attributes_to_list(\"diplomacy\", None)\n\n        other_diplomacies: Dict[str, List[List[int]]] = {}\n        for player in range(8):\n            diplomacy = diplomacies[player][:8]\n            for key, mapping in mappings.items():\n                lst = other_diplomacies.setdefault(key, [])\n                temp_lst = [mapping['gaia']] + [mapping[original_map[n]] for n in diplomacy]\n                temp_lst[player + 1] = mapping['self']\n                lst.append(temp_lst)\n\n        return UuidList(self._uuid, [\n            PlayerDataThree(\n                initial_camera_x[i],\n                initial_camera_y[i],\n                aok_allied_victory[i],\n                other_diplomacies['diplomacy_for_interaction'][i],\n                other_diplomacies['diplomacy_for_ai_system'][i],\n                color[i],\n            ) for i in range(len(initial_camera_x))\n        ])\n\n    @property\n    def _resources(self) -&gt; List[PlayerResources]:\n        \"\"\"Returns the resource objects for all players\"\"\"\n        food = self._player_attributes_to_list(\"food\", False, default=0, fill_empty=7)\n        wood = self._player_attributes_to_list(\"wood\", False, default=0, fill_empty=7)\n        gold = self._player_attributes_to_list(\"gold\", False, default=0, fill_empty=7)\n        stone = self._player_attributes_to_list(\"stone\", False, default=0, fill_empty=7)\n        color = self._player_attributes_to_list(\"color\", False, default=0)\n        color.extend(range(9, 16))\n\n        return UuidList(self._uuid, [\n            PlayerResources(food[i], wood[i], gold[i], stone[i], color[i]) for i in range(len(food))\n        ])\n\n    @property\n    def _metadata(self) -&gt; List[PlayerMetaData]:\n        \"\"\"Returns the metadata objects for all players\"\"\"\n        active = self._player_attributes_to_list(\"active\", False, default=0, fill_empty=7)\n        human = self._player_attributes_to_list(\"human\", False, default=1, fill_empty=7)\n        civilization = self._player_attributes_to_list(\"civilization\", False, default=Civilization.RANDOM, fill_empty=7)\n        architecture_set = self._player_attributes_to_list(\"architecture_set\", False, default=Civilization.RANDOM, fill_empty=7)\n        return UuidList(self._uuid, [\n            PlayerMetaData(active[i], human[i], civilization[i], architecture_set[i]) for i in range(len(active))\n        ])\n\n    @property\n    def _base_priorities(self) -&gt; List[int]:\n        \"\"\"Returns the base priorities of all players\"\"\"\n        return self._player_attributes_to_list(\"base_priority\", None, default=0)\n\n    @property\n    def _tribe_names(self) -&gt; List[str]:\n        \"\"\"Returns the tribe names of all players\"\"\"\n        return self._player_attributes_to_list(\"tribe_name\", None, default=\"\", fill_empty=8)\n\n    @property\n    def _string_table_player_names(self) -&gt; List[int]:\n        \"\"\"Returns the string table player names of all players\"\"\"\n        return self._player_attributes_to_list(\"string_table_name_id\", None, default=-2, fill_empty=8)\n\n    def _player_attributes_to_list(\n            self,\n            attribute: str,\n            gaia_first: bool | None = True,\n            default: str | int = 0,\n            fill_empty: int = 0\n    ) -&gt; List[Any]:\n        \"\"\"\n        The list to store in the scenario structure with values from all players.\n\n        Args:\n            attribute: The attribute to get from the players\n            gaia_first: If the list has gaia first, last or not at all\n            default: The default value to fill the empty fields and what to end to an 16 field list\n            fill_empty: How many empty elements have to be filled with the default value\n\n        Returns:\n            The list of values\n        \"\"\"\n        players = _player_list(gaia_first)\n        default_list = [default] * fill_empty\n        values = []\n        for p in players:\n            try:\n                v = getattr(self.players[p], attribute)\n                if v is None and gaia_first is None:\n                    v = default\n            except UnsupportedAttributeError:\n                v = None\n            values.append(v)\n        return values + default_list\n</code></pre>"},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager-attributes","title":"Attributes","text":""},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager.active_players","title":"<code>active_players: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code> <p>The amount of players that are active within the scenario</p>"},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager.players","title":"<code>players: List[Player]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[Player]</code> <p>Returns all player objects</p>"},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager-functions","title":"Functions","text":""},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>_player_count</code> <code>int</code>  - required <code>_tribe_names</code> <code>List[str]</code>  - required <code>_string_table_player_names</code> <code>List[int]</code>  - required <code>_metadata</code> <code>List[PlayerMetaData]</code>  - required <code>_lock_civilizations</code> <code>List[int]</code>  - required <code>_lock_personalities</code> <code>List[int]</code>  - required <code>_resources</code> <code>List[PlayerResources]</code>  - required <code>_diplomacy</code> <code>List[PlayerDiplomacy]</code>  - required <code>_allied_victories</code> <code>List[int]</code>  - required <code>_starting_ages</code> <code>List[int]</code>  - required <code>_base_priorities</code> <code>List[int]</code>  - required <code>_pop_caps</code> <code>List[int]</code>  - required <code>_player_data_4</code> <code>List[PlayerDataFour]</code>  - required <code>_player_data_3</code> <code>List[PlayerDataThree]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/player_manager.py</code> <pre><code>def __init__(\n        self,\n        _player_count: int,\n        _tribe_names: List[str],\n        _string_table_player_names: List[int],\n        _metadata: List[PlayerMetaData],\n        _lock_civilizations: List[int],\n        _lock_personalities: List[int],\n        _resources: List[PlayerResources],\n        _diplomacy: List[PlayerDiplomacy],\n        _allied_victories: List[int],\n        _starting_ages: List[int],\n        _base_priorities: List[int],\n        _pop_caps: List[int],\n        _player_data_4: List[PlayerDataFour],\n        _player_data_3: List[PlayerDataThree],\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    disables = {}\n    for type_ in ['tech', 'building', 'unit']:\n        disables[type_] = [kwargs[f'_disabled_{type_}_ids_player_{p}'] for p in range(1, 9)]\n\n    gaia_first_params = {}\n    no_gaia_params = {\n        'population_cap': [int(pd.population_limit) for pd in _player_data_4],\n        'tribe_name': _tribe_names,\n        'string_table_name_id': _string_table_player_names,\n        'base_priority': _base_priorities,\n        'allied_victory': _allied_victories,\n        'disabled_techs': disables['tech'],\n        'disabled_buildings': disables['building'],\n        'disabled_units': disables['unit'],\n        'initial_camera_x': [pd.initial_camera_x for pd in _player_data_3],\n        'initial_camera_y': [pd.initial_camera_y for pd in _player_data_3],\n        'diplomacy': [d.diplomacy_stance for d in _diplomacy],\n    }\n    gaia_last_params = {\n        'starting_age': _starting_ages,\n        'lock_civ': _lock_civilizations,\n        'lock_personality': _lock_personalities,\n        'food': [r.food for r in _resources],\n        'wood': [r.wood for r in _resources],\n        'gold': [r.gold for r in _resources],\n        'stone': [r.stone for r in _resources],\n        'color': [r.color for r in _resources],\n        'active': [r.active for r in _metadata],\n        'human': [r.human for r in _metadata],\n        'civilization': [r.civilization for r in _metadata],\n        'architecture_set': [r.architecture_set for r in _metadata],\n    }\n\n    param_sets = [(no_gaia_params, None), (gaia_first_params, True), (gaia_last_params, False)]\n    player_attributes: Dict[int, Dict] = {i: {'player_id': PlayerId(i)} for i in range(9)}\n    for param_set, gaia_first in param_sets:\n        for key, lst in param_set.items():\n            _spread_player_attributes(player_attributes, key, lst, gaia_first)\n\n    self.players = [Player(**player_attributes[p]) for p in PlayerId.all()]\n</code></pre>"},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager.set_default_starting_resources","title":"<code>def set_default_starting_resources(...)</code>","text":"<p>Sets the default starting resources for all players</p> Does NOT take civilizations into account <p>This does not take the current selected civ of this player into account. For example, a player with the Chinese civ selected will still be set to 200 food. Generally speaking, it's recommended to not use this for competitive, normal play. You can select <code>low</code> resources in the lobby menu to get 'normal' resources for every civ.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>List[PlayerId]</code> <p>A list of players, defaults to all players (incl GAIA) when left out</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/managers/player_manager.py</code> <pre><code>def set_default_starting_resources(self, players: List[PlayerId] = None) -&gt; None:\n    \"\"\"\n    Sets the default starting resources for all players\n\n    Warning: Does NOT take civilizations into account\n        This does not take the current selected civ of this player into account. For example, a player with the\n        Chinese civ selected will still be set to 200 food. Generally speaking, it's recommended to not use this for\n        competitive, normal play. You can select `low` resources in the lobby menu to get 'normal' resources for\n        every civ.\n\n    Args:\n        players: A list of players, defaults to all players (incl GAIA) when left out\n    \"\"\"\n    if players is None:\n        players = PlayerId.all()\n    for player in players:\n        self.players[player].food = 200\n        self.players[player].wood = 200\n        self.players[player].gold = 100\n        self.players[player].stone = 200\n</code></pre>"},{"location":"api_docs/player/player_manager/#AoE2ScenarioParser.objects.managers.player_manager.PlayerManager.set_diplomacy_teams","title":"<code>def set_diplomacy_teams(...)</code>","text":"<p>Sets all players in list allied with all others in the same list.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>List[PlayerId | int]</code> <p>List(s) with player IDs that'll be set to the given diplomacy value</p> <code>()</code> <code>diplomacy</code> <code>DiplomacyState</code> <p>The diplomacy to set the teams to. Defaults to ally.</p> <code>ALLY</code> <p>Examples:</p> <p>To set diplomacy like a 4v4 in ranked. Two teams of 4 with alternating IDs.</p> <pre><code>set_diplomacy_teams([1,3,5,7], [2,4,6,8], diplomacy=DiplomacyState.ALLY)\n</code></pre> Source code in <code>AoE2ScenarioParser/objects/managers/player_manager.py</code> <pre><code>def set_diplomacy_teams(self, *args: List[PlayerId | int], diplomacy: DiplomacyState = DiplomacyState.ALLY) \\\n        -&gt; None:\n    \"\"\"\n    Sets all players in list allied with all others in the same list.\n\n    Args:\n        *args: List(s) with player IDs that'll be set to the given diplomacy value\n        diplomacy: The diplomacy to set the teams to. Defaults to ally.\n\n    Examples:\n        To set diplomacy like a 4v4 in ranked. Two teams of 4 with alternating IDs.\n\n            set_diplomacy_teams([1,3,5,7], [2,4,6,8], diplomacy=DiplomacyState.ALLY)\n    \"\"\"\n    for team in args:\n        for player in team:\n            if player == PlayerId.GAIA:\n                raise ValueError(\"Gaia cannot be in a team\")\n            self.players[player].set_player_diplomacy([p for p in team if p != player], diplomacy)\n</code></pre>"},{"location":"api_docs/support/area/","title":"Area","text":"Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>class Area:\n    _recursion_steps = [Tile(0, -1), Tile(1, 0), Tile(0, 1), Tile(-1, 0)]\n    \"\"\"Values used for recursion steps\"\"\"\n\n    def __init__(\n            self,\n            map_size: int = None,\n            uuid: UUID = None,\n            x1: int = None,\n            y1: int = None,\n            x2: int = None,\n            y2: int = None,\n            corner1: Tile = None,\n            corner2: Tile = None,\n    ) -&gt; None:\n        \"\"\"\n        Object to easily select an area on the map. Uses method chaining for ease of use.\n\n        **Please note**: Setting a ``uuid`` will always overwrite the ``map_size`` attribute, even if it's not ``None``.\n\n        Args:\n            map_size: The size of the map this area object will handle\n            uuid: The UUID of the scenario this area belongs to\n            x1: The X location of the left corner\n            y1: The Y location of the left corner\n            x2: The X location of the right corner\n            y2: The Y location of the right corner\n            corner1: The location of the left corner\n            corner2: The location of the right corner\n        \"\"\"\n        if map_size is None and uuid is None:\n            if corner1 is None and (x1 is None or y1 is None):\n                raise ValueError(\"Cannot create area object without knowing the map size or a UUID from a scenario.\")\n\n        self.uuid: UUID = uuid\n        if map_size is not None:\n            self._map_size_value = map_size\n        else:\n            self._map_size_value = None\n\n        if values_are_valid(x1, y1) or value_is_valid(corner1):\n            x1, y1, x2, y2 = validate_coords(x1, y1, x2, y2, corner1, corner2)\n        else:\n            x1 = y1 = x2 = y2 = math.floor(self._map_size / 2)  # Select the center tile\n\n        self.state: AreaState = AreaState.FULL\n        self.inverted: bool = False\n\n        self.x1: int = x1\n        self.y1: int = y1\n        self.x2: int = x2\n        self.y2: int = y2\n\n        self.gap_size_x: int = 1\n        self.gap_size_y: int = 1\n        self.line_width_x: int = 1\n        self.line_width_y: int = 1\n        self.block_size_x: int = 1\n        self.block_size_y: int = 1\n\n        self.axis: str = \"\"\n\n        self.corner_size_x: int = 1\n        self.corner_size_y: int = 1\n\n    # ============================ Class methods ============================\n\n    @classmethod\n    def from_uuid(cls, uuid: UUID) -&gt; Area:\n        return cls(uuid=uuid)\n\n    @classmethod\n    def from_tiles(cls, corner1: Tile, corner2: Tile = None):\n        return cls(corner1=corner1, corner2=corner2)\n\n    # ============================ Properties ============================\n\n    @property\n    def x1(self) -&gt; int:\n        return self._minmax_val(self._x1)\n\n    @x1.setter\n    def x1(self, value):\n        self._x1 = value\n\n    @property\n    def y1(self) -&gt; int:\n        return self._minmax_val(self._y1)\n\n    @y1.setter\n    def y1(self, value):\n        self._y1 = value\n\n    @property\n    def x2(self) -&gt; int:\n        return self._minmax_val(self._x2)\n\n    @x2.setter\n    def x2(self, value):\n        self._x2 = value\n\n    @property\n    def y2(self) -&gt; int:\n        return self._minmax_val(self._y2)\n\n    @y2.setter\n    def y2(self, value):\n        self._y2 = value\n\n    @property\n    def corner1(self):\n        return Tile(self.x1, self.y1)\n\n    @corner1.setter\n    def corner1(self, value: Tile):\n        self.x1, self.y1 = value.x, value.y\n\n    @property\n    def corner2(self):\n        return Tile(self.x2, self.y2)\n\n    @corner2.setter\n    def corner2(self, value: Tile):\n        self.x2, self.y2 = value.x, value.y\n\n    @property\n    def map_size(self):\n        return self._map_size\n\n    @map_size.setter\n    def map_size(self, value):\n        if self.uuid is not None:\n            warn(\"Overriding the map size of a scenario linked Area object. Area.uuid was set to None.\",\n                 category=UuidForcedUnlinkWarning)\n            self.uuid = None\n        self._map_size_value = value\n\n    @property\n    def _map_size(self) -&gt; int:\n        if self.uuid is not None:\n            return getters.get_map_size(self.uuid)\n        elif self._map_size_value is not None:\n            return self._map_size_value\n        else:\n            self._map_size_error()\n\n    @property\n    def _map_size_safe(self) -&gt; int:\n        try:\n            return self._map_size\n        except ValueError:\n            return 999_999_999\n\n    @property\n    def maximum_coordinate(self) -&gt; int:\n        \"\"\"The maximum coordinate for the X or Y axis (like how 0 is the minimum)\"\"\"\n        return self._map_size_safe - 1\n\n    def associate_scenario(self, scenario: AoE2Scenario) -&gt; None:\n        \"\"\"\n        Associate area with scenario. Saves scenario UUID in this area object.\n\n        Args:\n            scenario: The scenario to associate with\n        \"\"\"\n        self.uuid = scenario.uuid\n\n    def _force_association(self) -&gt; None:\n        \"\"\"Raise ValueError if UUID is not set\"\"\"\n        if self.uuid is None:\n            raise ValueError(\"Area object not associated with scenario. Cannot request terrain information\")\n\n    def _force_map_size(self) -&gt; int:\n        \"\"\"\n        Raise ValueError if map_size isn't set. Error handling is done within self._map_size.\n        This just causes the error from within the `_map_size` if it isn't set.\n        Useful when a function conditionally uses the `_map_size`.\n        Where it 'sometimes' will and 'sometimes' won't throw the error\n        \"\"\"\n        return self._map_size\n\n    def _map_size_error(self) -&gt; None:\n        raise ValueError(\"No UUID or map_size was set. \"\n                         \"Set a map_size or associate with a scenario to use map size related functionality\")\n\n    # ============================ Conversion functions ============================\n\n    def to_coords(self, as_terrain: bool = False) -&gt; OrderedSet[Tile | 'TerrainTile']:\n        \"\"\"\n        Converts the selection to an OrderedSet of (x, y) coordinates\n\n        Args:\n            as_terrain: If the returning coordinates should be Tile objects or Terrain Tiles. If `True` the coordinates\n                are returned as TerrainTiles.\n\n        Returns:\n            An OrderedSet of Tiles ((x, y) named tuple) of the selection.\n\n        Examples:\n            The selection: ``((3,3), (5,5))`` would result in an OrderedSet with a length of 9::\n\n                [\n                    (3,3), (4,3)  ...,\n                    ...,   ...,   ...,\n                    ...,   (4,5), (5,5)\n                ]\n        \"\"\"\n        tiles = OrderedSet(\n            Tile(x, y) for y in self.get_range_y() for x in self.get_range_x() if self.is_within_selection(x, y)\n        )\n        return self._tiles_to_terrain_tiles(tiles) if as_terrain else tiles\n\n    def to_chunks(\n            self,\n            as_terrain: bool = False\n    ) -&gt; List[OrderedSet[Tile | 'TerrainTile']]:\n        \"\"\"\n        Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates.\n        The separation between chunks is based on if they're connected to each other.\n        So the tiles must share an edge (i.e. they should be non-diagonal).\n\n        Args:\n            as_terrain: If the returning coordinates should be Tile objects or Terrain Tiles. If `True` the coordinates\n                are returned as TerrainTiles.\n\n        Returns:\n            A list of OrderedSets of Tiles ((x, y) named tuple) of the selection.\n        \"\"\"\n        tiles = self.to_coords()\n\n        # Shortcut for states that CANNOT be more than one chunk\n        if self.state in AreaState.unchunkables():\n            return [tiles]\n\n        chunks: Dict[int, List[Tile]] = {}\n        for tile in tiles:\n            chunk_id = self._get_chunk_id(tile)\n            chunks.setdefault(chunk_id, []).append(tile)\n\n        map_size = self._map_size\n        chunks_ordered: List[OrderedSet[Tile | 'TerrainTile']] = []\n        for chunk_id, chunk_tiles in chunks.items():\n            tiles = self._tiles_to_terrain_tiles(chunk_tiles) if as_terrain else chunk_tiles\n            chunks_ordered.append(\n                OrderedSet(sorted(tiles, key=lambda t: t.y * map_size + t.x))\n            )\n\n        return chunks_ordered\n\n    def to_dict(self, prefix: str = \"area_\") -&gt; Dict[str, int]:\n        \"\"\"\n        Converts the 2 corners of the selection to area keys for use in effects etc.\n        This can be used by adding double stars (**) before this function.\n\n        Usage:\n            The selection: ``((3,3), (5,5))`` would result in a dict that looks like:\n                ``{'area_x1': 3, 'area_y1': 3, 'area_x2': 5, 'area_y2': 5}``\n            Then do: ``**area.to_dict()`` in a function that accepts area tiles\n\n        Args:\n            prefix: The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key)\n\n        Returns:\n            A dict with area_x1, area_y1, area_x2, area_y2 as keys and their respective values.\n        \"\"\"\n        return {f\"{prefix}{key}\": getattr(self, key) for key in ['x1', 'y1', 'x2', 'y2']}\n\n    # ============================ Getters ============================\n\n    def get_selection(self) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n        \"\"\"Get the four values of the selection as: ((x1, y1), (x2, y2))\"\"\"\n        return (self.x1, self.y1), (self.x2, self.y2)\n\n    def get_raw_selection(self) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n        \"\"\"Get the four values of the selection (even if they are outside the map) as: ((x1, y1), (x2, y2))\"\"\"\n        return (self._x1, self._y1), (self._x2, self._y2)\n\n    def get_center(self) -&gt; Tuple[float, float]:\n        \"\"\"Get center of current selection\"\"\"\n        return (self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2\n\n    def get_center_int(self) -&gt; Tuple[int, int]:\n        \"\"\"Get center of current selection, coords can only be integers. If even length, the value is ceiled\"\"\"\n        return math.ceil((self.x1 + self.x2) / 2), math.ceil((self.y1 + self.y2) / 2)\n\n    def get_range_x(self) -&gt; range:\n        \"\"\"Returns a range object for the x coordinates.\"\"\"\n        return range(self.x1, self.x2 + 1)\n\n    def get_range_y(self) -&gt; range:\n        \"\"\"Returns a range object for the y coordinates.\"\"\"\n        return range(self.y1, self.y2 + 1)\n\n    def get_width(self) -&gt; int:\n        \"\"\"Returns the length of the x side of the selection.\"\"\"\n        return self.x2 + 1 - self.x1\n\n    def get_height(self) -&gt; int:\n        \"\"\"Returns the length of the y side of the selection.\"\"\"\n        return self.y2 + 1 - self.y1\n\n    def get_dimensions(self) -&gt; Tuple[int, int]:\n        \"\"\"Returns the lengths of the x &amp; y side of the selection (in that order).\"\"\"\n        return self.get_width(), self.get_height()\n\n    # ============================ Use functions ============================\n\n    def use_full(self) -&gt; Area:\n        \"\"\"Sets the area object to use the entire selection\"\"\"\n        self.state = AreaState.FULL\n        return self\n\n    def use_only_edge(self, line_width: int = None, line_width_x: int = None, line_width_y: int = None) -&gt; Area:\n        \"\"\"\n        Sets the area object to only use the edge of the selection\n\n        Args:\n            line_width: The width of the x &amp; y edge line\n            line_width_x: The width of the x edge line\n            line_width_y: The width of the y edge line\n\n        Returns:\n            This area object\n        \"\"\"\n        self.attrs(line_width=line_width, line_width_x=line_width_x, line_width_y=line_width_y)\n        self.state = AreaState.EDGE\n        return self\n\n    def use_only_corners(self, corner_size: int = None, corner_size_x: int = None, corner_size_y: int = None) -&gt; Area:\n        \"\"\"\n        Sets the area object to only use the corners pattern within the selection.\n\n        Args:\n            corner_size: The size along both the x and y-axis of the corner areas\n            corner_size_x: The size along the x-axis of the corner areas\n            corner_size_y: The size along the y-axis of the corner areas\n\n        Returns:\n            This area object\n        \"\"\"\n        self.attrs(corner_size=corner_size, corner_size_x=corner_size_x, corner_size_y=corner_size_y)\n        self.state = AreaState.CORNERS\n        return self\n\n    def use_pattern_grid(\n            self,\n            block_size: int = None,\n            gap_size: int = None,\n            block_size_x: int = None,\n            block_size_y: int = None,\n            gap_size_x: int = None,\n            gap_size_y: int = None\n    ) -&gt; Area:\n        \"\"\"\n        Sets the area object to use a grid pattern within the selection.\n\n        Args:\n            block_size: The size of the gaps between lines\n            gap_size: The width of the grid lines\n            block_size_x: The size of the x gaps between lines\n            block_size_y: The size of the y gaps between lines\n            gap_size_x: The width of the x grid lines\n            gap_size_y: The width of the y grid lines\n\n        Returns:\n            This area object\n        \"\"\"\n        self.attrs(block_size=block_size, gap_size=gap_size,\n                   block_size_x=block_size_x, gap_size_x=gap_size_x,\n                   block_size_y=block_size_y, gap_size_y=gap_size_y)\n        self.state = AreaState.GRID\n        return self\n\n    def use_pattern_lines(self, axis: str = None, gap_size: int = None, line_width: int = None) -&gt; Area:\n        \"\"\"\n        Sets the area object to use a lines pattern within the selection.\n\n        Args:\n            axis: The axis the lines should follow. Can either be \"x\" or \"y\"\n            gap_size: The size of the gaps between lines\n            line_width: The width of the x &amp; y lines\n\n        Returns:\n            This area object\n        \"\"\"\n        if axis is not None:\n            axis = axis.lower()\n        self.attrs(axis=axis, gap_size=gap_size, line_width=line_width)\n        self.state = AreaState.LINES\n        return self\n\n    # ============================ Adjustment functions ============================\n\n    def invert(self) -&gt; Area:\n        \"\"\"\n        Inverts the inverted boolean. Causes the `to_coords` to return the inverted selection. This function is\n        especially useful for the grid state. It's not as useful for the edge which would be the same as shrinking the\n        selection. When used with the fill state an empty set is returned.\n\n        **Please note:** This inverts the INTERNAL selection. Tiles OUTSIDE the selection will NOT be returned.\n        \"\"\"\n        self.inverted = not self.inverted\n        return self\n\n    def along_axis(self, axis: str) -&gt; Area:\n        \"\"\"Sets the axis. Can be either \"x\" or \"y\". \"\"\"\n        self.axis = axis\n        return self\n\n    def attr(self, key: str | AreaAttr, value: int) -&gt; Area:\n        \"\"\"Sets the attribute to the given value. AreaAttr or str can be used as key\"\"\"\n        if isinstance(key, AreaAttr):\n            key = key.value\n\n        keys: List[str] = [key]\n        if key in ['line_width', 'gap_size', 'corner_size', 'block_size']:\n            keys = [key + '_x', key + '_y']\n\n        for key in keys:\n            setattr(self, key, value)\n        return self\n\n    def attrs(\n            self,\n            x1: int = None,\n            y1: int = None,\n            x2: int = None,\n            y2: int = None,\n            gap_size: int = None,\n            gap_size_x: int = None,\n            gap_size_y: int = None,\n            line_width: int = None,\n            line_width_x: int = None,\n            line_width_y: int = None,\n            axis: str = None,\n            corner_size: int = None,\n            corner_size_x: int = None,\n            corner_size_y: int = None,\n            block_size: int = None,\n            block_size_x: int = None,\n            block_size_y: int = None,\n    ) -&gt; Area:\n        \"\"\"\n        Sets multiple attributes to the corresponding values.\n\n        Returns:\n            This area object\n        \"\"\"\n        for key, value in locals().items():\n            if value is None or key == 'self':\n                continue\n            self.attr(key, value)\n        return self\n\n    def move(self, offset_x: int = 0, offset_y: int = 0):\n        \"\"\"Moves the selection area in a given direction relative to its current position\"\"\"\n        self.x1 += offset_x\n        self.y1 += offset_y\n        self.x2 += offset_x\n        self.y2 += offset_y\n        return self\n\n    def move_to(self, corner: Literal['west', 'north', 'east', 'south'], x: int, y: int):\n        \"\"\"\n        Moves the selection area to a given coordinate, placed from the given corner.\n        For center placement, use ``.center(...)``\n        \"\"\"\n        width = self.get_width() - 1\n        height = self.get_height() - 1\n\n        if corner == 'west':\n            self.x1, self.y1, self.x2, self.y2 = x, y, x + width, y + height\n        elif corner == 'north':\n            self.x1, self.y1, self.x2, self.y2 = x - width, y, x, y + height\n        elif corner == 'east':\n            self.x1, self.y1, self.x2, self.y2 = x - width, y - height, x, y\n        elif corner == 'south':\n            self.x1, self.y1, self.x2, self.y2 = x, y - height, x + width, y\n\n        return self\n\n    def size(self, n: int) -&gt; Area:\n        \"\"\"\n        Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become\n        ``((3,3), (5,5))``\n        \"\"\"\n        center_x, center_y = self.get_center_int()\n        n -= 1  # Ignore center tile\n        self.x1 = center_x - math.ceil(n / 2)\n        self.y1 = center_y - math.ceil(n / 2)\n        self.x2 = center_x + math.floor(n / 2)\n        self.y2 = center_y + math.floor(n / 2)\n        return self\n\n    def height(self, n: int) -&gt; Area:\n        \"\"\"\n        Sets the height (y-axis) of the selection. Shrinks/Expands both sides equally.\n        If the expansion hits the edge of the map, it'll expand on the other side.\n        \"\"\"\n        c1, c2 = self._get_length_change(n, self.get_height(), self.y1, self.y2)\n\n        self.y1 = self._y1 + c1\n        self.y2 = self._y2 + c2\n        return self\n\n    def width(self, n: int) -&gt; Area:\n        \"\"\"\n        Sets the width (x-axis) of the selection. Shrinks/Expands both sides equally.\n        If the expansion hits the edge of the map, it'll expand on the other side.\n        \"\"\"\n        c1, c2 = self._get_length_change(n, self.get_width(), self.x1, self.x2)\n\n        self.x1 = self._x1 + c1\n        self.x2 = self._x2 + c2\n        return self\n\n    def center(self, x: int, y: int) -&gt; Area:\n        \"\"\"\n        Moves the selection center to a given position. When the given center forces the selection of the edge of the\n        map the off-map tiles will not be returned. When moving the selection back into the map the tiles will be\n        returned again.\n\n        If you want to limit moving the center without changing the selection box size, use: ``center_bounded``\n        \"\"\"\n        center_x, center_y = self.get_center()\n        diff_x, diff_y = math.floor(x - center_x), math.floor(y - center_y)\n        self.x1 = self._x1 + diff_x\n        self.y1 = self._y1 + diff_y\n        self.x2 = self._x2 + diff_x\n        self.y2 = self._y2 + diff_y\n        return self\n\n    def center_bounded(self, x: int, y: int) -&gt; Area:\n        \"\"\"\n        Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge\n        of the map. The selection will be forced against the edge of the map and the selection will not be decreased in\n        size.\n        \"\"\"\n        self._force_map_size()\n\n        center_x, center_y = self.get_center()\n        diff_x, diff_y = math.floor(x - center_x), math.floor(y - center_y)\n        if diff_x &lt; 0 and abs(diff_x) &gt; self.x1:\n            diff_x = -self.x1\n        elif diff_x &gt; 0 and diff_x &gt; (distance_x := self.maximum_coordinate - self.x2):\n            diff_x = distance_x\n        if diff_y &lt; 0 and abs(diff_y) &gt; self.y1:\n            diff_y = -self.y1\n        elif diff_y &gt; 0 and diff_y &gt; (distance_y := self.maximum_coordinate - self.y2):\n            diff_y = distance_y\n        self.x1 += diff_x\n        self.y1 += diff_y\n        self.x2 += diff_x\n        self.y2 += diff_y\n        return self\n\n    def select_entire_map(self) -&gt; Area:\n        \"\"\"Sets the selection to the entire map\"\"\"\n        self.x1, self.y1, self.x2, self.y2 = 0, 0, self._map_size, self._map_size\n        return self\n\n    def select(self, x1: int, y1: int, x2: int = None, y2: int = None) -&gt; Area:\n        \"\"\"Sets the selection to the given coordinates\"\"\"\n        x2, y2 = self._negative_coord(x2, y2)\n\n        self.x1, self.y1, self.x2, self.y2 = validate_coords(x1, y1, x2, y2)\n\n        return self\n\n    def select_centered(self, x: int, y: int, dx: int = 1, dy: int = 1) -&gt; Area:\n        \"\"\"Sets the selection to the given coordinates\"\"\"\n        half_x, half_y = (dx - 1) / 2, (dy - 1) / 2\n        self.select(\n            x1=x - math.ceil(half_x),\n            y1=y - math.ceil(half_y),\n            x2=x + math.floor(half_x),\n            y2=y + math.floor(half_y),\n        )\n        return self\n\n    def shrink(self, n: int) -&gt; Area:\n        \"\"\"Shrinks the selection from all sides\"\"\"\n        self.shrink_x1(n)\n        self.shrink_y1(n)\n        self.shrink_x2(n)\n        self.shrink_y2(n)\n        return self\n\n    def shrink_x1(self, n: int) -&gt; Area:\n        \"\"\"Shrinks the selection from the first corner on the X axis by n\"\"\"\n        self.x1 = min(self._x1 + n, self._x2)\n        return self\n\n    def shrink_y1(self, n: int) -&gt; Area:\n        \"\"\"Shrinks the selection from the first corner on the Y axis by n\"\"\"\n        self.y1 = min(self._y1 + n, self._y2)\n        return self\n\n    def shrink_x2(self, n: int) -&gt; Area:\n        \"\"\"Shrinks the selection from the second corner on the X axis by n\"\"\"\n        self.x2 = max(self._x1, self._x2 - n)\n        return self\n\n    def shrink_y2(self, n: int) -&gt; Area:\n        \"\"\"Shrinks the selection from the second corner on the Y axis by n\"\"\"\n        self.y2 = max(self._y1, self._y2 - n)\n        return self\n\n    def expand(self, n: int) -&gt; Area:\n        \"\"\"Expands the selection from all sides\"\"\"\n        self.expand_x1(n)\n        self.expand_y1(n)\n        self.expand_x2(n)\n        self.expand_y2(n)\n        return self\n\n    def expand_x1(self, n: int) -&gt; Area:\n        \"\"\"Expands the selection from the first corner on the X axis by n\"\"\"\n        self.x1 = self.x1 - n\n        return self\n\n    def expand_y1(self, n: int) -&gt; Area:\n        \"\"\"Expands the selection from the first corner on the Y axis by n\"\"\"\n        self.y1 = self.y1 - n\n        return self\n\n    def expand_x2(self, n: int) -&gt; Area:\n        \"\"\"Expands the selection from the second corner on the X axis by n\"\"\"\n        self.x2 = self.x2 + n\n        return self\n\n    def expand_y2(self, n: int) -&gt; Area:\n        \"\"\"Expands the selection from the second corner on the Y axis by n\"\"\"\n        self.y2 = self.y2 + n\n        return self\n\n    # ============================ Test against ... functions ============================\n\n    def is_within_selection(self, x: int = -1, y: int = -1, tile: Tile = None) -&gt; bool:\n        \"\"\"\n        If a given (x,y) location is within the selection.\n\n        Args:\n            x: The X coordinate\n            y: The Y coordinate\n            tile: A Tile object, replacing the x &amp; y coordinates\n\n        Returns:\n            `True` if (x,y) is within the selection, `False` otherwise\n        \"\"\"\n        if tile is not None:\n            x, y = tile\n\n        if not (self._x1 &lt;= x &lt;= self._x2 and self._y1 &lt;= y &lt;= self._y2):\n            return False\n\n        is_within: bool\n        if self.state == AreaState.EDGE:\n            is_within = self._is_edge_tile(x, y)\n        elif self.state == AreaState.GRID:\n            is_within = self._is_a_grid_tile(x, y)\n        elif self.state == AreaState.LINES:\n            is_within = self._is_a_line_tile(x, y)\n        elif self.state == AreaState.CORNERS:\n            is_within = self._is_a_corner_tile(x, y)\n        else:\n            is_within = True\n        return self._invert_if_inverted(is_within)\n\n    def is_within_bounds(self) -&gt; bool:\n        \"\"\"Check if the current selection is within the map\"\"\"\n        self._force_map_size()\n\n        return 0 &lt;= self._x1 &lt; self.map_size \\\n            and 0 &lt;= self._y1 &lt; self.map_size \\\n            and 0 &lt;= self._x2 &lt; self.map_size \\\n            and 0 &lt;= self._y2 &lt; self.map_size\n\n    # ============================ Miscellaneous functions ============================\n\n    def copy(self) -&gt; Area:\n        \"\"\"\n        Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source\n        with small tweaks.\n\n        Examples:\n\n            Get a grid and the surrounding edge::\n\n                area = Area.select(10,10,20,20)\n                edge = area.copy().expand(1).use_only_edge().to_coords()\n                # Without copy you'd have to undo all changes above. In this case that'd be: `.shrink(1)`\n                grid = area.use_pattern_grid().to_coords()\n\n        Returns:\n            A copy of this Area object\n        \"\"\"\n        return copy.copy(self)\n\n    # ============================ Support functions ============================\n\n    def _get_length_change(self, new_len: int, cur_len: int, first_coord: int, second_coord) -&gt; Tuple[int, int]:\n        \"\"\"\n        Calculate the differences in tiles for the 2 points (x1 &amp; x2) or (y1 &amp; y2) when the length of an edge is changed\n\n        Args:\n            new_len: The new length\n            cur_len: The current length\n            first_coord: Coord of the first corner (x1 or y1)\n            second_coord: Coord of the first corner (x2 or y2)\n\n        Returns:\n            The differences for the first and second coordinate. Can be negative and positive ints.\n        \"\"\"\n        half: float = (new_len - cur_len) / 2\n        half1, half2 = -half, half\n        if half &gt; 0:\n            if half &gt; first_coord:\n                half1 = -first_coord\n                half2 += half - first_coord\n            if half &gt; (dist := self._map_size_safe - second_coord):\n                half2 = dist\n                half1 += half - dist\n            return math.floor(half1), math.floor(half2)\n        return math.ceil(half1), math.ceil(half2)\n\n    def _is_edge_tile(self, x: int, y: int) -&gt; bool:\n        \"\"\" Returns if a given tile (x,y) is an edge tile of the set selection given a certain edge width.\"\"\"\n        return any((\n            0 &lt;= x - self.x1 &lt; self.line_width_x,\n            0 &lt;= y - self.y1 &lt; self.line_width_y,\n            0 &lt;= self.x2 - x &lt; self.line_width_x,\n            0 &lt;= self.y2 - y &lt; self.line_width_y\n        ))\n\n    def _invert_if_inverted(self, bool_: bool) -&gt; bool:\n        \"\"\"Inverts the boolean if the area is in inverted state.\"\"\"\n        return not bool_ if self.inverted else bool_\n\n    def _is_a_corner_tile(self, x: int, y: int) -&gt; bool:\n        \"\"\"If a given (x,y) location is a corner tile.\"\"\"\n        return ((self.x1 &lt;= x &lt; self.x1 + self.corner_size_x) or (self.x2 - self.corner_size_x &lt; x &lt;= self.x2)) and \\\n            ((self.y1 &lt;= y &lt; self.y1 + self.corner_size_y) or (self.y2 - self.corner_size_y &lt; y &lt;= self.y2))\n\n    def _is_a_grid_tile(self, x: int, y: int) -&gt; bool:\n        \"\"\"If a given (x,y) location is within the grid selection.\"\"\"\n        return (x - self.x1) % (self.block_size_x + self.gap_size_x) &lt; self.block_size_x and \\\n            (y - self.y1) % (self.block_size_y + self.gap_size_y) &lt; self.block_size_y\n\n    def _is_a_line_tile(self, x: int, y: int) -&gt; bool:\n        \"\"\"If a given (x,y) location is within the grid selection.\"\"\"\n        if self.axis == \"x\":\n            return (y - self.y1) % (self.gap_size_y + self.line_width_y) &lt; self.line_width_y\n        elif self.axis == \"y\":\n            return (x - self.x1) % (self.gap_size_x + self.line_width_x) &lt; self.line_width_x\n        raise ValueError(\"Invalid axis value. Should be either x or y\")\n\n    def _minmax_val(self, val: int | float) -&gt; int | float:\n        \"\"\"Keeps a given value within the bounds of ``0 &lt;= val &lt; map_size``.\"\"\"\n        return max(0, min(val, self.maximum_coordinate))\n\n    def _negative_coord(self, *args: int) -&gt; List[int]:\n        \"\"\"Converts negative coordinates to the non negative value. Like: ``-1 == 119`` when ``map_size = 119``\"\"\"\n        return [\n            (self._map_size + coord) if coord and coord &lt; 0 else coord\n            for coord in args\n        ]\n\n    def _tiles_to_terrain_tiles(self, tiles: Iterable[Tile]) -&gt; OrderedSet['TerrainTile']:\n        \"\"\"\n        Converts the selection to an OrderedSet of terrain tile objects from the map manager.\n        Can only be used if the area has been associated with a scenario.\n\n        Returns:\n            An OrderedSet of terrain tiles from the map manager based on the selection.\n        \"\"\"\n        self._force_association()\n        terrain = getters.get_terrain(self.uuid)\n        map_size = self._map_size\n        return OrderedSet(terrain[xy_to_i(x, y, map_size)] for (x, y) in tiles)\n\n    def _get_chunk_id(self, tile: Tile) -&gt; int:\n        \"\"\"\n        This function gets the Chunk id of a tile based on the current state and configs. The chunk ID identifies which\n        chunk the given tile is in. This is useful for separating chunks that are connected but shouldn't be in the same\n        chunk (like when creating a checker or stripe pattern)\n\n        Args:\n            tile: The tile to check as Tile object\n\n        Returns:\n            The int ID of the chunk, or, -1 when it's not in a selection, or 0 when the selection cannot be split into\n                chunks.\n\n        Raises:\n            ValueError: if the area configuration isn't supported by this function.\n        \"\"\"\n        if not self.is_within_selection(tile=tile):\n            return -1\n\n        if self.state in AreaState.unchunkables():\n            return 0\n\n        elif self.state == AreaState.GRID:\n            if self.inverted:\n                return 0\n            per_row = math.ceil(self.get_height() / (self.block_size_x + self.gap_size_x))\n            return (tile.x - self.x1) // (self.block_size_x + self.gap_size_x) + \\\n                (tile.y - self.y1) // (self.block_size_y + self.gap_size_y) * per_row\n\n        elif self.state == AreaState.LINES:\n            if self.axis == \"x\":\n                return (tile.y - self.y1) // (self.line_width_y + self.gap_size_y)\n            elif self.axis == \"y\":\n                return (tile.x - self.x1) // (self.line_width_x + self.gap_size_x)\n\n        elif self.state == AreaState.CORNERS:\n            # 0 Left, 1 Top, 2 Right, 3 Bottom\n            if self.x1 &lt;= tile.x &lt; self.x1 + self.corner_size_x and self.y1 &lt;= tile.y &lt; self.y1 + self.corner_size_y:\n                return 0\n            if self.x2 - self.corner_size_x &lt; tile.x &lt;= self.x2 and self.y1 &lt;= tile.y &lt; self.y1 + self.corner_size_y:\n                return 1\n            if self.x2 - self.corner_size_x &lt; tile.x &lt;= self.x2 and self.y2 - self.corner_size_y &lt; tile.y &lt;= self.y2:\n                return 2\n            if self.x1 &lt;= tile.x &lt; self.x1 + self.corner_size_x and self.y2 - self.corner_size_y &lt; tile.y &lt;= self.y2:\n                return 3\n        raise ValueError(f\"Invalid area configuration for getting the Chunk ID. If you believe this is an error, \"\n                         f\"please raise an issue on github or in the Discord server\")\n\n    def __repr__(self) -&gt; str:\n        return f\"Area(x1={self.x1}, y1={self.y1}, x2={self.x2}, y2={self.y2}, state={self.state.name})\"\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area-attributes","title":"Attributes","text":""},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.axis","title":"<code>axis: str = ''</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>''</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.block_size_x","title":"<code>block_size_x: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.block_size_y","title":"<code>block_size_y: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.corner1","title":"<code>corner1</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.corner2","title":"<code>corner2</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.corner_size_x","title":"<code>corner_size_x: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.corner_size_y","title":"<code>corner_size_y: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.gap_size_x","title":"<code>gap_size_x: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.gap_size_y","title":"<code>gap_size_y: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.inverted","title":"<code>inverted: bool = False</code>  <code>instance-attribute</code>","text":"Type: <code>bool</code>                           Value: <code>False</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.line_width_x","title":"<code>line_width_x: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.line_width_y","title":"<code>line_width_y: int = 1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>1</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.map_size","title":"<code>map_size</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.maximum_coordinate","title":"<code>maximum_coordinate: int</code>  <code>property</code>","text":"Type: <code>int</code> <p>The maximum coordinate for the X or Y axis (like how 0 is the minimum)</p>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.state","title":"<code>state: AreaState = AreaState.FULL</code>  <code>instance-attribute</code>","text":"Type: <code>AreaState</code>                           Value: <code>AreaState.FULL</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.uuid","title":"<code>uuid: UUID = uuid</code>  <code>instance-attribute</code>","text":"Type: <code>UUID</code>                           Value: <code>uuid</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.x1","title":"<code>x1: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.x2","title":"<code>x2: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.y1","title":"<code>y1: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.y2","title":"<code>y2: int</code>  <code>property</code> <code>writable</code>","text":"Type: <code>int</code>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area-functions","title":"Functions","text":""},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.__init__","title":"<code>def __init__(...)</code>","text":"<p>Object to easily select an area on the map. Uses method chaining for ease of use.</p> <p>Please note: Setting a <code>uuid</code> will always overwrite the <code>map_size</code> attribute, even if it's not <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>map_size</code> <code>int</code> <p>The size of the map this area object will handle</p> <code>None</code> <code>uuid</code> <code>UUID</code> <p>The UUID of the scenario this area belongs to</p> <code>None</code> <code>x1</code> <code>int</code> <p>The X location of the left corner</p> <code>None</code> <code>y1</code> <code>int</code> <p>The Y location of the left corner</p> <code>None</code> <code>x2</code> <code>int</code> <p>The X location of the right corner</p> <code>None</code> <code>y2</code> <code>int</code> <p>The Y location of the right corner</p> <code>None</code> <code>corner1</code> <code>Tile</code> <p>The location of the left corner</p> <code>None</code> <code>corner2</code> <code>Tile</code> <p>The location of the right corner</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def __init__(\n        self,\n        map_size: int = None,\n        uuid: UUID = None,\n        x1: int = None,\n        y1: int = None,\n        x2: int = None,\n        y2: int = None,\n        corner1: Tile = None,\n        corner2: Tile = None,\n) -&gt; None:\n    \"\"\"\n    Object to easily select an area on the map. Uses method chaining for ease of use.\n\n    **Please note**: Setting a ``uuid`` will always overwrite the ``map_size`` attribute, even if it's not ``None``.\n\n    Args:\n        map_size: The size of the map this area object will handle\n        uuid: The UUID of the scenario this area belongs to\n        x1: The X location of the left corner\n        y1: The Y location of the left corner\n        x2: The X location of the right corner\n        y2: The Y location of the right corner\n        corner1: The location of the left corner\n        corner2: The location of the right corner\n    \"\"\"\n    if map_size is None and uuid is None:\n        if corner1 is None and (x1 is None or y1 is None):\n            raise ValueError(\"Cannot create area object without knowing the map size or a UUID from a scenario.\")\n\n    self.uuid: UUID = uuid\n    if map_size is not None:\n        self._map_size_value = map_size\n    else:\n        self._map_size_value = None\n\n    if values_are_valid(x1, y1) or value_is_valid(corner1):\n        x1, y1, x2, y2 = validate_coords(x1, y1, x2, y2, corner1, corner2)\n    else:\n        x1 = y1 = x2 = y2 = math.floor(self._map_size / 2)  # Select the center tile\n\n    self.state: AreaState = AreaState.FULL\n    self.inverted: bool = False\n\n    self.x1: int = x1\n    self.y1: int = y1\n    self.x2: int = x2\n    self.y2: int = y2\n\n    self.gap_size_x: int = 1\n    self.gap_size_y: int = 1\n    self.line_width_x: int = 1\n    self.line_width_y: int = 1\n    self.block_size_x: int = 1\n    self.block_size_y: int = 1\n\n    self.axis: str = \"\"\n\n    self.corner_size_x: int = 1\n    self.corner_size_y: int = 1\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.__repr__","title":"<code>def __repr__(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Area(x1={self.x1}, y1={self.y1}, x2={self.x2}, y2={self.y2}, state={self.state.name})\"\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.along_axis","title":"<code>def along_axis(...)</code>","text":"<p>Sets the axis. Can be either \"x\" or \"y\".</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def along_axis(self, axis: str) -&gt; Area:\n    \"\"\"Sets the axis. Can be either \"x\" or \"y\". \"\"\"\n    self.axis = axis\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.associate_scenario","title":"<code>def associate_scenario(...)</code>","text":"<p>Associate area with scenario. Saves scenario UUID in this area object.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>AoE2Scenario</code> <p>The scenario to associate with</p> required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def associate_scenario(self, scenario: AoE2Scenario) -&gt; None:\n    \"\"\"\n    Associate area with scenario. Saves scenario UUID in this area object.\n\n    Args:\n        scenario: The scenario to associate with\n    \"\"\"\n    self.uuid = scenario.uuid\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.attr","title":"<code>def attr(...)</code>","text":"<p>Sets the attribute to the given value. AreaAttr or str can be used as key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | AreaAttr</code>  - required <code>value</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def attr(self, key: str | AreaAttr, value: int) -&gt; Area:\n    \"\"\"Sets the attribute to the given value. AreaAttr or str can be used as key\"\"\"\n    if isinstance(key, AreaAttr):\n        key = key.value\n\n    keys: List[str] = [key]\n    if key in ['line_width', 'gap_size', 'corner_size', 'block_size']:\n        keys = [key + '_x', key + '_y']\n\n    for key in keys:\n        setattr(self, key, value)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.attrs","title":"<code>def attrs(...)</code>","text":"<p>Sets multiple attributes to the corresponding values.</p> <p>Returns:</p> Type Description <code>Area</code> <p>This area object</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code>  - <code>None</code> <code>y1</code> <code>int</code>  - <code>None</code> <code>x2</code> <code>int</code>  - <code>None</code> <code>y2</code> <code>int</code>  - <code>None</code> <code>gap_size</code> <code>int</code>  - <code>None</code> <code>gap_size_x</code> <code>int</code>  - <code>None</code> <code>gap_size_y</code> <code>int</code>  - <code>None</code> <code>line_width</code> <code>int</code>  - <code>None</code> <code>line_width_x</code> <code>int</code>  - <code>None</code> <code>line_width_y</code> <code>int</code>  - <code>None</code> <code>axis</code> <code>str</code>  - <code>None</code> <code>corner_size</code> <code>int</code>  - <code>None</code> <code>corner_size_x</code> <code>int</code>  - <code>None</code> <code>corner_size_y</code> <code>int</code>  - <code>None</code> <code>block_size</code> <code>int</code>  - <code>None</code> <code>block_size_x</code> <code>int</code>  - <code>None</code> <code>block_size_y</code> <code>int</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def attrs(\n        self,\n        x1: int = None,\n        y1: int = None,\n        x2: int = None,\n        y2: int = None,\n        gap_size: int = None,\n        gap_size_x: int = None,\n        gap_size_y: int = None,\n        line_width: int = None,\n        line_width_x: int = None,\n        line_width_y: int = None,\n        axis: str = None,\n        corner_size: int = None,\n        corner_size_x: int = None,\n        corner_size_y: int = None,\n        block_size: int = None,\n        block_size_x: int = None,\n        block_size_y: int = None,\n) -&gt; Area:\n    \"\"\"\n    Sets multiple attributes to the corresponding values.\n\n    Returns:\n        This area object\n    \"\"\"\n    for key, value in locals().items():\n        if value is None or key == 'self':\n            continue\n        self.attr(key, value)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.center","title":"<code>def center(...)</code>","text":"<p>Moves the selection center to a given position. When the given center forces the selection of the edge of the map the off-map tiles will not be returned. When moving the selection back into the map the tiles will be returned again.</p> <p>If you want to limit moving the center without changing the selection box size, use: <code>center_bounded</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code>  - required <code>y</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def center(self, x: int, y: int) -&gt; Area:\n    \"\"\"\n    Moves the selection center to a given position. When the given center forces the selection of the edge of the\n    map the off-map tiles will not be returned. When moving the selection back into the map the tiles will be\n    returned again.\n\n    If you want to limit moving the center without changing the selection box size, use: ``center_bounded``\n    \"\"\"\n    center_x, center_y = self.get_center()\n    diff_x, diff_y = math.floor(x - center_x), math.floor(y - center_y)\n    self.x1 = self._x1 + diff_x\n    self.y1 = self._y1 + diff_y\n    self.x2 = self._x2 + diff_x\n    self.y2 = self._y2 + diff_y\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.center_bounded","title":"<code>def center_bounded(...)</code>","text":"<p>Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge of the map. The selection will be forced against the edge of the map and the selection will not be decreased in size.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code>  - required <code>y</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def center_bounded(self, x: int, y: int) -&gt; Area:\n    \"\"\"\n    Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge\n    of the map. The selection will be forced against the edge of the map and the selection will not be decreased in\n    size.\n    \"\"\"\n    self._force_map_size()\n\n    center_x, center_y = self.get_center()\n    diff_x, diff_y = math.floor(x - center_x), math.floor(y - center_y)\n    if diff_x &lt; 0 and abs(diff_x) &gt; self.x1:\n        diff_x = -self.x1\n    elif diff_x &gt; 0 and diff_x &gt; (distance_x := self.maximum_coordinate - self.x2):\n        diff_x = distance_x\n    if diff_y &lt; 0 and abs(diff_y) &gt; self.y1:\n        diff_y = -self.y1\n    elif diff_y &gt; 0 and diff_y &gt; (distance_y := self.maximum_coordinate - self.y2):\n        diff_y = distance_y\n    self.x1 += diff_x\n    self.y1 += diff_y\n    self.x2 += diff_x\n    self.y2 += diff_y\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.copy","title":"<code>def copy(...)</code>","text":"<p>Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source with small tweaks.</p> <p>Examples:</p> <pre><code>Get a grid and the surrounding edge::\n\n    area = Area.select(10,10,20,20)\n    edge = area.copy().expand(1).use_only_edge().to_coords()\n    # Without copy you'd have to undo all changes above. In this case that'd be: `.shrink(1)`\n    grid = area.use_pattern_grid().to_coords()\n</code></pre> <p>Returns:</p> Type Description <code>Area</code> <p>A copy of this Area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def copy(self) -&gt; Area:\n    \"\"\"\n    Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source\n    with small tweaks.\n\n    Examples:\n\n        Get a grid and the surrounding edge::\n\n            area = Area.select(10,10,20,20)\n            edge = area.copy().expand(1).use_only_edge().to_coords()\n            # Without copy you'd have to undo all changes above. In this case that'd be: `.shrink(1)`\n            grid = area.use_pattern_grid().to_coords()\n\n    Returns:\n        A copy of this Area object\n    \"\"\"\n    return copy.copy(self)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.expand","title":"<code>def expand(...)</code>","text":"<p>Expands the selection from all sides</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def expand(self, n: int) -&gt; Area:\n    \"\"\"Expands the selection from all sides\"\"\"\n    self.expand_x1(n)\n    self.expand_y1(n)\n    self.expand_x2(n)\n    self.expand_y2(n)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.expand_x1","title":"<code>def expand_x1(...)</code>","text":"<p>Expands the selection from the first corner on the X axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def expand_x1(self, n: int) -&gt; Area:\n    \"\"\"Expands the selection from the first corner on the X axis by n\"\"\"\n    self.x1 = self.x1 - n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.expand_x2","title":"<code>def expand_x2(...)</code>","text":"<p>Expands the selection from the second corner on the X axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def expand_x2(self, n: int) -&gt; Area:\n    \"\"\"Expands the selection from the second corner on the X axis by n\"\"\"\n    self.x2 = self.x2 + n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.expand_y1","title":"<code>def expand_y1(...)</code>","text":"<p>Expands the selection from the first corner on the Y axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def expand_y1(self, n: int) -&gt; Area:\n    \"\"\"Expands the selection from the first corner on the Y axis by n\"\"\"\n    self.y1 = self.y1 - n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.expand_y2","title":"<code>def expand_y2(...)</code>","text":"<p>Expands the selection from the second corner on the Y axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def expand_y2(self, n: int) -&gt; Area:\n    \"\"\"Expands the selection from the second corner on the Y axis by n\"\"\"\n    self.y2 = self.y2 + n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.from_tiles","title":"<code>def from_tiles(...)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>corner1</code> <code>Tile</code>  - required <code>corner2</code> <code>Tile</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>@classmethod\ndef from_tiles(cls, corner1: Tile, corner2: Tile = None):\n    return cls(corner1=corner1, corner2=corner2)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.from_uuid","title":"<code>def from_uuid(...)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>UUID</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>@classmethod\ndef from_uuid(cls, uuid: UUID) -&gt; Area:\n    return cls(uuid=uuid)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_center","title":"<code>def get_center(...)</code>","text":"<p>Get center of current selection</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_center(self) -&gt; Tuple[float, float]:\n    \"\"\"Get center of current selection\"\"\"\n    return (self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_center_int","title":"<code>def get_center_int(...)</code>","text":"<p>Get center of current selection, coords can only be integers. If even length, the value is ceiled</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_center_int(self) -&gt; Tuple[int, int]:\n    \"\"\"Get center of current selection, coords can only be integers. If even length, the value is ceiled\"\"\"\n    return math.ceil((self.x1 + self.x2) / 2), math.ceil((self.y1 + self.y2) / 2)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_dimensions","title":"<code>def get_dimensions(...)</code>","text":"<p>Returns the lengths of the x &amp; y side of the selection (in that order).</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_dimensions(self) -&gt; Tuple[int, int]:\n    \"\"\"Returns the lengths of the x &amp; y side of the selection (in that order).\"\"\"\n    return self.get_width(), self.get_height()\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_height","title":"<code>def get_height(...)</code>","text":"<p>Returns the length of the y side of the selection.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"Returns the length of the y side of the selection.\"\"\"\n    return self.y2 + 1 - self.y1\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_range_x","title":"<code>def get_range_x(...)</code>","text":"<p>Returns a range object for the x coordinates.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_range_x(self) -&gt; range:\n    \"\"\"Returns a range object for the x coordinates.\"\"\"\n    return range(self.x1, self.x2 + 1)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_range_y","title":"<code>def get_range_y(...)</code>","text":"<p>Returns a range object for the y coordinates.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_range_y(self) -&gt; range:\n    \"\"\"Returns a range object for the y coordinates.\"\"\"\n    return range(self.y1, self.y2 + 1)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_raw_selection","title":"<code>def get_raw_selection(...)</code>","text":"<p>Get the four values of the selection (even if they are outside the map) as: ((x1, y1), (x2, y2))</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_raw_selection(self) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Get the four values of the selection (even if they are outside the map) as: ((x1, y1), (x2, y2))\"\"\"\n    return (self._x1, self._y1), (self._x2, self._y2)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_selection","title":"<code>def get_selection(...)</code>","text":"<p>Get the four values of the selection as: ((x1, y1), (x2, y2))</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_selection(self) -&gt; Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"Get the four values of the selection as: ((x1, y1), (x2, y2))\"\"\"\n    return (self.x1, self.y1), (self.x2, self.y2)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.get_width","title":"<code>def get_width(...)</code>","text":"<p>Returns the length of the x side of the selection.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"Returns the length of the x side of the selection.\"\"\"\n    return self.x2 + 1 - self.x1\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.height","title":"<code>def height(...)</code>","text":"<p>Sets the height (y-axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def height(self, n: int) -&gt; Area:\n    \"\"\"\n    Sets the height (y-axis) of the selection. Shrinks/Expands both sides equally.\n    If the expansion hits the edge of the map, it'll expand on the other side.\n    \"\"\"\n    c1, c2 = self._get_length_change(n, self.get_height(), self.y1, self.y2)\n\n    self.y1 = self._y1 + c1\n    self.y2 = self._y2 + c2\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.invert","title":"<code>def invert(...)</code>","text":"<p>Inverts the inverted boolean. Causes the <code>to_coords</code> to return the inverted selection. This function is especially useful for the grid state. It's not as useful for the edge which would be the same as shrinking the selection. When used with the fill state an empty set is returned.</p> <p>Please note: This inverts the INTERNAL selection. Tiles OUTSIDE the selection will NOT be returned.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def invert(self) -&gt; Area:\n    \"\"\"\n    Inverts the inverted boolean. Causes the `to_coords` to return the inverted selection. This function is\n    especially useful for the grid state. It's not as useful for the edge which would be the same as shrinking the\n    selection. When used with the fill state an empty set is returned.\n\n    **Please note:** This inverts the INTERNAL selection. Tiles OUTSIDE the selection will NOT be returned.\n    \"\"\"\n    self.inverted = not self.inverted\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.is_within_bounds","title":"<code>def is_within_bounds(...)</code>","text":"<p>Check if the current selection is within the map</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def is_within_bounds(self) -&gt; bool:\n    \"\"\"Check if the current selection is within the map\"\"\"\n    self._force_map_size()\n\n    return 0 &lt;= self._x1 &lt; self.map_size \\\n        and 0 &lt;= self._y1 &lt; self.map_size \\\n        and 0 &lt;= self._x2 &lt; self.map_size \\\n        and 0 &lt;= self._y2 &lt; self.map_size\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.is_within_selection","title":"<code>def is_within_selection(...)</code>","text":"<p>If a given (x,y) location is within the selection.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The X coordinate</p> <code>-1</code> <code>y</code> <code>int</code> <p>The Y coordinate</p> <code>-1</code> <code>tile</code> <code>Tile</code> <p>A Tile object, replacing the x &amp; y coordinates</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if (x,y) is within the selection, <code>False</code> otherwise</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def is_within_selection(self, x: int = -1, y: int = -1, tile: Tile = None) -&gt; bool:\n    \"\"\"\n    If a given (x,y) location is within the selection.\n\n    Args:\n        x: The X coordinate\n        y: The Y coordinate\n        tile: A Tile object, replacing the x &amp; y coordinates\n\n    Returns:\n        `True` if (x,y) is within the selection, `False` otherwise\n    \"\"\"\n    if tile is not None:\n        x, y = tile\n\n    if not (self._x1 &lt;= x &lt;= self._x2 and self._y1 &lt;= y &lt;= self._y2):\n        return False\n\n    is_within: bool\n    if self.state == AreaState.EDGE:\n        is_within = self._is_edge_tile(x, y)\n    elif self.state == AreaState.GRID:\n        is_within = self._is_a_grid_tile(x, y)\n    elif self.state == AreaState.LINES:\n        is_within = self._is_a_line_tile(x, y)\n    elif self.state == AreaState.CORNERS:\n        is_within = self._is_a_corner_tile(x, y)\n    else:\n        is_within = True\n    return self._invert_if_inverted(is_within)\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.move","title":"<code>def move(...)</code>","text":"<p>Moves the selection area in a given direction relative to its current position</p> <p>Parameters:</p> Name Type Description Default <code>offset_x</code> <code>int</code>  - <code>0</code> <code>offset_y</code> <code>int</code>  - <code>0</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def move(self, offset_x: int = 0, offset_y: int = 0):\n    \"\"\"Moves the selection area in a given direction relative to its current position\"\"\"\n    self.x1 += offset_x\n    self.y1 += offset_y\n    self.x2 += offset_x\n    self.y2 += offset_y\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.move_to","title":"<code>def move_to(...)</code>","text":"<p>Moves the selection area to a given coordinate, placed from the given corner. For center placement, use <code>.center(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>corner</code> <code>Literal['west', 'north', 'east', 'south']</code>  - required <code>x</code> <code>int</code>  - required <code>y</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def move_to(self, corner: Literal['west', 'north', 'east', 'south'], x: int, y: int):\n    \"\"\"\n    Moves the selection area to a given coordinate, placed from the given corner.\n    For center placement, use ``.center(...)``\n    \"\"\"\n    width = self.get_width() - 1\n    height = self.get_height() - 1\n\n    if corner == 'west':\n        self.x1, self.y1, self.x2, self.y2 = x, y, x + width, y + height\n    elif corner == 'north':\n        self.x1, self.y1, self.x2, self.y2 = x - width, y, x, y + height\n    elif corner == 'east':\n        self.x1, self.y1, self.x2, self.y2 = x - width, y - height, x, y\n    elif corner == 'south':\n        self.x1, self.y1, self.x2, self.y2 = x, y - height, x + width, y\n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.select","title":"<code>def select(...)</code>","text":"<p>Sets the selection to the given coordinates</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code>  - required <code>y1</code> <code>int</code>  - required <code>x2</code> <code>int</code>  - <code>None</code> <code>y2</code> <code>int</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def select(self, x1: int, y1: int, x2: int = None, y2: int = None) -&gt; Area:\n    \"\"\"Sets the selection to the given coordinates\"\"\"\n    x2, y2 = self._negative_coord(x2, y2)\n\n    self.x1, self.y1, self.x2, self.y2 = validate_coords(x1, y1, x2, y2)\n\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.select_centered","title":"<code>def select_centered(...)</code>","text":"<p>Sets the selection to the given coordinates</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code>  - required <code>y</code> <code>int</code>  - required <code>dx</code> <code>int</code>  - <code>1</code> <code>dy</code> <code>int</code>  - <code>1</code> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def select_centered(self, x: int, y: int, dx: int = 1, dy: int = 1) -&gt; Area:\n    \"\"\"Sets the selection to the given coordinates\"\"\"\n    half_x, half_y = (dx - 1) / 2, (dy - 1) / 2\n    self.select(\n        x1=x - math.ceil(half_x),\n        y1=y - math.ceil(half_y),\n        x2=x + math.floor(half_x),\n        y2=y + math.floor(half_y),\n    )\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.select_entire_map","title":"<code>def select_entire_map(...)</code>","text":"<p>Sets the selection to the entire map</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def select_entire_map(self) -&gt; Area:\n    \"\"\"Sets the selection to the entire map\"\"\"\n    self.x1, self.y1, self.x2, self.y2 = 0, 0, self._map_size, self._map_size\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.shrink","title":"<code>def shrink(...)</code>","text":"<p>Shrinks the selection from all sides</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def shrink(self, n: int) -&gt; Area:\n    \"\"\"Shrinks the selection from all sides\"\"\"\n    self.shrink_x1(n)\n    self.shrink_y1(n)\n    self.shrink_x2(n)\n    self.shrink_y2(n)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.shrink_x1","title":"<code>def shrink_x1(...)</code>","text":"<p>Shrinks the selection from the first corner on the X axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def shrink_x1(self, n: int) -&gt; Area:\n    \"\"\"Shrinks the selection from the first corner on the X axis by n\"\"\"\n    self.x1 = min(self._x1 + n, self._x2)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.shrink_x2","title":"<code>def shrink_x2(...)</code>","text":"<p>Shrinks the selection from the second corner on the X axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def shrink_x2(self, n: int) -&gt; Area:\n    \"\"\"Shrinks the selection from the second corner on the X axis by n\"\"\"\n    self.x2 = max(self._x1, self._x2 - n)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.shrink_y1","title":"<code>def shrink_y1(...)</code>","text":"<p>Shrinks the selection from the first corner on the Y axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def shrink_y1(self, n: int) -&gt; Area:\n    \"\"\"Shrinks the selection from the first corner on the Y axis by n\"\"\"\n    self.y1 = min(self._y1 + n, self._y2)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.shrink_y2","title":"<code>def shrink_y2(...)</code>","text":"<p>Shrinks the selection from the second corner on the Y axis by n</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def shrink_y2(self, n: int) -&gt; Area:\n    \"\"\"Shrinks the selection from the second corner on the Y axis by n\"\"\"\n    self.y2 = max(self._y1, self._y2 - n)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.size","title":"<code>def size(...)</code>","text":"<p>Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become <code>((3,3), (5,5))</code></p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def size(self, n: int) -&gt; Area:\n    \"\"\"\n    Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become\n    ``((3,3), (5,5))``\n    \"\"\"\n    center_x, center_y = self.get_center_int()\n    n -= 1  # Ignore center tile\n    self.x1 = center_x - math.ceil(n / 2)\n    self.y1 = center_y - math.ceil(n / 2)\n    self.x2 = center_x + math.floor(n / 2)\n    self.y2 = center_y + math.floor(n / 2)\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.to_chunks","title":"<code>def to_chunks(...)</code>","text":"<p>Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates. The separation between chunks is based on if they're connected to each other. So the tiles must share an edge (i.e. they should be non-diagonal).</p> <p>Parameters:</p> Name Type Description Default <code>as_terrain</code> <code>bool</code> <p>If the returning coordinates should be Tile objects or Terrain Tiles. If <code>True</code> the coordinates are returned as TerrainTiles.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[OrderedSet[Tile | 'TerrainTile']]</code> <p>A list of OrderedSets of Tiles ((x, y) named tuple) of the selection.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def to_chunks(\n        self,\n        as_terrain: bool = False\n) -&gt; List[OrderedSet[Tile | 'TerrainTile']]:\n    \"\"\"\n    Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates.\n    The separation between chunks is based on if they're connected to each other.\n    So the tiles must share an edge (i.e. they should be non-diagonal).\n\n    Args:\n        as_terrain: If the returning coordinates should be Tile objects or Terrain Tiles. If `True` the coordinates\n            are returned as TerrainTiles.\n\n    Returns:\n        A list of OrderedSets of Tiles ((x, y) named tuple) of the selection.\n    \"\"\"\n    tiles = self.to_coords()\n\n    # Shortcut for states that CANNOT be more than one chunk\n    if self.state in AreaState.unchunkables():\n        return [tiles]\n\n    chunks: Dict[int, List[Tile]] = {}\n    for tile in tiles:\n        chunk_id = self._get_chunk_id(tile)\n        chunks.setdefault(chunk_id, []).append(tile)\n\n    map_size = self._map_size\n    chunks_ordered: List[OrderedSet[Tile | 'TerrainTile']] = []\n    for chunk_id, chunk_tiles in chunks.items():\n        tiles = self._tiles_to_terrain_tiles(chunk_tiles) if as_terrain else chunk_tiles\n        chunks_ordered.append(\n            OrderedSet(sorted(tiles, key=lambda t: t.y * map_size + t.x))\n        )\n\n    return chunks_ordered\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.to_coords","title":"<code>def to_coords(...)</code>","text":"<p>Converts the selection to an OrderedSet of (x, y) coordinates</p> <p>Parameters:</p> Name Type Description Default <code>as_terrain</code> <code>bool</code> <p>If the returning coordinates should be Tile objects or Terrain Tiles. If <code>True</code> the coordinates are returned as TerrainTiles.</p> <code>False</code> <p>Returns:</p> Type Description <code>OrderedSet[Tile | 'TerrainTile']</code> <p>An OrderedSet of Tiles ((x, y) named tuple) of the selection.</p> <p>Examples:</p> <p>The selection: <code>((3,3), (5,5))</code> would result in an OrderedSet with a length of 9::</p> <pre><code>[\n    (3,3), (4,3)  ...,\n    ...,   ...,   ...,\n    ...,   (4,5), (5,5)\n]\n</code></pre> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def to_coords(self, as_terrain: bool = False) -&gt; OrderedSet[Tile | 'TerrainTile']:\n    \"\"\"\n    Converts the selection to an OrderedSet of (x, y) coordinates\n\n    Args:\n        as_terrain: If the returning coordinates should be Tile objects or Terrain Tiles. If `True` the coordinates\n            are returned as TerrainTiles.\n\n    Returns:\n        An OrderedSet of Tiles ((x, y) named tuple) of the selection.\n\n    Examples:\n        The selection: ``((3,3), (5,5))`` would result in an OrderedSet with a length of 9::\n\n            [\n                (3,3), (4,3)  ...,\n                ...,   ...,   ...,\n                ...,   (4,5), (5,5)\n            ]\n    \"\"\"\n    tiles = OrderedSet(\n        Tile(x, y) for y in self.get_range_y() for x in self.get_range_x() if self.is_within_selection(x, y)\n    )\n    return self._tiles_to_terrain_tiles(tiles) if as_terrain else tiles\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.to_dict","title":"<code>def to_dict(...)</code>","text":"<p>Converts the 2 corners of the selection to area keys for use in effects etc. This can be used by adding double stars (**) before this function.</p> Usage <p>The selection: <code>((3,3), (5,5))</code> would result in a dict that looks like:     <code>{'area_x1': 3, 'area_y1': 3, 'area_x2': 5, 'area_y2': 5}</code> Then do: <code>**area.to_dict()</code> in a function that accepts area tiles</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key)</p> <code>'area_'</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>A dict with area_x1, area_y1, area_x2, area_y2 as keys and their respective values.</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def to_dict(self, prefix: str = \"area_\") -&gt; Dict[str, int]:\n    \"\"\"\n    Converts the 2 corners of the selection to area keys for use in effects etc.\n    This can be used by adding double stars (**) before this function.\n\n    Usage:\n        The selection: ``((3,3), (5,5))`` would result in a dict that looks like:\n            ``{'area_x1': 3, 'area_y1': 3, 'area_x2': 5, 'area_y2': 5}``\n        Then do: ``**area.to_dict()`` in a function that accepts area tiles\n\n    Args:\n        prefix: The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key)\n\n    Returns:\n        A dict with area_x1, area_y1, area_x2, area_y2 as keys and their respective values.\n    \"\"\"\n    return {f\"{prefix}{key}\": getattr(self, key) for key in ['x1', 'y1', 'x2', 'y2']}\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.use_full","title":"<code>def use_full(...)</code>","text":"<p>Sets the area object to use the entire selection</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def use_full(self) -&gt; Area:\n    \"\"\"Sets the area object to use the entire selection\"\"\"\n    self.state = AreaState.FULL\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.use_only_corners","title":"<code>def use_only_corners(...)</code>","text":"<p>Sets the area object to only use the corners pattern within the selection.</p> <p>Parameters:</p> Name Type Description Default <code>corner_size</code> <code>int</code> <p>The size along both the x and y-axis of the corner areas</p> <code>None</code> <code>corner_size_x</code> <code>int</code> <p>The size along the x-axis of the corner areas</p> <code>None</code> <code>corner_size_y</code> <code>int</code> <p>The size along the y-axis of the corner areas</p> <code>None</code> <p>Returns:</p> Type Description <code>Area</code> <p>This area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def use_only_corners(self, corner_size: int = None, corner_size_x: int = None, corner_size_y: int = None) -&gt; Area:\n    \"\"\"\n    Sets the area object to only use the corners pattern within the selection.\n\n    Args:\n        corner_size: The size along both the x and y-axis of the corner areas\n        corner_size_x: The size along the x-axis of the corner areas\n        corner_size_y: The size along the y-axis of the corner areas\n\n    Returns:\n        This area object\n    \"\"\"\n    self.attrs(corner_size=corner_size, corner_size_x=corner_size_x, corner_size_y=corner_size_y)\n    self.state = AreaState.CORNERS\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.use_only_edge","title":"<code>def use_only_edge(...)</code>","text":"<p>Sets the area object to only use the edge of the selection</p> <p>Parameters:</p> Name Type Description Default <code>line_width</code> <code>int</code> <p>The width of the x &amp; y edge line</p> <code>None</code> <code>line_width_x</code> <code>int</code> <p>The width of the x edge line</p> <code>None</code> <code>line_width_y</code> <code>int</code> <p>The width of the y edge line</p> <code>None</code> <p>Returns:</p> Type Description <code>Area</code> <p>This area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def use_only_edge(self, line_width: int = None, line_width_x: int = None, line_width_y: int = None) -&gt; Area:\n    \"\"\"\n    Sets the area object to only use the edge of the selection\n\n    Args:\n        line_width: The width of the x &amp; y edge line\n        line_width_x: The width of the x edge line\n        line_width_y: The width of the y edge line\n\n    Returns:\n        This area object\n    \"\"\"\n    self.attrs(line_width=line_width, line_width_x=line_width_x, line_width_y=line_width_y)\n    self.state = AreaState.EDGE\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.use_pattern_grid","title":"<code>def use_pattern_grid(...)</code>","text":"<p>Sets the area object to use a grid pattern within the selection.</p> <p>Parameters:</p> Name Type Description Default <code>block_size</code> <code>int</code> <p>The size of the gaps between lines</p> <code>None</code> <code>gap_size</code> <code>int</code> <p>The width of the grid lines</p> <code>None</code> <code>block_size_x</code> <code>int</code> <p>The size of the x gaps between lines</p> <code>None</code> <code>block_size_y</code> <code>int</code> <p>The size of the y gaps between lines</p> <code>None</code> <code>gap_size_x</code> <code>int</code> <p>The width of the x grid lines</p> <code>None</code> <code>gap_size_y</code> <code>int</code> <p>The width of the y grid lines</p> <code>None</code> <p>Returns:</p> Type Description <code>Area</code> <p>This area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def use_pattern_grid(\n        self,\n        block_size: int = None,\n        gap_size: int = None,\n        block_size_x: int = None,\n        block_size_y: int = None,\n        gap_size_x: int = None,\n        gap_size_y: int = None\n) -&gt; Area:\n    \"\"\"\n    Sets the area object to use a grid pattern within the selection.\n\n    Args:\n        block_size: The size of the gaps between lines\n        gap_size: The width of the grid lines\n        block_size_x: The size of the x gaps between lines\n        block_size_y: The size of the y gaps between lines\n        gap_size_x: The width of the x grid lines\n        gap_size_y: The width of the y grid lines\n\n    Returns:\n        This area object\n    \"\"\"\n    self.attrs(block_size=block_size, gap_size=gap_size,\n               block_size_x=block_size_x, gap_size_x=gap_size_x,\n               block_size_y=block_size_y, gap_size_y=gap_size_y)\n    self.state = AreaState.GRID\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.use_pattern_lines","title":"<code>def use_pattern_lines(...)</code>","text":"<p>Sets the area object to use a lines pattern within the selection.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>The axis the lines should follow. Can either be \"x\" or \"y\"</p> <code>None</code> <code>gap_size</code> <code>int</code> <p>The size of the gaps between lines</p> <code>None</code> <code>line_width</code> <code>int</code> <p>The width of the x &amp; y lines</p> <code>None</code> <p>Returns:</p> Type Description <code>Area</code> <p>This area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def use_pattern_lines(self, axis: str = None, gap_size: int = None, line_width: int = None) -&gt; Area:\n    \"\"\"\n    Sets the area object to use a lines pattern within the selection.\n\n    Args:\n        axis: The axis the lines should follow. Can either be \"x\" or \"y\"\n        gap_size: The size of the gaps between lines\n        line_width: The width of the x &amp; y lines\n\n    Returns:\n        This area object\n    \"\"\"\n    if axis is not None:\n        axis = axis.lower()\n    self.attrs(axis=axis, gap_size=gap_size, line_width=line_width)\n    self.state = AreaState.LINES\n    return self\n</code></pre>"},{"location":"api_docs/support/area/#AoE2ScenarioParser.objects.support.area.Area.width","title":"<code>def width(...)</code>","text":"<p>Sets the width (x-axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>def width(self, n: int) -&gt; Area:\n    \"\"\"\n    Sets the width (x-axis) of the selection. Shrinks/Expands both sides equally.\n    If the expansion hits the edge of the map, it'll expand on the other side.\n    \"\"\"\n    c1, c2 = self._get_length_change(n, self.get_width(), self.x1, self.x2)\n\n    self.x1 = self._x1 + c1\n    self.x2 = self._x2 + c2\n    return self\n</code></pre>"},{"location":"api_docs/support/area_attr/","title":"AreaAttr","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to show the supported attributes that can be edited using <code>Area.attr(k, v)</code></p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>class AreaAttr(Enum):\n    \"\"\"Enum to show the supported attributes that can be edited using ``Area.attr(k, v)``\"\"\"\n    X1 = \"x1\"\n    Y1 = \"y1\"\n    X2 = \"x2\"\n    Y2 = \"y2\"\n    GAP_SIZE = \"gap_size\"\n    GAP_SIZE_X = \"gap_size_x\"\n    GAP_SIZE_Y = \"gap_size_y\"\n    LINE_WIDTH = \"line_width\"\n    LINE_WIDTH_X = \"line_width_x\"\n    LINE_WIDTH_Y = \"line_width_y\"\n    AXIS = \"axis\"\n    CORNER_SIZE = \"corner_size\"\n    CORNER_SIZE_X = \"corner_size_x\"\n    CORNER_SIZE_Y = \"corner_size_y\"\n    BLOCK_SIZE = \"block_size\"\n    BLOCK_SIZE_X = \"block_size_x\"\n    BLOCK_SIZE_Y = \"block_size_y\"\n</code></pre>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr-attributes","title":"Attributes","text":""},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.AXIS","title":"<code>AXIS = 'axis'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'axis'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.BLOCK_SIZE","title":"<code>BLOCK_SIZE = 'block_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'block_size'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.BLOCK_SIZE_X","title":"<code>BLOCK_SIZE_X = 'block_size_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'block_size_x'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.BLOCK_SIZE_Y","title":"<code>BLOCK_SIZE_Y = 'block_size_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'block_size_y'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.CORNER_SIZE","title":"<code>CORNER_SIZE = 'corner_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'corner_size'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.CORNER_SIZE_X","title":"<code>CORNER_SIZE_X = 'corner_size_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'corner_size_x'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.CORNER_SIZE_Y","title":"<code>CORNER_SIZE_Y = 'corner_size_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'corner_size_y'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.GAP_SIZE","title":"<code>GAP_SIZE = 'gap_size'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'gap_size'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.GAP_SIZE_X","title":"<code>GAP_SIZE_X = 'gap_size_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'gap_size_x'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.GAP_SIZE_Y","title":"<code>GAP_SIZE_Y = 'gap_size_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'gap_size_y'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.LINE_WIDTH","title":"<code>LINE_WIDTH = 'line_width'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'line_width'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.LINE_WIDTH_X","title":"<code>LINE_WIDTH_X = 'line_width_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'line_width_x'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.LINE_WIDTH_Y","title":"<code>LINE_WIDTH_Y = 'line_width_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'line_width_y'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.X1","title":"<code>X1 = 'x1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'x1'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.X2","title":"<code>X2 = 'x2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'x2'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.Y1","title":"<code>Y1 = 'y1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'y1'</code>"},{"location":"api_docs/support/area_attr/#AoE2ScenarioParser.objects.support.area.AreaAttr.Y2","title":"<code>Y2 = 'y2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'y2'</code>"},{"location":"api_docs/support/area_state/","title":"AreaState","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to show the state of the Area object</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>class AreaState(Enum):\n    \"\"\"Enum to show the state of the Area object\"\"\"\n    FULL = 0\n    EDGE = 1\n    GRID = 2\n    LINES = 3\n    CORNERS = 4\n\n    @staticmethod\n    def unchunkables() -&gt; List[AreaState]:\n        \"\"\"Returns the states that cannot be split into chunks\"\"\"\n        return [AreaState.FULL, AreaState.EDGE]\n</code></pre>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState-attributes","title":"Attributes","text":""},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.CORNERS","title":"<code>CORNERS = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>4</code>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.EDGE","title":"<code>EDGE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>1</code>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.FULL","title":"<code>FULL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>0</code>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.GRID","title":"<code>GRID = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>2</code>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.LINES","title":"<code>LINES = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>3</code>"},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState-functions","title":"Functions","text":""},{"location":"api_docs/support/area_state/#AoE2ScenarioParser.objects.support.area.AreaState.unchunkables","title":"<code>def unchunkables(...)</code>  <code>staticmethod</code>","text":"<p>Returns the states that cannot be split into chunks</p> Source code in <code>AoE2ScenarioParser/objects/support/area.py</code> <pre><code>@staticmethod\ndef unchunkables() -&gt; List[AreaState]:\n    \"\"\"Returns the states that cannot be split into chunks\"\"\"\n    return [AreaState.FULL, AreaState.EDGE]\n</code></pre>"},{"location":"api_docs/trigger/trigger/","title":"Trigger","text":""},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger-classes","title":"Classes","text":""},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger","title":"<code>Trigger</code>","text":"<p>               Bases: <code>AoE2Object</code>, <code>TriggerComponent</code></p> <p>Object for handling a trigger.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>class Trigger(AoE2Object, TriggerComponent):\n    \"\"\"Object for handling a trigger.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Triggers\", \"trigger_data[__index__]\", group=[\n            RetrieverObjectLink(\"name\", link=\"trigger_name\"),\n            RetrieverObjectLink(\"description\", link=\"trigger_description\"),\n            RetrieverObjectLink(\"description_stid\", link=\"description_string_table_id\"),\n            RetrieverObjectLink(\"display_as_objective\"),\n            RetrieverObjectLink(\"short_description\"),\n            RetrieverObjectLink(\"short_description_stid\", link=\"short_description_string_table_id\"),\n            RetrieverObjectLink(\"display_on_screen\"),\n            RetrieverObjectLink(\"description_order\", link=\"objective_description_order\"),\n            RetrieverObjectLink(\"enabled\"),\n            RetrieverObjectLink(\"looping\"),\n            RetrieverObjectLink(\"header\", link=\"make_header\"),\n            RetrieverObjectLink(\"mute_objectives\"),\n            RetrieverObjectLink(\"conditions\", link=\"condition_data\", process_as_object=Condition),\n            RetrieverObjectLink(\"condition_order\", link=\"condition_display_order_array\"),\n            RetrieverObjectLink(\"effects\", link=\"effect_data\", process_as_object=Effect),\n            RetrieverObjectLink(\"effect_order\", link=\"effect_display_order_array\"),\n        ]),\n        RetrieverObjectLink(\"trigger_id\", retrieve_history_number=0),\n    ]\n\n    def __init__(\n            self,\n            name: str,\n            description: str = \"\",\n            description_stid: int = -1,\n            display_as_objective: int = 0,\n            short_description: str = \"\",\n            short_description_stid: int = -1,\n            display_on_screen: int = 0,\n            description_order: int = 0,\n            enabled: int = 1,\n            looping: int = 0,\n            header: int = 0,\n            mute_objectives: int = 0,\n            conditions: List[Condition] = None,\n            condition_order: List[int] = None,\n            effects: List[Effect] = None,\n            effect_order: List[int] = None,\n            trigger_id: int = -1,\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        if conditions is None:\n            conditions = []\n        if condition_order is None:\n            condition_order = []\n        if effects is None:\n            effects = []\n        if effect_order is None:\n            effect_order = []\n\n        self.name: str = name\n        self.description: str = description\n        self.description_stid: int = description_stid\n        self.display_as_objective: int = display_as_objective\n        self.short_description: str = short_description\n        self.short_description_stid: int = short_description_stid\n        self.display_on_screen: int = display_on_screen\n        self.description_order: int = description_order\n        self.enabled: int = enabled\n        self.looping: int = looping\n        self.header: int = header\n        self.mute_objectives: int = mute_objectives\n        self._condition_hash = hash_list(conditions)\n        self.conditions: List[Condition] = conditions\n        self.condition_order: List[int] = condition_order\n        self._effect_hash = hash_list(effects)\n        self.effects: List[Effect] = effects\n        self.effect_order: List[int] = effect_order\n        self.trigger_id: int = trigger_id\n\n        self.new_effect: NewEffectSupport = NewEffectSupport(self)\n        self.new_condition: NewConditionSupport = NewConditionSupport(self)\n\n        self._assign_new_ce_support()\n\n    def _deepcopy_entry(self, k, v) -&gt; Any:\n        if k in ['new_effect', 'new_condition']:\n            return None\n        else:\n            return super()._deepcopy_entry(k, v)\n\n    def _assign_new_ce_support(self):\n        \"\"\"Assigns new `new_effect` and `new_condition` objects to this trigger\"\"\"\n        self.new_effect = NewEffectSupport(self)\n        self.new_condition = NewConditionSupport(self)\n\n    @property\n    def condition_order(self) -&gt; List[int]:\n        \"\"\"The condition display order \"\"\"\n        if list_changed(self.conditions, self._condition_hash):\n            update_order_array(self._condition_order, len(self.conditions))\n            self._condition_hash = hash_list(self.conditions)\n        return self._condition_order\n\n    @condition_order.setter\n    def condition_order(self, val):\n        self._condition_order = val\n\n    @property\n    def effect_order(self) -&gt; List[int]:\n        \"\"\"The effect display order \"\"\"\n        if list_changed(self.effects, self._effect_hash):\n            update_order_array(self._effect_order, len(self.effects))\n            self._effect_hash = hash_list(self.effects)\n        return self._effect_order\n\n    @effect_order.setter\n    def effect_order(self, val):\n        self._effect_order = val\n\n    @property\n    def conditions(self) -&gt; List[Condition]:\n        \"\"\"All conditions in this trigger\"\"\"\n        return self._conditions\n\n    @conditions.setter\n    def conditions(self, val: List[Condition]) -&gt; None:\n        self._conditions = UuidList(self._uuid, val)\n        self.condition_order = list(range(0, len(val)))\n\n    @property\n    def effects(self) -&gt; List[Effect]:\n        \"\"\"All effects in this trigger\"\"\"\n        return self._effects\n\n    @effects.setter\n    def effects(self, val: List[Effect]) -&gt; None:\n        self._effects = UuidList(self._uuid, val)\n        self.effect_order = list(range(0, len(val)))\n\n    def _add_effect(self, effect_type: EffectId, ai_script_goal=None, armour_attack_quantity=None,\n            armour_attack_class=None, quantity=None, tribute_list=None, diplomacy=None,\n            object_list_unit_id=None, source_player=None, target_player=None, technology=None, string_id=None,\n            display_time=None, trigger_id=None, location_x=None, location_y=None,\n            location_object_reference=None, area_x1=None, area_y1=None, area_x2=None, area_y2=None,\n            object_group=None, object_type=None, instruction_panel_position=None, attack_stance=None,\n            time_unit=None, enabled=None, food=None, wood=None, stone=None, gold=None, item_id=None,\n            flash_object=None, force_research_technology=None, visibility_state=None, scroll=None,\n            operation=None, object_list_unit_id_2=None, button_location=None, ai_signal_value=None,\n            object_attributes=None, variable=None, timer=None, facet=None, play_sound=None, message=None,\n            player_color=None, sound_name=None, selected_object_ids=None, color_mood=None, reset_timer=None,\n            object_state=None, action_type=None, ) -&gt; Effect:\n        \"\"\"Used to add new effect to trigger. Please use trigger.new_effect.&lt;effect_name&gt; instead\"\"\"\n\n        def get_default_effect_attributes(eff_type):\n            \"\"\"Gets the default effect attributes based on a certain effect type, with exception handling\"\"\"\n            sv = getters.get_scenario_version(self._uuid)\n            try:\n                return effect_dataset.default_attributes[eff_type]\n            except KeyError:\n                effect = EffectId(eff_type)\n                raise UnsupportedAttributeError(\n                    f\"The effect {effect.name} is not supported in scenario version {sv}\"\n                ) from None\n\n        effect_defaults = get_default_effect_attributes(effect_type)\n        effect_attr = {}\n        for key, value in effect_defaults.items():\n            effect_attr[key] = (locals()[key] if locals()[key] is not None else value)\n        new_effect = Effect(**effect_attr, uuid=self._uuid)\n        self.effects.append(new_effect)\n        return new_effect\n\n    def _add_condition(self, condition_type: ConditionId, quantity=None,\n            attribute=None, unit_object=None, next_object=None, object_list=None,\n            source_player=None, technology=None, timer=None, area_x1=None, area_y1=None, area_x2=None,\n            area_y2=None, object_group=None, object_type=None, ai_signal=None, inverted=None, variable=None,\n            comparison=None, target_player=None, unit_ai_action=None, xs_function=None, object_state=None,\n            timer_id=None, victory_timer_type=None, include_changeable_weapon_objects=None,\n    ) -&gt; Condition:\n        \"\"\"Used to add new condition to trigger. Please use trigger.new_condition.&lt;condition_name&gt; instead\"\"\"\n\n        def get_default_condition_attributes(cond_type):\n            \"\"\"Gets the default condition attributes based on a certain condition type, with exception handling\"\"\"\n            sv = getters.get_scenario_version(self._uuid)\n            try:\n                return condition_dataset.default_attributes[cond_type]\n            except KeyError:\n                condition = ConditionId(cond_type)\n                raise UnsupportedAttributeError(\n                    f\"The condition {condition.name} is not supported in scenario version {sv}\"\n                ) from None\n\n        condition_defaults = get_default_condition_attributes(condition_type)\n        condition_attr = {}\n        for key, value in condition_defaults.items():\n            condition_attr[key] = (locals()[key] if locals()[key] is not None else value)\n        new_condition = Condition(**condition_attr, uuid=self._uuid)\n        self.conditions.append(new_condition)\n        return new_condition\n\n    def get_effect(self, effect_index: int = None, display_index: int = None) -&gt; Effect:\n        \"\"\"\n        Retrieve an effect based on its (display) index\n\n        Args:\n            effect_index: The effect index of the effect to retrieve\n            display_index: The display index of the effect to retrieve\n\n        Raises:\n            ValueError: If more than one parameter is used simultaneously\n            IndexError: If the effect could not be found\n\n        Returns:\n            The wanted effect\n        \"\"\"\n        if not mutually_exclusive(effect_index is not None, display_index is not None):\n            raise ValueError(f\"Please identify an effect using either effect_index or display_index.\")\n\n        if effect_index is None:\n            effect_index = self.effect_order[display_index]\n\n        return self.effects[effect_index]\n\n    def get_condition(self, condition_index: int = None, display_index: int = None) -&gt; Condition:\n        \"\"\"\n        Retrieve a condition based on its (display) index\n\n        Args:\n            condition_index: The condition index of the condition to retrieve\n            display_index: The display index of the condition to retrieve\n\n        Raises:\n            ValueError: If more than one parameter is used simultaneously\n            IndexError: If the condition could not be found\n\n        Returns:\n            The wanted condition\n        \"\"\"\n        if not mutually_exclusive(condition_index is not None, display_index is not None):\n            raise ValueError(f\"Please identify a condition using either condition_index or display_index.\")\n\n        if condition_index is None:\n            condition_index = self.condition_order[display_index]\n\n        return self.conditions[condition_index]\n\n    def remove_effect(self, effect_index: int = None, display_index: int = None, effect: Effect = None) -&gt; None:\n        \"\"\"\n        Remove an effect from this trigger\n\n        Args:\n            effect_index: The effect index of the condition to remove\n            display_index: The display index of the condition to remove\n            effect: A reference to the effect object to remove from this trigger\n\n        Raises:\n            ValueError: If more than one parameter is used simultaneously\n        \"\"\"\n        if not mutually_exclusive(effect_index is not None, display_index is not None, effect is not None):\n            raise ValueError(f\"Please identify an effect using either effect_index, display_index or effect.\")\n\n        if effect is not None:\n            effect_index = self.effects.index(effect)\n        if effect_index is None:\n            effect_index = self.effect_order[display_index]\n\n        del self.effects[effect_index]\n\n    def remove_condition(self, condition_index: int = None, display_index: int = None, condition: Condition = None) \\\n            -&gt; None:\n        \"\"\"\n        Remove a condition from this trigger\n\n        Args:\n            condition_index: The condition index of the condition to remove\n            display_index: The display index of the condition to remove\n            condition: A reference to the condition object to remove from this trigger\n\n        Raises:\n            ValueError: If more than one parameter is used simultaneously\n        \"\"\"\n        if not mutually_exclusive(condition_index is not None, display_index is not None, condition is not None):\n            raise ValueError(f\"Please identify a condition using either condition_index, display_index or condition.\")\n\n        if condition is not None:\n            condition_index = self.conditions.index(condition)\n\n        if condition_index is None:\n            condition_index = self.condition_order[display_index]\n\n        del self.conditions[condition_index]\n\n    def get_content_as_string(self, include_trigger_definition: bool = False) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing all content of this trigger.\n        This includes all the content within the conditions and effects of this trigger.\n\n        This is also the function that is called when doing: `print(trigger)`\n\n        Args:\n            include_trigger_definition: If the trigger meta-data should be added by this function\n\n        Returns:\n            The created string\n        \"\"\"\n        return_string = \"\"\n\n        data_tba = {\n            'enabled': self.enabled != 0,\n            'looping': self.looping != 0\n        }\n\n        if self.description != \"\":\n            data_tba['description'] = f\"'{self.description}'\"\n        if self.description_stid != -1:\n            data_tba['description_stid'] = self.description_stid\n        if self.short_description != \"\":\n            data_tba['short_description'] = f\"'{self.short_description}'\"\n        if self.short_description_stid != -1:\n            data_tba['short_description_stid'] = self.short_description_stid\n        if self.display_as_objective != 0:\n            data_tba['display_as_objective'] = (self.display_as_objective != 0)\n        if self.display_on_screen != 0:\n            data_tba['display_on_screen'] = (self.display_on_screen != 0)\n        if self.description_order != 0:\n            data_tba['description_order'] = self.description_order\n        if self.header != 0:\n            data_tba['header'] = (self.header != 0)\n        if self.mute_objectives != 0:\n            data_tba['mute_objectives'] = (self.mute_objectives != 0)\n\n        for key, value in data_tba.items():\n            return_string += f\"{key}: {value}\\n\"\n\n        if len(self.condition_order) &gt; 0:\n            return_string += \"conditions:\\n\"\n            for c_display_order, condition_id in enumerate(self.condition_order):\n                condition = self.conditions[condition_id]\n\n                name = f\"Unknown ({condition.condition_type})\"\n                if condition.condition_type in condition_dataset.condition_names:\n                    name = condition_dataset.condition_names[condition.condition_type]\n\n                return_string += f\"\\t{name} [Index: {condition_id}, Display: {c_display_order}]:\\n\"\n                return_string += add_tabs(condition.get_content_as_string(), 2)\n\n        if len(self.effect_order) &gt; 0:\n            return_string += \"effects:\\n\"\n            for e_display_order, effect_id in enumerate(self.effect_order):\n                effect = self.effects[effect_id]\n\n                name = f\"Unknown ({effect.effect_type})\"\n                if effect.effect_type in effect_dataset.effect_names:\n                    name = effect_dataset.effect_names[effect.effect_type]\n\n                return_string += f\"\\t{name} [Index: {effect_id}, Display: {e_display_order}]:\\n\"\n                return_string += add_tabs(effect.get_content_as_string(), 2)\n\n        if include_trigger_definition:\n            return f\"\\\"{self.name}\\\" [Index: {self.trigger_id}]\\n\" + add_tabs(return_string, 1)\n        return return_string\n\n    def __str__(self) -&gt; str:\n        return f\"[Trigger] {self.get_content_as_string(include_trigger_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.condition_order","title":"<code>condition_order: List[int]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[int]</code> <p>The condition display order</p>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.conditions","title":"<code>conditions: List[Condition]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[Condition]</code> <p>All conditions in this trigger</p>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.description","title":"<code>description: str = description</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>description</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.description_order","title":"<code>description_order: int = description_order</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>description_order</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.description_stid","title":"<code>description_stid: int = description_stid</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>description_stid</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.display_as_objective","title":"<code>display_as_objective: int = display_as_objective</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>display_as_objective</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.display_on_screen","title":"<code>display_on_screen: int = display_on_screen</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>display_on_screen</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.effect_order","title":"<code>effect_order: List[int]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[int]</code> <p>The effect display order</p>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.effects","title":"<code>effects: List[Effect]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[Effect]</code> <p>All effects in this trigger</p>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.enabled","title":"<code>enabled: int = enabled</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>enabled</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.header","title":"<code>header: int = header</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>header</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.looping","title":"<code>looping: int = looping</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>looping</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.mute_objectives","title":"<code>mute_objectives: int = mute_objectives</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>mute_objectives</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.name","title":"<code>name: str = name</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>name</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.new_condition","title":"<code>new_condition: NewConditionSupport = NewConditionSupport(self)</code>  <code>instance-attribute</code>","text":"Type: <code>NewConditionSupport</code>                           Value: <code>NewConditionSupport(self)</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.new_effect","title":"<code>new_effect: NewEffectSupport = NewEffectSupport(self)</code>  <code>instance-attribute</code>","text":"Type: <code>NewEffectSupport</code>                           Value: <code>NewEffectSupport(self)</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.short_description","title":"<code>short_description: str = short_description</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>short_description</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.short_description_stid","title":"<code>short_description_stid: int = short_description_stid</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>short_description_stid</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.trigger_id","title":"<code>trigger_id: int = trigger_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>trigger_id</code>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code>  - required <code>description</code> <code>str</code>  - <code>''</code> <code>description_stid</code> <code>int</code>  - <code>-1</code> <code>display_as_objective</code> <code>int</code>  - <code>0</code> <code>short_description</code> <code>str</code>  - <code>''</code> <code>short_description_stid</code> <code>int</code>  - <code>-1</code> <code>display_on_screen</code> <code>int</code>  - <code>0</code> <code>description_order</code> <code>int</code>  - <code>0</code> <code>enabled</code> <code>int</code>  - <code>1</code> <code>looping</code> <code>int</code>  - <code>0</code> <code>header</code> <code>int</code>  - <code>0</code> <code>mute_objectives</code> <code>int</code>  - <code>0</code> <code>conditions</code> <code>List[Condition]</code>  - <code>None</code> <code>condition_order</code> <code>List[int]</code>  - <code>None</code> <code>effects</code> <code>List[Effect]</code>  - <code>None</code> <code>effect_order</code> <code>List[int]</code>  - <code>None</code> <code>trigger_id</code> <code>int</code>  - <code>-1</code> <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        description_stid: int = -1,\n        display_as_objective: int = 0,\n        short_description: str = \"\",\n        short_description_stid: int = -1,\n        display_on_screen: int = 0,\n        description_order: int = 0,\n        enabled: int = 1,\n        looping: int = 0,\n        header: int = 0,\n        mute_objectives: int = 0,\n        conditions: List[Condition] = None,\n        condition_order: List[int] = None,\n        effects: List[Effect] = None,\n        effect_order: List[int] = None,\n        trigger_id: int = -1,\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    if conditions is None:\n        conditions = []\n    if condition_order is None:\n        condition_order = []\n    if effects is None:\n        effects = []\n    if effect_order is None:\n        effect_order = []\n\n    self.name: str = name\n    self.description: str = description\n    self.description_stid: int = description_stid\n    self.display_as_objective: int = display_as_objective\n    self.short_description: str = short_description\n    self.short_description_stid: int = short_description_stid\n    self.display_on_screen: int = display_on_screen\n    self.description_order: int = description_order\n    self.enabled: int = enabled\n    self.looping: int = looping\n    self.header: int = header\n    self.mute_objectives: int = mute_objectives\n    self._condition_hash = hash_list(conditions)\n    self.conditions: List[Condition] = conditions\n    self.condition_order: List[int] = condition_order\n    self._effect_hash = hash_list(effects)\n    self.effects: List[Effect] = effects\n    self.effect_order: List[int] = effect_order\n    self.trigger_id: int = trigger_id\n\n    self.new_effect: NewEffectSupport = NewEffectSupport(self)\n    self.new_condition: NewConditionSupport = NewConditionSupport(self)\n\n    self._assign_new_ce_support()\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.__str__","title":"<code>def __str__(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"[Trigger] {self.get_content_as_string(include_trigger_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.get_condition","title":"<code>def get_condition(...)</code>","text":"<p>Retrieve a condition based on its (display) index</p> <p>Parameters:</p> Name Type Description Default <code>condition_index</code> <code>int</code> <p>The condition index of the condition to retrieve</p> <code>None</code> <code>display_index</code> <code>int</code> <p>The display index of the condition to retrieve</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one parameter is used simultaneously</p> <code>IndexError</code> <p>If the condition could not be found</p> <p>Returns:</p> Type Description <code>Condition</code> <p>The wanted condition</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def get_condition(self, condition_index: int = None, display_index: int = None) -&gt; Condition:\n    \"\"\"\n    Retrieve a condition based on its (display) index\n\n    Args:\n        condition_index: The condition index of the condition to retrieve\n        display_index: The display index of the condition to retrieve\n\n    Raises:\n        ValueError: If more than one parameter is used simultaneously\n        IndexError: If the condition could not be found\n\n    Returns:\n        The wanted condition\n    \"\"\"\n    if not mutually_exclusive(condition_index is not None, display_index is not None):\n        raise ValueError(f\"Please identify a condition using either condition_index or display_index.\")\n\n    if condition_index is None:\n        condition_index = self.condition_order[display_index]\n\n    return self.conditions[condition_index]\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.get_content_as_string","title":"<code>def get_content_as_string(...)</code>","text":"<p>Create a human-readable string showcasing all content of this trigger. This includes all the content within the conditions and effects of this trigger.</p> <p>This is also the function that is called when doing: <code>print(trigger)</code></p> <p>Parameters:</p> Name Type Description Default <code>include_trigger_definition</code> <code>bool</code> <p>If the trigger meta-data should be added by this function</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def get_content_as_string(self, include_trigger_definition: bool = False) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing all content of this trigger.\n    This includes all the content within the conditions and effects of this trigger.\n\n    This is also the function that is called when doing: `print(trigger)`\n\n    Args:\n        include_trigger_definition: If the trigger meta-data should be added by this function\n\n    Returns:\n        The created string\n    \"\"\"\n    return_string = \"\"\n\n    data_tba = {\n        'enabled': self.enabled != 0,\n        'looping': self.looping != 0\n    }\n\n    if self.description != \"\":\n        data_tba['description'] = f\"'{self.description}'\"\n    if self.description_stid != -1:\n        data_tba['description_stid'] = self.description_stid\n    if self.short_description != \"\":\n        data_tba['short_description'] = f\"'{self.short_description}'\"\n    if self.short_description_stid != -1:\n        data_tba['short_description_stid'] = self.short_description_stid\n    if self.display_as_objective != 0:\n        data_tba['display_as_objective'] = (self.display_as_objective != 0)\n    if self.display_on_screen != 0:\n        data_tba['display_on_screen'] = (self.display_on_screen != 0)\n    if self.description_order != 0:\n        data_tba['description_order'] = self.description_order\n    if self.header != 0:\n        data_tba['header'] = (self.header != 0)\n    if self.mute_objectives != 0:\n        data_tba['mute_objectives'] = (self.mute_objectives != 0)\n\n    for key, value in data_tba.items():\n        return_string += f\"{key}: {value}\\n\"\n\n    if len(self.condition_order) &gt; 0:\n        return_string += \"conditions:\\n\"\n        for c_display_order, condition_id in enumerate(self.condition_order):\n            condition = self.conditions[condition_id]\n\n            name = f\"Unknown ({condition.condition_type})\"\n            if condition.condition_type in condition_dataset.condition_names:\n                name = condition_dataset.condition_names[condition.condition_type]\n\n            return_string += f\"\\t{name} [Index: {condition_id}, Display: {c_display_order}]:\\n\"\n            return_string += add_tabs(condition.get_content_as_string(), 2)\n\n    if len(self.effect_order) &gt; 0:\n        return_string += \"effects:\\n\"\n        for e_display_order, effect_id in enumerate(self.effect_order):\n            effect = self.effects[effect_id]\n\n            name = f\"Unknown ({effect.effect_type})\"\n            if effect.effect_type in effect_dataset.effect_names:\n                name = effect_dataset.effect_names[effect.effect_type]\n\n            return_string += f\"\\t{name} [Index: {effect_id}, Display: {e_display_order}]:\\n\"\n            return_string += add_tabs(effect.get_content_as_string(), 2)\n\n    if include_trigger_definition:\n        return f\"\\\"{self.name}\\\" [Index: {self.trigger_id}]\\n\" + add_tabs(return_string, 1)\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.get_effect","title":"<code>def get_effect(...)</code>","text":"<p>Retrieve an effect based on its (display) index</p> <p>Parameters:</p> Name Type Description Default <code>effect_index</code> <code>int</code> <p>The effect index of the effect to retrieve</p> <code>None</code> <code>display_index</code> <code>int</code> <p>The display index of the effect to retrieve</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one parameter is used simultaneously</p> <code>IndexError</code> <p>If the effect could not be found</p> <p>Returns:</p> Type Description <code>Effect</code> <p>The wanted effect</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def get_effect(self, effect_index: int = None, display_index: int = None) -&gt; Effect:\n    \"\"\"\n    Retrieve an effect based on its (display) index\n\n    Args:\n        effect_index: The effect index of the effect to retrieve\n        display_index: The display index of the effect to retrieve\n\n    Raises:\n        ValueError: If more than one parameter is used simultaneously\n        IndexError: If the effect could not be found\n\n    Returns:\n        The wanted effect\n    \"\"\"\n    if not mutually_exclusive(effect_index is not None, display_index is not None):\n        raise ValueError(f\"Please identify an effect using either effect_index or display_index.\")\n\n    if effect_index is None:\n        effect_index = self.effect_order[display_index]\n\n    return self.effects[effect_index]\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.remove_condition","title":"<code>def remove_condition(...)</code>","text":"<p>Remove a condition from this trigger</p> <p>Parameters:</p> Name Type Description Default <code>condition_index</code> <code>int</code> <p>The condition index of the condition to remove</p> <code>None</code> <code>display_index</code> <code>int</code> <p>The display index of the condition to remove</p> <code>None</code> <code>condition</code> <code>Condition</code> <p>A reference to the condition object to remove from this trigger</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one parameter is used simultaneously</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def remove_condition(self, condition_index: int = None, display_index: int = None, condition: Condition = None) \\\n        -&gt; None:\n    \"\"\"\n    Remove a condition from this trigger\n\n    Args:\n        condition_index: The condition index of the condition to remove\n        display_index: The display index of the condition to remove\n        condition: A reference to the condition object to remove from this trigger\n\n    Raises:\n        ValueError: If more than one parameter is used simultaneously\n    \"\"\"\n    if not mutually_exclusive(condition_index is not None, display_index is not None, condition is not None):\n        raise ValueError(f\"Please identify a condition using either condition_index, display_index or condition.\")\n\n    if condition is not None:\n        condition_index = self.conditions.index(condition)\n\n    if condition_index is None:\n        condition_index = self.condition_order[display_index]\n\n    del self.conditions[condition_index]\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger.Trigger.remove_effect","title":"<code>def remove_effect(...)</code>","text":"<p>Remove an effect from this trigger</p> <p>Parameters:</p> Name Type Description Default <code>effect_index</code> <code>int</code> <p>The effect index of the condition to remove</p> <code>None</code> <code>display_index</code> <code>int</code> <p>The display index of the condition to remove</p> <code>None</code> <code>effect</code> <code>Effect</code> <p>A reference to the effect object to remove from this trigger</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one parameter is used simultaneously</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/trigger.py</code> <pre><code>def remove_effect(self, effect_index: int = None, display_index: int = None, effect: Effect = None) -&gt; None:\n    \"\"\"\n    Remove an effect from this trigger\n\n    Args:\n        effect_index: The effect index of the condition to remove\n        display_index: The display index of the condition to remove\n        effect: A reference to the effect object to remove from this trigger\n\n    Raises:\n        ValueError: If more than one parameter is used simultaneously\n    \"\"\"\n    if not mutually_exclusive(effect_index is not None, display_index is not None, effect is not None):\n        raise ValueError(f\"Please identify an effect using either effect_index, display_index or effect.\")\n\n    if effect is not None:\n        effect_index = self.effects.index(effect)\n    if effect_index is None:\n        effect_index = self.effect_order[display_index]\n\n    del self.effects[effect_index]\n</code></pre>"},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger/#AoE2ScenarioParser.objects.data_objects.trigger-modules","title":"Modules","text":""},{"location":"api_docs/trigger/trigger_ce_lock/","title":"TriggerCeLock","text":""},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock-classes","title":"Classes","text":""},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock","title":"<code>TriggerCELock</code>","text":"<p>Object used to identify which conditions and effects should be locked from change</p> Source code in <code>AoE2ScenarioParser/objects/support/trigger_ce_lock.py</code> <pre><code>class TriggerCELock:\n    \"\"\"Object used to identify which conditions and effects should be locked from change\"\"\"\n    def __init__(\n            self,\n            lock_conditions: bool = False,\n            lock_effects: bool = False,\n            lock_condition_type: List[int] | None = None,\n            lock_effect_type: List[int] | None = None,\n            lock_condition_ids: List[int] | None = None,\n            lock_effect_ids: List[int] | None = None\n    ):\n        \"\"\"\n        Args:\n            lock_conditions: Lock all conditions\n            lock_effects: Lock all effects\n            lock_condition_type: Lock certain condition types. Example: `ConditionId.OWN_OBJECTS`\n            lock_effect_type: Lock certain effect types. Example: `EffectId.CREATE_OBJECT`\n            lock_condition_ids: Lock certain conditions by their id\n            lock_effect_ids: Lock certain effects by their id\n        \"\"\"\n        if lock_condition_type is None:\n            lock_condition_type = []\n        if lock_effect_type is None:\n            lock_effect_type = []\n        if lock_condition_ids is None:\n            lock_condition_ids = []\n        if lock_effect_ids is None:\n            lock_effect_ids = []\n\n        self.lock_conditions = lock_conditions\n        self.lock_effects = lock_effects\n        self.lock_condition_type = lock_condition_type\n        self.lock_effect_type = lock_effect_type\n        self.lock_condition_ids = lock_condition_ids\n        self.lock_effect_ids = lock_effect_ids\n</code></pre>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_condition_ids","title":"<code>lock_condition_ids = lock_condition_ids</code>  <code>instance-attribute</code>","text":"Value: <code>lock_condition_ids</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_condition_type","title":"<code>lock_condition_type = lock_condition_type</code>  <code>instance-attribute</code>","text":"Value: <code>lock_condition_type</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_conditions","title":"<code>lock_conditions = lock_conditions</code>  <code>instance-attribute</code>","text":"Value: <code>lock_conditions</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_effect_ids","title":"<code>lock_effect_ids = lock_effect_ids</code>  <code>instance-attribute</code>","text":"Value: <code>lock_effect_ids</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_effect_type","title":"<code>lock_effect_type = lock_effect_type</code>  <code>instance-attribute</code>","text":"Value: <code>lock_effect_type</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.lock_effects","title":"<code>lock_effects = lock_effects</code>  <code>instance-attribute</code>","text":"Value: <code>lock_effects</code>"},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_ce_lock/#AoE2ScenarioParser.objects.support.trigger_ce_lock.TriggerCELock.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lock_conditions</code> <code>bool</code> <p>Lock all conditions</p> <code>False</code> <code>lock_effects</code> <code>bool</code> <p>Lock all effects</p> <code>False</code> <code>lock_condition_type</code> <code>List[int] | None</code> <p>Lock certain condition types. Example: <code>ConditionId.OWN_OBJECTS</code></p> <code>None</code> <code>lock_effect_type</code> <code>List[int] | None</code> <p>Lock certain effect types. Example: <code>EffectId.CREATE_OBJECT</code></p> <code>None</code> <code>lock_condition_ids</code> <code>List[int] | None</code> <p>Lock certain conditions by their id</p> <code>None</code> <code>lock_effect_ids</code> <code>List[int] | None</code> <p>Lock certain effects by their id</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/trigger_ce_lock.py</code> <pre><code>def __init__(\n        self,\n        lock_conditions: bool = False,\n        lock_effects: bool = False,\n        lock_condition_type: List[int] | None = None,\n        lock_effect_type: List[int] | None = None,\n        lock_condition_ids: List[int] | None = None,\n        lock_effect_ids: List[int] | None = None\n):\n    \"\"\"\n    Args:\n        lock_conditions: Lock all conditions\n        lock_effects: Lock all effects\n        lock_condition_type: Lock certain condition types. Example: `ConditionId.OWN_OBJECTS`\n        lock_effect_type: Lock certain effect types. Example: `EffectId.CREATE_OBJECT`\n        lock_condition_ids: Lock certain conditions by their id\n        lock_effect_ids: Lock certain effects by their id\n    \"\"\"\n    if lock_condition_type is None:\n        lock_condition_type = []\n    if lock_effect_type is None:\n        lock_effect_type = []\n    if lock_condition_ids is None:\n        lock_condition_ids = []\n    if lock_effect_ids is None:\n        lock_effect_ids = []\n\n    self.lock_conditions = lock_conditions\n    self.lock_effects = lock_effects\n    self.lock_condition_type = lock_condition_type\n    self.lock_effect_type = lock_effect_type\n    self.lock_condition_ids = lock_condition_ids\n    self.lock_effect_ids = lock_effect_ids\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/","title":"TriggerManager","text":""},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager-classes","title":"Classes","text":""},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager","title":"<code>TriggerManager</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of everything trigger related. This class does not include the logic for DE specific features (e.g. <code>Variable</code> objects). For those see: <code>TriggerManagerDE</code></p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>class TriggerManager(AoE2Object):\n    \"\"\"\n    Manager of everything trigger related.\n    This class does not include the logic for DE specific features (e.g. `Variable` objects).\n    For those see: `TriggerManagerDE`\n    \"\"\"\n\n    _link_list = [\n        RetrieverObjectLink(\"triggers\", \"Triggers\", \"trigger_data\", process_as_object=Trigger),\n        RetrieverObjectLink(\"trigger_display_order\", \"Triggers\", \"trigger_display_order_array\"),\n    ]\n\n    def __init__(\n            self,\n            triggers: List[Trigger],\n            trigger_display_order: List[int],\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        self.triggers: List[Trigger] = triggers\n        self.trigger_display_order: List[int] = trigger_display_order\n        self._trigger_hash = hash_list(triggers)\n\n    @property\n    def triggers(self) -&gt; UuidList[Trigger]:\n        \"\"\"All triggers\"\"\"\n        return self._triggers\n\n    @triggers.setter\n    def triggers(self, value: List[Trigger]) -&gt; None:\n        value = UuidList(self._uuid, value, on_update_execute_entry=self._update_triggers_uuid)\n\n        self._trigger_hash = hash_list(value)\n        self._triggers = value\n        self.trigger_display_order = list(range(len(value)))\n\n    def _update_triggers_uuid(self, trigger):\n        \"\"\"Function to update inner UUIDs \"\"\"\n        for effect in trigger.effects:\n            effect._uuid = self._uuid\n        for condition in trigger.conditions:\n            condition._uuid = self._uuid\n\n    @property\n    def trigger_display_order(self) -&gt; List[int]:\n        \"\"\"The display order. This is a list of trigger IDs in the display order. NOT execution order!\"\"\"\n        if list_changed(self.triggers, self._trigger_hash):\n            update_order_array(self._trigger_display_order, len(self.triggers))\n            self._trigger_hash = hash_list(self.triggers)\n        return self._trigger_display_order\n\n    @trigger_display_order.setter\n    def trigger_display_order(self, val):\n        self._trigger_display_order = val\n\n    def copy_trigger_per_player(\n            self,\n            from_player: IntEnum,\n            trigger_select: int | TriggerSelect,\n            change_from_player_only: bool = False,\n            include_player_source: bool = True,\n            include_player_target: bool = False,\n            trigger_ce_lock: TriggerCELock | None = None,\n            include_gaia: bool = False,\n            create_copy_for_players: List[IntEnum] = None\n    ) -&gt; Dict[PlayerId, Trigger]:\n        \"\"\"\n        Copies a trigger for all or a selection of players. Every copy will change desired player attributes with it.\n\n        Args:\n            from_player: The central player this trigger is created for. This is the player that will not get\n                a copy.\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n            change_from_player_only: If set to `True`,  only change player attributes in effects and conditions that\n                are equal to the player defined using the `from_player` parameter.\n            include_player_source: If set to `True`,  allow player source attributes to be changed while copying.\n                Player source attributes are attributes where a player is defined to perform an action such as create an\n                object. If set to `False` these attributes will remain unchanged.\n            include_player_target: If set to `True`,  allow player target attributes to be changed while copying.\n                Player target attributes are attributes where a player is defined as the target such as change ownership\n                or sending resources. If set to `False` these attributes will remain unchanged.\n            trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n                effects from being changed while copying.\n            include_gaia: If `True`,  GAIA is included in the copied list. (Also when `create_copy_for_players` is\n                defined)\n            create_copy_for_players: A list of Players to create a copy for. The `from_player` will be\n                excluded from this list.\n\n        Returns:\n            A dict with all the new created triggers. The key is the player for which the trigger is\n                created using the IntEnum associated with it. Example:\n                `{PlayerId.TWO: Trigger, PlayerId.FIVE: Trigger}`\n\n        Raises:\n            ValueError: if more than one trigger selection is used. Any of (trigger_index, display_index or trigger)\n                Or if Both `include_player_source` and `include_player_target` are `False`\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n        if create_copy_for_players is None:\n            create_copy_for_players = [\n                PlayerId.ONE, PlayerId.TWO, PlayerId.THREE, PlayerId.FOUR,\n                PlayerId.FIVE, PlayerId.SIX, PlayerId.SEVEN, PlayerId.EIGHT\n            ]\n        if include_gaia and PlayerId.GAIA not in create_copy_for_players:\n            create_copy_for_players.append(PlayerId.GAIA)\n\n        alter_conditions, alter_effects = TriggerManager._find_alterable_ce(trigger, trigger_ce_lock)\n\n        return_dict: Dict[PlayerId, Trigger] = {}\n        for player in create_copy_for_players:\n            if player == from_player:\n                continue\n\n            new_trigger = self.copy_trigger(TriggerSelect.trigger(trigger), append_after_source=False, add_suffix=False)\n            new_trigger.name += \" (GAIA)\" if player == PlayerId.GAIA else f\" (p{player})\"\n            return_dict[player] = new_trigger\n\n            for cond_x in alter_conditions:\n                cond = new_trigger.conditions[cond_x]\n                if cond.source_player == -1:\n                    continue\n\n                if include_player_source:\n                    if not change_from_player_only or (change_from_player_only and cond.source_player == from_player):\n                        cond.source_player = PlayerId(player)\n                if include_player_target:\n                    if not change_from_player_only or (change_from_player_only and cond.target_player == from_player):\n                        cond.target_player = PlayerId(player)\n\n            for effect_x in alter_effects:\n                effect = new_trigger.effects[effect_x]\n                if effect.source_player == -1:\n                    continue\n\n                if include_player_source:\n                    if not change_from_player_only or (change_from_player_only and effect.source_player == from_player):\n                        effect.source_player = PlayerId(player)\n                if include_player_target:\n                    if not change_from_player_only or (change_from_player_only and effect.target_player == from_player):\n                        effect.target_player = PlayerId(player)\n\n        # After copies have been made\n        trigger.name += f\" (p{from_player})\"\n\n        return return_dict\n\n    def copy_trigger(\n            self,\n            trigger_select: int | TriggerSelect,\n            append_after_source: bool = True,\n            add_suffix: bool = True\n    ) -&gt; Trigger:\n        \"\"\"\n        Creates an exact copy (deepcopy) of this trigger.\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n            append_after_source: If the new trigger should be appended below the source trigger\n            add_suffix: If the text ' (copy)' should be added after the trigger\n\n        Returns:\n            The newly copied trigger\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n        deepcopy_trigger = copy.deepcopy(trigger)\n        deepcopy_trigger.trigger_id = len(self.triggers)\n        if add_suffix:\n            deepcopy_trigger.name += \" (copy)\"\n\n        self.triggers.append(deepcopy_trigger)\n\n        if append_after_source:\n            self.move_triggers([trigger_index, deepcopy_trigger.trigger_id], trigger_index)\n\n        return deepcopy_trigger\n\n    def copy_trigger_tree_per_player(\n            self,\n            from_player: IntEnum,\n            trigger_select: int | TriggerSelect,\n            change_from_player_only: bool = False,\n            include_player_source: bool = True,\n            include_player_target: bool = False,\n            trigger_ce_lock: TriggerCELock | None = None,\n            include_gaia: bool = False,\n            create_copy_for_players: List[IntEnum] | None = None,\n            group_triggers_by: GroupBy | None = None\n    ) -&gt; Dict[IntEnum, List[Trigger]]:\n        \"\"\"\n        Copies an entire trigger tree for all or a selection of players. Every copy will change desired player\n        attributes with it. Trigger trees are triggers linked together using `(de)activate_trigger` effects.\n\n        Args:\n            from_player: The central player this trigger is created for. This is the player that will not get\n                a copy.\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n            change_from_player_only: If set to `True`,  only change player attributes in effects and conditions that\n                are equal to the player defined using the `from_player` parameter.\n            include_player_source: If set to `True`,  allow player source attributes to be changed while copying.\n                Player source attributes are attributes where a player is defined to perform an action such as create an\n                object. If set to `False` these attributes will remain unchanged.\n            include_player_target: If set to `True`,  allow player target attributes to be changed while copying.\n                Player target attributes are attributes where a player is defined as the target such as change ownership\n                or sending resources. If set to `False` these attributes will remain unchanged.\n            trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n                effects from being changed while copying.\n            include_gaia: If `True`,  GAIA is included in the copied list. (Also when `create_copy_for_players` is\n                defined)\n            create_copy_for_players: A list of Players to create a copy for. The `from_player` will be\n                excluded from this list.\n            group_triggers_by: How to group the newly added triggers.\n\n        Returns:\n            The newly created triggers in a dict using the Player as key and as value with a list of triggers\n        \"\"\"\n        if group_triggers_by is None:\n            group_triggers_by = GroupBy.NONE\n\n        trigger_index, display_index, source_trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n        known_node_indexes = [trigger_index]\n        self._find_trigger_tree_nodes_recursively(source_trigger, known_node_indexes)\n\n        new_triggers: Dict[IntEnum, List[Trigger]] = {}\n        trigger_index_swap = {}\n\n        # Set values for from_player\n        new_triggers[from_player] = [self.triggers[i] for i in known_node_indexes]\n        for index in known_node_indexes:\n            trigger: Trigger = self.triggers[index]\n            trigger_index_swap.setdefault(index, {})[from_player] = trigger.trigger_id\n\n        # Copy for all other players\n        for index in known_node_indexes:\n            triggers = self.copy_trigger_per_player(\n                from_player,\n                index,\n                change_from_player_only,\n                include_player_source,\n                include_player_target,\n                trigger_ce_lock,\n                include_gaia,\n                create_copy_for_players,\n            )\n            for player, trigger in triggers.items():\n                trigger_index_swap.setdefault(index, {})[player] = trigger.trigger_id\n                new_triggers.setdefault(player, []).append(trigger)\n\n        # Set trigger_id's in activation effects to the new player copied trigger ID\n        for player, triggers in new_triggers.items():\n            for trigger in triggers:\n                for effect in get_activation_effects(trigger):\n                    effect.trigger_id = trigger_index_swap[effect.trigger_id][player]\n\n        # -------------- Group by logic -------------- #\n        new_trigger_ids = []\n        if group_triggers_by == GroupBy.TRIGGER:\n            for i in range(len(known_node_indexes)):\n                for player in PlayerId.all():\n                    if player == from_player:\n                        new_trigger_ids.append(known_node_indexes[i])\n                        continue\n                    if player not in new_triggers:\n                        continue\n                    new_trigger_ids.append(new_triggers[player][i].trigger_id)\n        elif group_triggers_by == GroupBy.PLAYER:\n            for player in PlayerId.all():\n                if player == from_player:\n                    new_trigger_ids.extend(known_node_indexes)\n                    continue\n                if player not in new_triggers:\n                    continue\n\n                new_trigger_ids.extend([trigger.trigger_id for trigger in new_triggers[player]])\n\n        if group_triggers_by != GroupBy.NONE:\n            self.move_triggers(new_trigger_ids, display_index)\n\n        return new_triggers\n\n    def move_triggers(self, trigger_ids: List[int], insert_index: int) -&gt; None:\n        \"\"\"\n        Moves the given IDs from anywhere to the split index. This function reorders triggers BUT keeps\n        ``(de)activate trigger`` effects linked properly!\n\n        As an example:\n\n        ```\n        [0,1,2,3,4,5,6,7,8]  # Current index order\n        # Let's move trigger 1, 4, 5 and 6 to location 2\n        self.move_triggers([1, 4, 5, 6], 2)  # &lt;&lt; 2 is an INDEX, not the value\n        [0,1,4,5,6,2,3,7,8]  # New index order\n        ```\n\n        Args:\n            trigger_ids: The trigger IDs to move\n            insert_index: The index that defines where to insert the triggers\n        \"\"\"\n        if min(trigger_ids) &lt; 0:\n            raise ValueError(f\"Trigger IDs cannot be negative\")\n\n        if insert_index &gt;= len(self.trigger_display_order):\n            # Add to the end of the list\n            new_trigger_id_order = [n for n in self.trigger_display_order if n not in trigger_ids]\n            new_trigger_id_order += trigger_ids\n        else:\n            insert_num = self.trigger_display_order[insert_index]\n            new_trigger_id_order = [n for n in self.trigger_display_order if n not in trigger_ids or n == insert_num]\n\n            split_index = new_trigger_id_order.index(insert_num)\n\n            if insert_num in trigger_ids:\n                new_trigger_id_order.remove(insert_num)\n\n            new_trigger_id_order = new_trigger_id_order[:split_index] + trigger_ids + new_trigger_id_order[split_index:]\n        self.reorder_triggers(new_trigger_id_order)\n\n    def reorder_triggers(self, new_id_order: List[int] = None, ) -&gt; None:\n        \"\"\"\n        Reorder all triggers to a given order of IDs. This function reorders triggers BUT keeps ``(de)activate trigger``\n        effects linked properly!\n\n        Examples:\n\n            Moving the 6th trigger to the end of the trigger list::\n\n                [0,1,2,3,4,5,6,7,8]  # Trigger IDs before\n                self.reorder_triggers([0,1,2,3,5,4,7,8,6])\n                [0,1,2,3,5,4,7,8,6]  # Trigger IDs after\n\n            Setting the trigger (execution) order to the current display order::\n\n                self.reorder_triggers(self.trigger_display_order)\n\n        Keep in mind that all trigger IDs will get remapped with this function. So ``trigger_manager.triggers[4]`` might\n        result in a different trigger after this function is called in comparison to before.\n\n        Args:\n            new_id_order: The new trigger order. Uses the current display order when left unused\n        \"\"\"\n        if new_id_order is not None:\n            if min(new_id_order) &lt; 0:\n                raise ValueError(f\"Trigger IDs cannot be negative\")\n            self.trigger_display_order = new_id_order\n\n        new_triggers_list = []\n        index_changes = {}\n        for new_index, index in enumerate(self.trigger_display_order):\n            try:\n                trigger = self.triggers[index]\n            except IndexError:\n                raise ValueError(f\"The trigger ID {index} doesn't exist\") from None\n            index_changes[trigger.trigger_id] = new_index\n\n            trigger.trigger_id = new_index\n            new_triggers_list.append(trigger)\n        self.triggers = new_triggers_list\n\n        # Find and update all (de)activation effect trigger references\n        for trigger in self.triggers:\n            for effect in get_activation_effects(trigger):\n                if effect.trigger_id in index_changes:\n                    effect.trigger_id = index_changes[effect.trigger_id]\n\n    def copy_trigger_tree(self, trigger_select: int | TriggerSelect) -&gt; List[Trigger]:\n        \"\"\"\n        Copies an entire trigger tree. Trigger trees are triggers linked together using `(de)activate_trigger` effects.\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select\n\n        Returns:\n            The newly created triggers in a list\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n        known_node_indexes = [trigger_index]\n        self._find_trigger_tree_nodes_recursively(trigger, known_node_indexes)\n\n        new_triggers = []\n        id_swap = {}\n        for index in known_node_indexes:\n            trigger = self.copy_trigger(index, append_after_source=False)\n            new_triggers.append(trigger)\n            id_swap[index] = trigger.trigger_id\n\n        for trigger in new_triggers:\n            for effect in get_activation_effects(trigger):\n                effect.trigger_id = id_swap[effect.trigger_id]\n\n        return new_triggers\n\n    def replace_player(\n            self,\n            trigger_select: int | TriggerSelect,\n            to_player: PlayerId,\n            only_change_from: PlayerId = None,\n            include_player_source: bool = True,\n            include_player_target: bool = False,\n            trigger_ce_lock: TriggerCELock = None\n    ) -&gt; Trigger:\n        \"\"\"\n        Replaces player attributes. Specifically useful if multiple players are used in the same trigger.\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n            to_player: The player the attributes are changed to.\n            only_change_from: Can only change player attributes if the player is equal to the given value\n            include_player_source: If set to `True`,  allow player source attributes to be changed while replacing.\n                Player source attributes are attributes where a player is defined to perform an action such as create an\n                object. If set to `False` these attributes will remain unchanged.\n            include_player_target: If set to `True`,  allow player target attributes to be changed while replacing.\n                Player target attributes are attributes where a player is defined as the target such as change ownership\n                or sending resources. If set to `False` these attributes will remain unchanged.\n            trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n                effects from being changed.\n\n        Returns:\n            The given trigger with the proper player attributes changed\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n        alter_conditions, alter_effects = TriggerManager._find_alterable_ce(trigger, trigger_ce_lock)\n\n        for cond_x in alter_conditions:\n            cond = trigger.conditions[cond_x]\n            if value_is_valid(cond.source_player) and include_player_source:\n                if only_change_from is not None and only_change_from != cond.source_player:\n                    continue\n                cond.source_player = PlayerId(to_player)\n            if value_is_valid(cond.target_player) and include_player_target:\n                if only_change_from is not None and only_change_from != cond.target_player:\n                    continue\n                cond.target_player = PlayerId(to_player)\n        for effect_x in alter_effects:\n            effect = trigger.effects[effect_x]\n            if value_is_valid(effect.source_player) and include_player_source:\n                if only_change_from is not None and only_change_from != effect.source_player:\n                    continue\n                effect.source_player = PlayerId(to_player)\n            if value_is_valid(effect.target_player) and include_player_target:\n                if only_change_from is not None and only_change_from != effect.target_player:\n                    continue\n                effect.target_player = PlayerId(to_player)\n\n        return trigger\n\n    def add_trigger(\n            self,\n            name: str,\n            description: str | None = None,\n            description_stid: int | None = None,\n            display_as_objective: bool | None = None,\n            short_description: str | None = None,\n            short_description_stid: int | None = None,\n            display_on_screen: bool | None = None,\n            description_order: int | None = None,\n            enabled: bool | None = None,\n            looping: bool | None = None,\n            header: bool | None = None,\n            mute_objectives: bool | None = None,\n            conditions: List | None = None,\n            effects: List | None = None\n    ) -&gt; Trigger:\n        \"\"\"\n        Adds a new trigger to the scenario. Everything that is left empty will be set to in-game editor defaults.\n\n        Args:\n            name: The name for the trigger\n            description: The trigger description\n            description_stid: The trigger description string table ID\n            display_as_objective: Display the trigger as objective\n            short_description: The short trigger description\n            short_description_stid: The short trigger description string table ID\n            display_on_screen: Display the trigger objective on screen\n            description_order: ?\n            enabled: If the trigger is enabled from the start.\n            looping: If the trigger loops.\n            header: Turn objective into header\n            mute_objectives: Mute objectives\n            conditions: A list of condition managers\n            effects: A list of effect managers\n\n        Returns:\n            The newly created trigger\n        \"\"\"\n        keys = [\n            'description', 'description_stid', 'display_as_objective', 'short_description',\n            'short_description_stid', 'display_on_screen', 'description_order', 'enabled', 'looping', 'header',\n            'mute_objectives', 'conditions', 'effects'\n        ]\n        trigger_attr = {}\n        for key in keys:\n            if locals()[key] is not None:\n                trigger_attr[key] = locals()[key]\n        new_trigger = Trigger(name=name, trigger_id=len(self.triggers), **trigger_attr, uuid=self._uuid)\n        self.triggers.append(new_trigger)\n        return new_trigger\n\n    def import_triggers(self, triggers: List[Trigger], index: int = -1, deepcopy: bool = True) -&gt; List[Trigger]:\n        \"\"\"\n        Adds existing trigger objects (from another scenario) to this scenario. Keeping all ``(de)activate trigger``\n        effects linked!\n\n        Args:\n            triggers: The list of Trigger objects to be added\n            index: The index where to insert the new triggers, will be added at the end when left unused.\n            deepcopy: If the given triggers need to be deep copied or not when importing. Can be useful to keep the\n                reference alive between the source and target trigger the same when setting this to `False`.\n\n        Returns:\n            The newly added triggers (with the new IDs and activation links etc.)\n        \"\"\"\n        if deepcopy:\n            triggers = copy.deepcopy(triggers)\n        index_changes = {}\n\n        for offset, trigger in enumerate(triggers):\n            new_index = len(self.triggers) + offset\n            index_changes[trigger.trigger_id] = trigger.trigger_id = new_index\n\n        for trigger in triggers:\n            for i, effect in enumerate(get_activation_effects(trigger)):\n                try:\n                    effect.trigger_id = index_changes[effect.trigger_id]\n                except KeyError:\n                    warn(f\"(De)Activation effect {i} in trigger '{trigger.name}' refers to a trigger that wasn't \"\n                         f\"included in the imported triggers. Effect will be reset\")\n                    effect.trigger_id = -1\n\n        self.triggers += triggers\n        if index != -1:\n            self.move_triggers([t.trigger_id for t in triggers], index)\n        return triggers\n\n    def get_trigger(self, trigger_select: int | TriggerSelect) -&gt; Trigger:\n        \"\"\"\n        Get a single trigger\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n\n        Returns:\n            The selected trigger\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n        return trigger\n\n    def remove_trigger(self, trigger_select: int | TriggerSelect) -&gt; None:\n        \"\"\"\n        Removes a trigger BUT keeps ``(de)activate trigger`` effects linked properly!\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n        \"\"\"\n        self.remove_triggers([trigger_select])\n\n    def remove_triggers(self, trigger_selects: List[int | TriggerSelect]) -&gt; None:\n        \"\"\"\n        Removes a list of triggers BUT keeps ``(de)activate trigger`` effects linked properly!\n\n        Args:\n            trigger_selects: The list with trigger IDs\n        \"\"\"\n        removing_trigger_ids = [\n            self._validate_and_retrieve_trigger_info(trigger_select)[0] for trigger_select in trigger_selects\n        ]\n        removing_trigger_ids.sort(reverse=True)\n\n        new_display_order = self.compute_updated_display_order(removing_trigger_ids)\n\n        for trigger_id in removing_trigger_ids:\n            del self.triggers[trigger_id]\n\n        index_changes = {}\n        for new_index, trigger in enumerate(self.triggers):\n            if new_index != trigger.trigger_id:\n                index_changes[trigger.trigger_id] = new_index\n                trigger.trigger_id = new_index\n\n        # Find and update all (de)activation effect trigger references\n        for trigger in self.triggers:\n            for effect in get_activation_effects(trigger):\n                if effect.trigger_id in index_changes:\n                    effect.trigger_id = index_changes[effect.trigger_id]\n\n        self.trigger_display_order = new_display_order\n\n    def _find_trigger_tree_nodes_recursively(self, trigger, known_node_indexes: List[int]) -&gt; None:\n        found_node_indexes = TriggerManager._find_trigger_tree_nodes(trigger)\n        unknown_node_indexes = [i for i in found_node_indexes if i not in known_node_indexes]\n\n        if len(unknown_node_indexes) == 0:\n            return\n\n        known_node_indexes += unknown_node_indexes\n\n        for index in unknown_node_indexes:\n            self._find_trigger_tree_nodes_recursively(self.triggers[index], known_node_indexes)\n\n    def _validate_and_retrieve_trigger_info(self, trigger_select) -&gt; (int, int, Trigger):\n        if type(trigger_select) is int:\n            trigger = display_index = None\n            trigger_index = trigger_select\n        else:\n            trigger = trigger_select.trigger\n            trigger_index = trigger_select.trigger_index\n            display_index = trigger_select.display_index\n\n        try:\n            if trigger is not None:\n                trigger_index = trigger.trigger_id\n                display_index = self.trigger_display_order.index(trigger_index)\n            elif trigger_index is not None:\n                trigger = self.triggers[trigger_index]\n                display_index = self.trigger_display_order.index(trigger_index)\n            elif display_index is not None:\n                trigger_index = self.trigger_display_order[display_index]\n                trigger = self.triggers[trigger_index]\n        except IndexError:\n            if trigger_index:\n                raise ValueError(f\"No trigger with index {trigger_index}\") from None\n            if display_index:\n                raise ValueError(f\"No Trigger with display index {display_index}\") from None\n\n        return trigger_index, display_index, trigger\n\n    def get_summary_as_string(self) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing a summary of the content of the manager.\n        This includes all triggers and the amount of conditions and effects they hold.\n\n        Returns:\n            The created string\n        \"\"\"\n        return_string = \"\\nTrigger Summary:\\n\"\n\n        triggers = self.triggers\n        display_order = self.trigger_display_order\n\n        if len(display_order) == 0:\n            return_string += \"\\t&lt;&lt; No Triggers &gt;&gt;\"\n\n        longest_trigger_name = -1\n        longest_index_notation = -1\n        for display, trigger_index in enumerate(display_order):\n            trigger_name = triggers[trigger_index].name\n            longest_trigger_name = max(longest_trigger_name, len(trigger_name))\n\n            longest_index_notation = max(\n                longest_index_notation,\n                helper.get_int_len(display) + helper.get_int_len(trigger_index)\n            )\n\n        longest_trigger_name += 3\n        for display, trigger_index in enumerate(display_order):\n            trigger = triggers[trigger_index]\n            trigger_name = trigger.name\n\n            name_buffer = longest_trigger_name - len(trigger_name)\n            index_buffer = longest_index_notation - (helper.get_int_len(display) + helper.get_int_len(trigger_index))\n            return_string += \"\\t\" + trigger_name + (\" \" * name_buffer)\n            return_string += f\" [Index: {trigger_index}, Display: {display}] {' ' * index_buffer}\"\n\n            return_string += \"\\t(conditions: \" + str(len(trigger.conditions)) + \", \"\n            return_string += \" effects: \" + str(len(trigger.effects)) + \")\\n\"\n\n        return return_string\n\n    def get_content_as_string(self) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing all content of the manager.\n        This includes all triggers and their conditions and effects.\n\n        This is also the function that is called when doing: `print(trigger_manager)`\n\n        Returns:\n            The created string\n        \"\"\"\n        return_string = \"\\nTriggers:\\n\"\n\n        if len(self.triggers) == 0:\n            return_string += \"\\t&lt;&lt;No triggers&gt;&gt;\\n\"\n\n        for trigger_index in self.trigger_display_order:\n            return_string += self.get_trigger_as_string(trigger_index) + \"\\n\"\n\n        return return_string\n\n    def get_trigger_as_string(self, trigger_select: int | TriggerSelect) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing trigger meta-data and content.\n\n        Args:\n            trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n\n        Returns:\n            The created string\n        \"\"\"\n        trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n        return_string = \"\\t'\" + trigger.name + \"'\"\n        return_string += \" [Index: \" + str(trigger_index) + \", Display: \" + str(display_index) + \"]\" + \":\\n\"\n\n        return_string += add_tabs(trigger.get_content_as_string(include_trigger_definition=False), 2)\n\n        return return_string\n\n    @staticmethod\n    def _find_alterable_ce(trigger: Trigger, trigger_ce_lock: TriggerCELock) -&gt; (List[int], List[int]):\n        \"\"\"Logic for selecting the proper conditions and effects based on a TriggerCELock\"\"\"\n        lock_conditions = trigger_ce_lock.lock_conditions if trigger_ce_lock is not None else False\n        lock_effects = trigger_ce_lock.lock_effects if trigger_ce_lock is not None else False\n        lock_condition_type = trigger_ce_lock.lock_condition_type if trigger_ce_lock is not None else []\n        lock_effect_type = trigger_ce_lock.lock_effect_type if trigger_ce_lock is not None else []\n        lock_condition_ids = trigger_ce_lock.lock_condition_ids if trigger_ce_lock is not None else []\n        lock_effect_ids = trigger_ce_lock.lock_effect_ids if trigger_ce_lock is not None else []\n\n        alter_conditions: List[int] = []\n        alter_effects: List[int] = []\n        if not lock_conditions:\n            for i, cond in enumerate(trigger.conditions):\n                if i not in lock_condition_ids and cond.condition_type not in lock_condition_type:\n                    alter_conditions.append(i)\n        if not lock_effects:\n            for i, effect in enumerate(trigger.effects):\n                if i not in lock_effect_ids and effect.effect_type not in lock_effect_type:\n                    alter_effects.append(i)\n\n        return alter_conditions, alter_effects\n\n    @staticmethod\n    def _find_trigger_tree_nodes(trigger: Trigger) -&gt; List[int]:\n        \"\"\"Get all linked trigger ids from all (de)activation effects in a trigger\"\"\"\n        return [\n            effect.trigger_id for effect in trigger.effects if\n            effect.effect_type in [EffectId.ACTIVATE_TRIGGER, EffectId.DEACTIVATE_TRIGGER]\n        ]\n\n    def __str__(self) -&gt; str:\n        return self.get_content_as_string()\n\n    def compute_updated_display_order(self, removing_trigger_ids: List[int]):\n        new_display_order = []\n        for index in self.trigger_display_order:\n            subtract = 0\n            skip = False\n\n            for removing_index in removing_trigger_ids:\n                if removing_index == index:\n                    skip = True\n                    break\n\n                if index &gt; removing_index:\n                    subtract += 1\n\n            if skip:\n                continue\n\n            new_display_order.append(index - subtract)\n\n        return new_display_order\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.trigger_display_order","title":"<code>trigger_display_order: List[int]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[int]</code> <p>The display order. This is a list of trigger IDs in the display order. NOT execution order!</p>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.triggers","title":"<code>triggers: UuidList[Trigger]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>UuidList[Trigger]</code> <p>All triggers</p>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>triggers</code> <code>List[Trigger]</code>  - required <code>trigger_display_order</code> <code>List[int]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def __init__(\n        self,\n        triggers: List[Trigger],\n        trigger_display_order: List[int],\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    self.triggers: List[Trigger] = triggers\n    self.trigger_display_order: List[int] = trigger_display_order\n    self._trigger_hash = hash_list(triggers)\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.__str__","title":"<code>def __str__(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.get_content_as_string()\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.add_trigger","title":"<code>def add_trigger(...)</code>","text":"<p>Adds a new trigger to the scenario. Everything that is left empty will be set to in-game editor defaults.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the trigger</p> required <code>description</code> <code>str | None</code> <p>The trigger description</p> <code>None</code> <code>description_stid</code> <code>int | None</code> <p>The trigger description string table ID</p> <code>None</code> <code>display_as_objective</code> <code>bool | None</code> <p>Display the trigger as objective</p> <code>None</code> <code>short_description</code> <code>str | None</code> <p>The short trigger description</p> <code>None</code> <code>short_description_stid</code> <code>int | None</code> <p>The short trigger description string table ID</p> <code>None</code> <code>display_on_screen</code> <code>bool | None</code> <p>Display the trigger objective on screen</p> <code>None</code> <code>description_order</code> <code>int | None</code> <p>?</p> <code>None</code> <code>enabled</code> <code>bool | None</code> <p>If the trigger is enabled from the start.</p> <code>None</code> <code>looping</code> <code>bool | None</code> <p>If the trigger loops.</p> <code>None</code> <code>header</code> <code>bool | None</code> <p>Turn objective into header</p> <code>None</code> <code>mute_objectives</code> <code>bool | None</code> <p>Mute objectives</p> <code>None</code> <code>conditions</code> <code>List | None</code> <p>A list of condition managers</p> <code>None</code> <code>effects</code> <code>List | None</code> <p>A list of effect managers</p> <code>None</code> <p>Returns:</p> Type Description <code>Trigger</code> <p>The newly created trigger</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def add_trigger(\n        self,\n        name: str,\n        description: str | None = None,\n        description_stid: int | None = None,\n        display_as_objective: bool | None = None,\n        short_description: str | None = None,\n        short_description_stid: int | None = None,\n        display_on_screen: bool | None = None,\n        description_order: int | None = None,\n        enabled: bool | None = None,\n        looping: bool | None = None,\n        header: bool | None = None,\n        mute_objectives: bool | None = None,\n        conditions: List | None = None,\n        effects: List | None = None\n) -&gt; Trigger:\n    \"\"\"\n    Adds a new trigger to the scenario. Everything that is left empty will be set to in-game editor defaults.\n\n    Args:\n        name: The name for the trigger\n        description: The trigger description\n        description_stid: The trigger description string table ID\n        display_as_objective: Display the trigger as objective\n        short_description: The short trigger description\n        short_description_stid: The short trigger description string table ID\n        display_on_screen: Display the trigger objective on screen\n        description_order: ?\n        enabled: If the trigger is enabled from the start.\n        looping: If the trigger loops.\n        header: Turn objective into header\n        mute_objectives: Mute objectives\n        conditions: A list of condition managers\n        effects: A list of effect managers\n\n    Returns:\n        The newly created trigger\n    \"\"\"\n    keys = [\n        'description', 'description_stid', 'display_as_objective', 'short_description',\n        'short_description_stid', 'display_on_screen', 'description_order', 'enabled', 'looping', 'header',\n        'mute_objectives', 'conditions', 'effects'\n    ]\n    trigger_attr = {}\n    for key in keys:\n        if locals()[key] is not None:\n            trigger_attr[key] = locals()[key]\n    new_trigger = Trigger(name=name, trigger_id=len(self.triggers), **trigger_attr, uuid=self._uuid)\n    self.triggers.append(new_trigger)\n    return new_trigger\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.compute_updated_display_order","title":"<code>def compute_updated_display_order(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>removing_trigger_ids</code> <code>List[int]</code>  - required Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def compute_updated_display_order(self, removing_trigger_ids: List[int]):\n    new_display_order = []\n    for index in self.trigger_display_order:\n        subtract = 0\n        skip = False\n\n        for removing_index in removing_trigger_ids:\n            if removing_index == index:\n                skip = True\n                break\n\n            if index &gt; removing_index:\n                subtract += 1\n\n        if skip:\n            continue\n\n        new_display_order.append(index - subtract)\n\n    return new_display_order\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.copy_trigger","title":"<code>def copy_trigger(...)</code>","text":"<p>Creates an exact copy (deepcopy) of this trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <code>append_after_source</code> <code>bool</code> <p>If the new trigger should be appended below the source trigger</p> <code>True</code> <code>add_suffix</code> <code>bool</code> <p>If the text ' (copy)' should be added after the trigger</p> <code>True</code> <p>Returns:</p> Type Description <code>Trigger</code> <p>The newly copied trigger</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def copy_trigger(\n        self,\n        trigger_select: int | TriggerSelect,\n        append_after_source: bool = True,\n        add_suffix: bool = True\n) -&gt; Trigger:\n    \"\"\"\n    Creates an exact copy (deepcopy) of this trigger.\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n        append_after_source: If the new trigger should be appended below the source trigger\n        add_suffix: If the text ' (copy)' should be added after the trigger\n\n    Returns:\n        The newly copied trigger\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n    deepcopy_trigger = copy.deepcopy(trigger)\n    deepcopy_trigger.trigger_id = len(self.triggers)\n    if add_suffix:\n        deepcopy_trigger.name += \" (copy)\"\n\n    self.triggers.append(deepcopy_trigger)\n\n    if append_after_source:\n        self.move_triggers([trigger_index, deepcopy_trigger.trigger_id], trigger_index)\n\n    return deepcopy_trigger\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.copy_trigger_per_player","title":"<code>def copy_trigger_per_player(...)</code>","text":"<p>Copies a trigger for all or a selection of players. Every copy will change desired player attributes with it.</p> <p>Parameters:</p> Name Type Description Default <code>from_player</code> <code>IntEnum</code> <p>The central player this trigger is created for. This is the player that will not get a copy.</p> required <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <code>change_from_player_only</code> <code>bool</code> <p>If set to <code>True</code>,  only change player attributes in effects and conditions that are equal to the player defined using the <code>from_player</code> parameter.</p> <code>False</code> <code>include_player_source</code> <code>bool</code> <p>If set to <code>True</code>,  allow player source attributes to be changed while copying. Player source attributes are attributes where a player is defined to perform an action such as create an object. If set to <code>False</code> these attributes will remain unchanged.</p> <code>True</code> <code>include_player_target</code> <code>bool</code> <p>If set to <code>True</code>,  allow player target attributes to be changed while copying. Player target attributes are attributes where a player is defined as the target such as change ownership or sending resources. If set to <code>False</code> these attributes will remain unchanged.</p> <code>False</code> <code>trigger_ce_lock</code> <code>TriggerCELock | None</code> <p>The TriggerCELock object. Used to lock certain (types) of conditions or effects from being changed while copying.</p> <code>None</code> <code>include_gaia</code> <code>bool</code> <p>If <code>True</code>,  GAIA is included in the copied list. (Also when <code>create_copy_for_players</code> is defined)</p> <code>False</code> <code>create_copy_for_players</code> <code>List[IntEnum]</code> <p>A list of Players to create a copy for. The <code>from_player</code> will be excluded from this list.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[PlayerId, Trigger]</code> <p>A dict with all the new created triggers. The key is the player for which the trigger is created using the IntEnum associated with it. Example: <code>{PlayerId.TWO: Trigger, PlayerId.FIVE: Trigger}</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if more than one trigger selection is used. Any of (trigger_index, display_index or trigger) Or if Both <code>include_player_source</code> and <code>include_player_target</code> are <code>False</code></p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def copy_trigger_per_player(\n        self,\n        from_player: IntEnum,\n        trigger_select: int | TriggerSelect,\n        change_from_player_only: bool = False,\n        include_player_source: bool = True,\n        include_player_target: bool = False,\n        trigger_ce_lock: TriggerCELock | None = None,\n        include_gaia: bool = False,\n        create_copy_for_players: List[IntEnum] = None\n) -&gt; Dict[PlayerId, Trigger]:\n    \"\"\"\n    Copies a trigger for all or a selection of players. Every copy will change desired player attributes with it.\n\n    Args:\n        from_player: The central player this trigger is created for. This is the player that will not get\n            a copy.\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n        change_from_player_only: If set to `True`,  only change player attributes in effects and conditions that\n            are equal to the player defined using the `from_player` parameter.\n        include_player_source: If set to `True`,  allow player source attributes to be changed while copying.\n            Player source attributes are attributes where a player is defined to perform an action such as create an\n            object. If set to `False` these attributes will remain unchanged.\n        include_player_target: If set to `True`,  allow player target attributes to be changed while copying.\n            Player target attributes are attributes where a player is defined as the target such as change ownership\n            or sending resources. If set to `False` these attributes will remain unchanged.\n        trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n            effects from being changed while copying.\n        include_gaia: If `True`,  GAIA is included in the copied list. (Also when `create_copy_for_players` is\n            defined)\n        create_copy_for_players: A list of Players to create a copy for. The `from_player` will be\n            excluded from this list.\n\n    Returns:\n        A dict with all the new created triggers. The key is the player for which the trigger is\n            created using the IntEnum associated with it. Example:\n            `{PlayerId.TWO: Trigger, PlayerId.FIVE: Trigger}`\n\n    Raises:\n        ValueError: if more than one trigger selection is used. Any of (trigger_index, display_index or trigger)\n            Or if Both `include_player_source` and `include_player_target` are `False`\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n    if create_copy_for_players is None:\n        create_copy_for_players = [\n            PlayerId.ONE, PlayerId.TWO, PlayerId.THREE, PlayerId.FOUR,\n            PlayerId.FIVE, PlayerId.SIX, PlayerId.SEVEN, PlayerId.EIGHT\n        ]\n    if include_gaia and PlayerId.GAIA not in create_copy_for_players:\n        create_copy_for_players.append(PlayerId.GAIA)\n\n    alter_conditions, alter_effects = TriggerManager._find_alterable_ce(trigger, trigger_ce_lock)\n\n    return_dict: Dict[PlayerId, Trigger] = {}\n    for player in create_copy_for_players:\n        if player == from_player:\n            continue\n\n        new_trigger = self.copy_trigger(TriggerSelect.trigger(trigger), append_after_source=False, add_suffix=False)\n        new_trigger.name += \" (GAIA)\" if player == PlayerId.GAIA else f\" (p{player})\"\n        return_dict[player] = new_trigger\n\n        for cond_x in alter_conditions:\n            cond = new_trigger.conditions[cond_x]\n            if cond.source_player == -1:\n                continue\n\n            if include_player_source:\n                if not change_from_player_only or (change_from_player_only and cond.source_player == from_player):\n                    cond.source_player = PlayerId(player)\n            if include_player_target:\n                if not change_from_player_only or (change_from_player_only and cond.target_player == from_player):\n                    cond.target_player = PlayerId(player)\n\n        for effect_x in alter_effects:\n            effect = new_trigger.effects[effect_x]\n            if effect.source_player == -1:\n                continue\n\n            if include_player_source:\n                if not change_from_player_only or (change_from_player_only and effect.source_player == from_player):\n                    effect.source_player = PlayerId(player)\n            if include_player_target:\n                if not change_from_player_only or (change_from_player_only and effect.target_player == from_player):\n                    effect.target_player = PlayerId(player)\n\n    # After copies have been made\n    trigger.name += f\" (p{from_player})\"\n\n    return return_dict\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.copy_trigger_tree","title":"<code>def copy_trigger_tree(...)</code>","text":"<p>Copies an entire trigger tree. Trigger trees are triggers linked together using <code>(de)activate_trigger</code> effects.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select</p> required <p>Returns:</p> Type Description <code>List[Trigger]</code> <p>The newly created triggers in a list</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def copy_trigger_tree(self, trigger_select: int | TriggerSelect) -&gt; List[Trigger]:\n    \"\"\"\n    Copies an entire trigger tree. Trigger trees are triggers linked together using `(de)activate_trigger` effects.\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select\n\n    Returns:\n        The newly created triggers in a list\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n    known_node_indexes = [trigger_index]\n    self._find_trigger_tree_nodes_recursively(trigger, known_node_indexes)\n\n    new_triggers = []\n    id_swap = {}\n    for index in known_node_indexes:\n        trigger = self.copy_trigger(index, append_after_source=False)\n        new_triggers.append(trigger)\n        id_swap[index] = trigger.trigger_id\n\n    for trigger in new_triggers:\n        for effect in get_activation_effects(trigger):\n            effect.trigger_id = id_swap[effect.trigger_id]\n\n    return new_triggers\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.copy_trigger_tree_per_player","title":"<code>def copy_trigger_tree_per_player(...)</code>","text":"<p>Copies an entire trigger tree for all or a selection of players. Every copy will change desired player attributes with it. Trigger trees are triggers linked together using <code>(de)activate_trigger</code> effects.</p> <p>Parameters:</p> Name Type Description Default <code>from_player</code> <code>IntEnum</code> <p>The central player this trigger is created for. This is the player that will not get a copy.</p> required <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <code>change_from_player_only</code> <code>bool</code> <p>If set to <code>True</code>,  only change player attributes in effects and conditions that are equal to the player defined using the <code>from_player</code> parameter.</p> <code>False</code> <code>include_player_source</code> <code>bool</code> <p>If set to <code>True</code>,  allow player source attributes to be changed while copying. Player source attributes are attributes where a player is defined to perform an action such as create an object. If set to <code>False</code> these attributes will remain unchanged.</p> <code>True</code> <code>include_player_target</code> <code>bool</code> <p>If set to <code>True</code>,  allow player target attributes to be changed while copying. Player target attributes are attributes where a player is defined as the target such as change ownership or sending resources. If set to <code>False</code> these attributes will remain unchanged.</p> <code>False</code> <code>trigger_ce_lock</code> <code>TriggerCELock | None</code> <p>The TriggerCELock object. Used to lock certain (types) of conditions or effects from being changed while copying.</p> <code>None</code> <code>include_gaia</code> <code>bool</code> <p>If <code>True</code>,  GAIA is included in the copied list. (Also when <code>create_copy_for_players</code> is defined)</p> <code>False</code> <code>create_copy_for_players</code> <code>List[IntEnum] | None</code> <p>A list of Players to create a copy for. The <code>from_player</code> will be excluded from this list.</p> <code>None</code> <code>group_triggers_by</code> <code>GroupBy | None</code> <p>How to group the newly added triggers.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[IntEnum, List[Trigger]]</code> <p>The newly created triggers in a dict using the Player as key and as value with a list of triggers</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def copy_trigger_tree_per_player(\n        self,\n        from_player: IntEnum,\n        trigger_select: int | TriggerSelect,\n        change_from_player_only: bool = False,\n        include_player_source: bool = True,\n        include_player_target: bool = False,\n        trigger_ce_lock: TriggerCELock | None = None,\n        include_gaia: bool = False,\n        create_copy_for_players: List[IntEnum] | None = None,\n        group_triggers_by: GroupBy | None = None\n) -&gt; Dict[IntEnum, List[Trigger]]:\n    \"\"\"\n    Copies an entire trigger tree for all or a selection of players. Every copy will change desired player\n    attributes with it. Trigger trees are triggers linked together using `(de)activate_trigger` effects.\n\n    Args:\n        from_player: The central player this trigger is created for. This is the player that will not get\n            a copy.\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n        change_from_player_only: If set to `True`,  only change player attributes in effects and conditions that\n            are equal to the player defined using the `from_player` parameter.\n        include_player_source: If set to `True`,  allow player source attributes to be changed while copying.\n            Player source attributes are attributes where a player is defined to perform an action such as create an\n            object. If set to `False` these attributes will remain unchanged.\n        include_player_target: If set to `True`,  allow player target attributes to be changed while copying.\n            Player target attributes are attributes where a player is defined as the target such as change ownership\n            or sending resources. If set to `False` these attributes will remain unchanged.\n        trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n            effects from being changed while copying.\n        include_gaia: If `True`,  GAIA is included in the copied list. (Also when `create_copy_for_players` is\n            defined)\n        create_copy_for_players: A list of Players to create a copy for. The `from_player` will be\n            excluded from this list.\n        group_triggers_by: How to group the newly added triggers.\n\n    Returns:\n        The newly created triggers in a dict using the Player as key and as value with a list of triggers\n    \"\"\"\n    if group_triggers_by is None:\n        group_triggers_by = GroupBy.NONE\n\n    trigger_index, display_index, source_trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n    known_node_indexes = [trigger_index]\n    self._find_trigger_tree_nodes_recursively(source_trigger, known_node_indexes)\n\n    new_triggers: Dict[IntEnum, List[Trigger]] = {}\n    trigger_index_swap = {}\n\n    # Set values for from_player\n    new_triggers[from_player] = [self.triggers[i] for i in known_node_indexes]\n    for index in known_node_indexes:\n        trigger: Trigger = self.triggers[index]\n        trigger_index_swap.setdefault(index, {})[from_player] = trigger.trigger_id\n\n    # Copy for all other players\n    for index in known_node_indexes:\n        triggers = self.copy_trigger_per_player(\n            from_player,\n            index,\n            change_from_player_only,\n            include_player_source,\n            include_player_target,\n            trigger_ce_lock,\n            include_gaia,\n            create_copy_for_players,\n        )\n        for player, trigger in triggers.items():\n            trigger_index_swap.setdefault(index, {})[player] = trigger.trigger_id\n            new_triggers.setdefault(player, []).append(trigger)\n\n    # Set trigger_id's in activation effects to the new player copied trigger ID\n    for player, triggers in new_triggers.items():\n        for trigger in triggers:\n            for effect in get_activation_effects(trigger):\n                effect.trigger_id = trigger_index_swap[effect.trigger_id][player]\n\n    # -------------- Group by logic -------------- #\n    new_trigger_ids = []\n    if group_triggers_by == GroupBy.TRIGGER:\n        for i in range(len(known_node_indexes)):\n            for player in PlayerId.all():\n                if player == from_player:\n                    new_trigger_ids.append(known_node_indexes[i])\n                    continue\n                if player not in new_triggers:\n                    continue\n                new_trigger_ids.append(new_triggers[player][i].trigger_id)\n    elif group_triggers_by == GroupBy.PLAYER:\n        for player in PlayerId.all():\n            if player == from_player:\n                new_trigger_ids.extend(known_node_indexes)\n                continue\n            if player not in new_triggers:\n                continue\n\n            new_trigger_ids.extend([trigger.trigger_id for trigger in new_triggers[player]])\n\n    if group_triggers_by != GroupBy.NONE:\n        self.move_triggers(new_trigger_ids, display_index)\n\n    return new_triggers\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.get_content_as_string","title":"<code>def get_content_as_string(...)</code>","text":"<p>Create a human-readable string showcasing all content of the manager. This includes all triggers and their conditions and effects.</p> <p>This is also the function that is called when doing: <code>print(trigger_manager)</code></p> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def get_content_as_string(self) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing all content of the manager.\n    This includes all triggers and their conditions and effects.\n\n    This is also the function that is called when doing: `print(trigger_manager)`\n\n    Returns:\n        The created string\n    \"\"\"\n    return_string = \"\\nTriggers:\\n\"\n\n    if len(self.triggers) == 0:\n        return_string += \"\\t&lt;&lt;No triggers&gt;&gt;\\n\"\n\n    for trigger_index in self.trigger_display_order:\n        return_string += self.get_trigger_as_string(trigger_index) + \"\\n\"\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.get_summary_as_string","title":"<code>def get_summary_as_string(...)</code>","text":"<p>Create a human-readable string showcasing a summary of the content of the manager. This includes all triggers and the amount of conditions and effects they hold.</p> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def get_summary_as_string(self) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing a summary of the content of the manager.\n    This includes all triggers and the amount of conditions and effects they hold.\n\n    Returns:\n        The created string\n    \"\"\"\n    return_string = \"\\nTrigger Summary:\\n\"\n\n    triggers = self.triggers\n    display_order = self.trigger_display_order\n\n    if len(display_order) == 0:\n        return_string += \"\\t&lt;&lt; No Triggers &gt;&gt;\"\n\n    longest_trigger_name = -1\n    longest_index_notation = -1\n    for display, trigger_index in enumerate(display_order):\n        trigger_name = triggers[trigger_index].name\n        longest_trigger_name = max(longest_trigger_name, len(trigger_name))\n\n        longest_index_notation = max(\n            longest_index_notation,\n            helper.get_int_len(display) + helper.get_int_len(trigger_index)\n        )\n\n    longest_trigger_name += 3\n    for display, trigger_index in enumerate(display_order):\n        trigger = triggers[trigger_index]\n        trigger_name = trigger.name\n\n        name_buffer = longest_trigger_name - len(trigger_name)\n        index_buffer = longest_index_notation - (helper.get_int_len(display) + helper.get_int_len(trigger_index))\n        return_string += \"\\t\" + trigger_name + (\" \" * name_buffer)\n        return_string += f\" [Index: {trigger_index}, Display: {display}] {' ' * index_buffer}\"\n\n        return_string += \"\\t(conditions: \" + str(len(trigger.conditions)) + \", \"\n        return_string += \" effects: \" + str(len(trigger.effects)) + \")\\n\"\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.get_trigger","title":"<code>def get_trigger(...)</code>","text":"<p>Get a single trigger</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <p>Returns:</p> Type Description <code>Trigger</code> <p>The selected trigger</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def get_trigger(self, trigger_select: int | TriggerSelect) -&gt; Trigger:\n    \"\"\"\n    Get a single trigger\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n\n    Returns:\n        The selected trigger\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n    return trigger\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.get_trigger_as_string","title":"<code>def get_trigger_as_string(...)</code>","text":"<p>Create a human-readable string showcasing trigger meta-data and content.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def get_trigger_as_string(self, trigger_select: int | TriggerSelect) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing trigger meta-data and content.\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n\n    Returns:\n        The created string\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n\n    return_string = \"\\t'\" + trigger.name + \"'\"\n    return_string += \" [Index: \" + str(trigger_index) + \", Display: \" + str(display_index) + \"]\" + \":\\n\"\n\n    return_string += add_tabs(trigger.get_content_as_string(include_trigger_definition=False), 2)\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.import_triggers","title":"<code>def import_triggers(...)</code>","text":"<p>Adds existing trigger objects (from another scenario) to this scenario. Keeping all <code>(de)activate trigger</code> effects linked!</p> <p>Parameters:</p> Name Type Description Default <code>triggers</code> <code>List[Trigger]</code> <p>The list of Trigger objects to be added</p> required <code>index</code> <code>int</code> <p>The index where to insert the new triggers, will be added at the end when left unused.</p> <code>-1</code> <code>deepcopy</code> <code>bool</code> <p>If the given triggers need to be deep copied or not when importing. Can be useful to keep the reference alive between the source and target trigger the same when setting this to <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Trigger]</code> <p>The newly added triggers (with the new IDs and activation links etc.)</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def import_triggers(self, triggers: List[Trigger], index: int = -1, deepcopy: bool = True) -&gt; List[Trigger]:\n    \"\"\"\n    Adds existing trigger objects (from another scenario) to this scenario. Keeping all ``(de)activate trigger``\n    effects linked!\n\n    Args:\n        triggers: The list of Trigger objects to be added\n        index: The index where to insert the new triggers, will be added at the end when left unused.\n        deepcopy: If the given triggers need to be deep copied or not when importing. Can be useful to keep the\n            reference alive between the source and target trigger the same when setting this to `False`.\n\n    Returns:\n        The newly added triggers (with the new IDs and activation links etc.)\n    \"\"\"\n    if deepcopy:\n        triggers = copy.deepcopy(triggers)\n    index_changes = {}\n\n    for offset, trigger in enumerate(triggers):\n        new_index = len(self.triggers) + offset\n        index_changes[trigger.trigger_id] = trigger.trigger_id = new_index\n\n    for trigger in triggers:\n        for i, effect in enumerate(get_activation_effects(trigger)):\n            try:\n                effect.trigger_id = index_changes[effect.trigger_id]\n            except KeyError:\n                warn(f\"(De)Activation effect {i} in trigger '{trigger.name}' refers to a trigger that wasn't \"\n                     f\"included in the imported triggers. Effect will be reset\")\n                effect.trigger_id = -1\n\n    self.triggers += triggers\n    if index != -1:\n        self.move_triggers([t.trigger_id for t in triggers], index)\n    return triggers\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.move_triggers","title":"<code>def move_triggers(...)</code>","text":"<p>Moves the given IDs from anywhere to the split index. This function reorders triggers BUT keeps <code>(de)activate trigger</code> effects linked properly!</p> <p>As an example:</p> <pre><code>[0,1,2,3,4,5,6,7,8]  # Current index order\n# Let's move trigger 1, 4, 5 and 6 to location 2\nself.move_triggers([1, 4, 5, 6], 2)  # &lt;&lt; 2 is an INDEX, not the value\n[0,1,4,5,6,2,3,7,8]  # New index order\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>trigger_ids</code> <code>List[int]</code> <p>The trigger IDs to move</p> required <code>insert_index</code> <code>int</code> <p>The index that defines where to insert the triggers</p> required Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def move_triggers(self, trigger_ids: List[int], insert_index: int) -&gt; None:\n    \"\"\"\n    Moves the given IDs from anywhere to the split index. This function reorders triggers BUT keeps\n    ``(de)activate trigger`` effects linked properly!\n\n    As an example:\n\n    ```\n    [0,1,2,3,4,5,6,7,8]  # Current index order\n    # Let's move trigger 1, 4, 5 and 6 to location 2\n    self.move_triggers([1, 4, 5, 6], 2)  # &lt;&lt; 2 is an INDEX, not the value\n    [0,1,4,5,6,2,3,7,8]  # New index order\n    ```\n\n    Args:\n        trigger_ids: The trigger IDs to move\n        insert_index: The index that defines where to insert the triggers\n    \"\"\"\n    if min(trigger_ids) &lt; 0:\n        raise ValueError(f\"Trigger IDs cannot be negative\")\n\n    if insert_index &gt;= len(self.trigger_display_order):\n        # Add to the end of the list\n        new_trigger_id_order = [n for n in self.trigger_display_order if n not in trigger_ids]\n        new_trigger_id_order += trigger_ids\n    else:\n        insert_num = self.trigger_display_order[insert_index]\n        new_trigger_id_order = [n for n in self.trigger_display_order if n not in trigger_ids or n == insert_num]\n\n        split_index = new_trigger_id_order.index(insert_num)\n\n        if insert_num in trigger_ids:\n            new_trigger_id_order.remove(insert_num)\n\n        new_trigger_id_order = new_trigger_id_order[:split_index] + trigger_ids + new_trigger_id_order[split_index:]\n    self.reorder_triggers(new_trigger_id_order)\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.remove_trigger","title":"<code>def remove_trigger(...)</code>","text":"<p>Removes a trigger BUT keeps <code>(de)activate trigger</code> effects linked properly!</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def remove_trigger(self, trigger_select: int | TriggerSelect) -&gt; None:\n    \"\"\"\n    Removes a trigger BUT keeps ``(de)activate trigger`` effects linked properly!\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n    \"\"\"\n    self.remove_triggers([trigger_select])\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.remove_triggers","title":"<code>def remove_triggers(...)</code>","text":"<p>Removes a list of triggers BUT keeps <code>(de)activate trigger</code> effects linked properly!</p> <p>Parameters:</p> Name Type Description Default <code>trigger_selects</code> <code>List[int | TriggerSelect]</code> <p>The list with trigger IDs</p> required Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def remove_triggers(self, trigger_selects: List[int | TriggerSelect]) -&gt; None:\n    \"\"\"\n    Removes a list of triggers BUT keeps ``(de)activate trigger`` effects linked properly!\n\n    Args:\n        trigger_selects: The list with trigger IDs\n    \"\"\"\n    removing_trigger_ids = [\n        self._validate_and_retrieve_trigger_info(trigger_select)[0] for trigger_select in trigger_selects\n    ]\n    removing_trigger_ids.sort(reverse=True)\n\n    new_display_order = self.compute_updated_display_order(removing_trigger_ids)\n\n    for trigger_id in removing_trigger_ids:\n        del self.triggers[trigger_id]\n\n    index_changes = {}\n    for new_index, trigger in enumerate(self.triggers):\n        if new_index != trigger.trigger_id:\n            index_changes[trigger.trigger_id] = new_index\n            trigger.trigger_id = new_index\n\n    # Find and update all (de)activation effect trigger references\n    for trigger in self.triggers:\n        for effect in get_activation_effects(trigger):\n            if effect.trigger_id in index_changes:\n                effect.trigger_id = index_changes[effect.trigger_id]\n\n    self.trigger_display_order = new_display_order\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.reorder_triggers","title":"<code>def reorder_triggers(...)</code>","text":"<p>Reorder all triggers to a given order of IDs. This function reorders triggers BUT keeps <code>(de)activate trigger</code> effects linked properly!</p> <p>Examples:</p> <pre><code>Moving the 6th trigger to the end of the trigger list::\n\n    [0,1,2,3,4,5,6,7,8]  # Trigger IDs before\n    self.reorder_triggers([0,1,2,3,5,4,7,8,6])\n    [0,1,2,3,5,4,7,8,6]  # Trigger IDs after\n\nSetting the trigger (execution) order to the current display order::\n\n    self.reorder_triggers(self.trigger_display_order)\n</code></pre> <p>Keep in mind that all trigger IDs will get remapped with this function. So <code>trigger_manager.triggers[4]</code> might result in a different trigger after this function is called in comparison to before.</p> <p>Parameters:</p> Name Type Description Default <code>new_id_order</code> <code>List[int]</code> <p>The new trigger order. Uses the current display order when left unused</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def reorder_triggers(self, new_id_order: List[int] = None, ) -&gt; None:\n    \"\"\"\n    Reorder all triggers to a given order of IDs. This function reorders triggers BUT keeps ``(de)activate trigger``\n    effects linked properly!\n\n    Examples:\n\n        Moving the 6th trigger to the end of the trigger list::\n\n            [0,1,2,3,4,5,6,7,8]  # Trigger IDs before\n            self.reorder_triggers([0,1,2,3,5,4,7,8,6])\n            [0,1,2,3,5,4,7,8,6]  # Trigger IDs after\n\n        Setting the trigger (execution) order to the current display order::\n\n            self.reorder_triggers(self.trigger_display_order)\n\n    Keep in mind that all trigger IDs will get remapped with this function. So ``trigger_manager.triggers[4]`` might\n    result in a different trigger after this function is called in comparison to before.\n\n    Args:\n        new_id_order: The new trigger order. Uses the current display order when left unused\n    \"\"\"\n    if new_id_order is not None:\n        if min(new_id_order) &lt; 0:\n            raise ValueError(f\"Trigger IDs cannot be negative\")\n        self.trigger_display_order = new_id_order\n\n    new_triggers_list = []\n    index_changes = {}\n    for new_index, index in enumerate(self.trigger_display_order):\n        try:\n            trigger = self.triggers[index]\n        except IndexError:\n            raise ValueError(f\"The trigger ID {index} doesn't exist\") from None\n        index_changes[trigger.trigger_id] = new_index\n\n        trigger.trigger_id = new_index\n        new_triggers_list.append(trigger)\n    self.triggers = new_triggers_list\n\n    # Find and update all (de)activation effect trigger references\n    for trigger in self.triggers:\n        for effect in get_activation_effects(trigger):\n            if effect.trigger_id in index_changes:\n                effect.trigger_id = index_changes[effect.trigger_id]\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.TriggerManager.replace_player","title":"<code>def replace_player(...)</code>","text":"<p>Replaces player attributes. Specifically useful if multiple players are used in the same trigger.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_select</code> <code>int | TriggerSelect</code> <p>The ID of the trigger or an object used to identify which trigger to select.</p> required <code>to_player</code> <code>PlayerId</code> <p>The player the attributes are changed to.</p> required <code>only_change_from</code> <code>PlayerId</code> <p>Can only change player attributes if the player is equal to the given value</p> <code>None</code> <code>include_player_source</code> <code>bool</code> <p>If set to <code>True</code>,  allow player source attributes to be changed while replacing. Player source attributes are attributes where a player is defined to perform an action such as create an object. If set to <code>False</code> these attributes will remain unchanged.</p> <code>True</code> <code>include_player_target</code> <code>bool</code> <p>If set to <code>True</code>,  allow player target attributes to be changed while replacing. Player target attributes are attributes where a player is defined as the target such as change ownership or sending resources. If set to <code>False</code> these attributes will remain unchanged.</p> <code>False</code> <code>trigger_ce_lock</code> <code>TriggerCELock</code> <p>The TriggerCELock object. Used to lock certain (types) of conditions or effects from being changed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Trigger</code> <p>The given trigger with the proper player attributes changed</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def replace_player(\n        self,\n        trigger_select: int | TriggerSelect,\n        to_player: PlayerId,\n        only_change_from: PlayerId = None,\n        include_player_source: bool = True,\n        include_player_target: bool = False,\n        trigger_ce_lock: TriggerCELock = None\n) -&gt; Trigger:\n    \"\"\"\n    Replaces player attributes. Specifically useful if multiple players are used in the same trigger.\n\n    Args:\n        trigger_select: The ID of the trigger or an object used to identify which trigger to select.\n        to_player: The player the attributes are changed to.\n        only_change_from: Can only change player attributes if the player is equal to the given value\n        include_player_source: If set to `True`,  allow player source attributes to be changed while replacing.\n            Player source attributes are attributes where a player is defined to perform an action such as create an\n            object. If set to `False` these attributes will remain unchanged.\n        include_player_target: If set to `True`,  allow player target attributes to be changed while replacing.\n            Player target attributes are attributes where a player is defined as the target such as change ownership\n            or sending resources. If set to `False` these attributes will remain unchanged.\n        trigger_ce_lock: The TriggerCELock object. Used to lock certain (types) of conditions or\n            effects from being changed.\n\n    Returns:\n        The given trigger with the proper player attributes changed\n    \"\"\"\n    trigger_index, display_index, trigger = self._validate_and_retrieve_trigger_info(trigger_select)\n    alter_conditions, alter_effects = TriggerManager._find_alterable_ce(trigger, trigger_ce_lock)\n\n    for cond_x in alter_conditions:\n        cond = trigger.conditions[cond_x]\n        if value_is_valid(cond.source_player) and include_player_source:\n            if only_change_from is not None and only_change_from != cond.source_player:\n                continue\n            cond.source_player = PlayerId(to_player)\n        if value_is_valid(cond.target_player) and include_player_target:\n            if only_change_from is not None and only_change_from != cond.target_player:\n                continue\n            cond.target_player = PlayerId(to_player)\n    for effect_x in alter_effects:\n        effect = trigger.effects[effect_x]\n        if value_is_valid(effect.source_player) and include_player_source:\n            if only_change_from is not None and only_change_from != effect.source_player:\n                continue\n            effect.source_player = PlayerId(to_player)\n        if value_is_valid(effect.target_player) and include_player_target:\n            if only_change_from is not None and only_change_from != effect.target_player:\n                continue\n            effect.target_player = PlayerId(to_player)\n\n    return trigger\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager.get_activation_effects","title":"<code>def get_activation_effects(...)</code>","text":"<p>Get all activation effects in a Trigger</p> <p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>Trigger</code> <p>The trigger object</p> required <p>Returns:</p> Type Description <code>List[Effect]</code> <p>A list with (de)activation effects</p> Source code in <code>AoE2ScenarioParser/objects/managers/trigger_manager.py</code> <pre><code>def get_activation_effects(trigger: Trigger) -&gt; List[Effect]:\n    \"\"\"\n    Get all activation effects in a Trigger\n\n    Args:\n        trigger: The trigger object\n\n    Returns:\n        A list with (de)activation effects\n    \"\"\"\n    return [eff for eff in trigger.effects if eff.effect_type in [\n        EffectId.ACTIVATE_TRIGGER, EffectId.DEACTIVATE_TRIGGER\n    ]]\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager/#AoE2ScenarioParser.objects.managers.trigger_manager-modules","title":"Modules","text":""},{"location":"api_docs/trigger/trigger_manager_de/","title":"TriggerManagerDE","text":""},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de-classes","title":"Classes","text":""},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE","title":"<code>TriggerManagerDE</code>","text":"<p>               Bases: <code>TriggerManager</code></p> <p>Manager of all DE trigger related features</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>class TriggerManagerDE(TriggerManager):\n    \"\"\"Manager of all DE trigger related features\"\"\"\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Triggers\", group=[\n            RetrieverObjectLink(\"triggers\", link=\"trigger_data\", process_as_object=Trigger),\n            RetrieverObjectLink(\"trigger_display_order\", link=\"trigger_display_order_array\"),\n            RetrieverObjectLink(\"variables\", link=\"variable_data\", process_as_object=Variable),\n        ])\n    ]\n\n    def __init__(self, triggers: List[Trigger], trigger_display_order: List[int], variables: List[Variable], **kwargs):\n        super().__init__(triggers, trigger_display_order, **kwargs)\n\n        self.variables: List[Variable] = variables\n\n    @property\n    def variables(self) -&gt; List[Variable]:\n        \"\"\"All currently renamed variables\"\"\"\n        return self._variables\n\n    @variables.setter\n    def variables(self, value: List[Variable]):\n        self._variables = UuidList(self._uuid, value)\n\n    def add_variable(self, name: str, variable_id: int = -1) -&gt; Variable:\n        \"\"\"\n        Adds a variable.\n\n        Args:\n            name: The name for the variable\n            variable_id: The ID of the variable. If left empty lowest available value will be used\n\n        Returns:\n            The newly renamed Variable\n        \"\"\"\n        list_of_var_ids = [var.variable_id for var in self.variables]\n        if variable_id == -1:\n            for i in range(256):\n                if i not in list_of_var_ids:\n                    variable_id = i\n                    break\n            if variable_id == -1:\n                raise IndexError(f\"No variable ID available. All in use? In use: ({list_of_var_ids}/256)\")\n        if not (0 &lt;= variable_id &lt;= 255):\n            raise ValueError(\"Variable ID has to fall between 0 and 255 (incl).\")\n        if variable_id in list_of_var_ids:\n            raise ValueError(\"Variable ID already in use.\")\n\n        new_variable = Variable(variable_id=variable_id, name=name, uuid=self._uuid)\n        self.variables.append(new_variable)\n        return new_variable\n\n    def get_variable(self, variable_id: int = None, variable_name: str = None) -&gt; Optional[Variable]:\n        \"\"\"\n        Get a specific variable\n\n        Args:\n            variable_id: The ID of the variable you want\n            variable_name: The name of the variable you want\n\n        Returns:\n            The `Variable` object or None if it couldn't be found\n        \"\"\"\n        if not mutually_exclusive(variable_id is not None, variable_name is not None):\n            raise ValueError(\"Select a variable using either the variable_id or variable_name parameters.\")\n        for variable in self.variables:\n            if variable.variable_id == variable_id or variable.name == variable_name:\n                return variable\n        return None\n\n    def get_summary_as_string(self) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing a summary of the content of the manager.\n        This includes all triggers and the amount of conditions and effects they hold and also all renamed variables.\n\n        Returns:\n            The created string\n        \"\"\"\n        return_string = super().get_summary_as_string()\n\n        return_string += \"\\nVariables Summary:\\n\"\n        if len(self.variables) == 0:\n            return_string += \"\\t&lt;&lt; No Variables &gt;&gt;\"\n\n        longest_variable_name = -1\n        for variable in self.variables:\n            longest_variable_name = max(longest_variable_name, len(variable.name))\n\n        longest_variable_name += 3\n        for index, variable in enumerate(self.variables):\n            var_name = variable.name\n            name_buffer = \" \" * (longest_variable_name - len(var_name))\n            return_string += f\"\\t{var_name}{name_buffer}[Index: {variable.variable_id}]\\n\"\n\n        return return_string\n\n    def get_content_as_string(self) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing all content of the manager.\n        This includes all triggers and their conditions and effects and also all renamed variables.\n\n        This is also the function that is called when doing: `print(trigger_manager)`\n\n        Returns:\n            The created string\n        \"\"\"\n        return_string = super().get_content_as_string()\n\n        return_string += \"Variables:\\n\"\n\n        if len(self.variables) == 0:\n            return_string += \"\\t&lt;&lt;No Variables&gt;&gt;\\n\"\n\n        for variable in self.variables:\n            return_string += f\"\\t'{variable.name}' [Index: {variable.variable_id}] ({variable._uuid})\\n\"\n\n        return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.variables","title":"<code>variables: List[Variable]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[Variable]</code> <p>All currently renamed variables</p>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>triggers</code> <code>List[Trigger]</code>  - required <code>trigger_display_order</code> <code>List[int]</code>  - required <code>variables</code> <code>List[Variable]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>def __init__(self, triggers: List[Trigger], trigger_display_order: List[int], variables: List[Variable], **kwargs):\n    super().__init__(triggers, trigger_display_order, **kwargs)\n\n    self.variables: List[Variable] = variables\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.add_variable","title":"<code>def add_variable(...)</code>","text":"<p>Adds a variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the variable</p> required <code>variable_id</code> <code>int</code> <p>The ID of the variable. If left empty lowest available value will be used</p> <code>-1</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The newly renamed Variable</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>def add_variable(self, name: str, variable_id: int = -1) -&gt; Variable:\n    \"\"\"\n    Adds a variable.\n\n    Args:\n        name: The name for the variable\n        variable_id: The ID of the variable. If left empty lowest available value will be used\n\n    Returns:\n        The newly renamed Variable\n    \"\"\"\n    list_of_var_ids = [var.variable_id for var in self.variables]\n    if variable_id == -1:\n        for i in range(256):\n            if i not in list_of_var_ids:\n                variable_id = i\n                break\n        if variable_id == -1:\n            raise IndexError(f\"No variable ID available. All in use? In use: ({list_of_var_ids}/256)\")\n    if not (0 &lt;= variable_id &lt;= 255):\n        raise ValueError(\"Variable ID has to fall between 0 and 255 (incl).\")\n    if variable_id in list_of_var_ids:\n        raise ValueError(\"Variable ID already in use.\")\n\n    new_variable = Variable(variable_id=variable_id, name=name, uuid=self._uuid)\n    self.variables.append(new_variable)\n    return new_variable\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.get_content_as_string","title":"<code>def get_content_as_string(...)</code>","text":"<p>Create a human-readable string showcasing all content of the manager. This includes all triggers and their conditions and effects and also all renamed variables.</p> <p>This is also the function that is called when doing: <code>print(trigger_manager)</code></p> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>def get_content_as_string(self) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing all content of the manager.\n    This includes all triggers and their conditions and effects and also all renamed variables.\n\n    This is also the function that is called when doing: `print(trigger_manager)`\n\n    Returns:\n        The created string\n    \"\"\"\n    return_string = super().get_content_as_string()\n\n    return_string += \"Variables:\\n\"\n\n    if len(self.variables) == 0:\n        return_string += \"\\t&lt;&lt;No Variables&gt;&gt;\\n\"\n\n    for variable in self.variables:\n        return_string += f\"\\t'{variable.name}' [Index: {variable.variable_id}] ({variable._uuid})\\n\"\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.get_summary_as_string","title":"<code>def get_summary_as_string(...)</code>","text":"<p>Create a human-readable string showcasing a summary of the content of the manager. This includes all triggers and the amount of conditions and effects they hold and also all renamed variables.</p> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>def get_summary_as_string(self) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing a summary of the content of the manager.\n    This includes all triggers and the amount of conditions and effects they hold and also all renamed variables.\n\n    Returns:\n        The created string\n    \"\"\"\n    return_string = super().get_summary_as_string()\n\n    return_string += \"\\nVariables Summary:\\n\"\n    if len(self.variables) == 0:\n        return_string += \"\\t&lt;&lt; No Variables &gt;&gt;\"\n\n    longest_variable_name = -1\n    for variable in self.variables:\n        longest_variable_name = max(longest_variable_name, len(variable.name))\n\n    longest_variable_name += 3\n    for index, variable in enumerate(self.variables):\n        var_name = variable.name\n        name_buffer = \" \" * (longest_variable_name - len(var_name))\n        return_string += f\"\\t{var_name}{name_buffer}[Index: {variable.variable_id}]\\n\"\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de.TriggerManagerDE.get_variable","title":"<code>def get_variable(...)</code>","text":"<p>Get a specific variable</p> <p>Parameters:</p> Name Type Description Default <code>variable_id</code> <code>int</code> <p>The ID of the variable you want</p> <code>None</code> <code>variable_name</code> <code>str</code> <p>The name of the variable you want</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Variable]</code> <p>The <code>Variable</code> object or None if it couldn't be found</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/trigger_manager_de.py</code> <pre><code>def get_variable(self, variable_id: int = None, variable_name: str = None) -&gt; Optional[Variable]:\n    \"\"\"\n    Get a specific variable\n\n    Args:\n        variable_id: The ID of the variable you want\n        variable_name: The name of the variable you want\n\n    Returns:\n        The `Variable` object or None if it couldn't be found\n    \"\"\"\n    if not mutually_exclusive(variable_id is not None, variable_name is not None):\n        raise ValueError(\"Select a variable using either the variable_id or variable_name parameters.\")\n    for variable in self.variables:\n        if variable.variable_id == variable_id or variable.name == variable_name:\n            return variable\n    return None\n</code></pre>"},{"location":"api_docs/trigger/trigger_manager_de/#AoE2ScenarioParser.objects.managers.de.trigger_manager_de-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_select/","title":"TriggerSelect","text":""},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TS","title":"<code>TS: Type[TriggerSelect] = TriggerSelect</code>  <code>module-attribute</code>","text":"Type: <code>Type[TriggerSelect]</code>                           Value: <code>TriggerSelect</code> <p>Alias for <code>TriggerSelect</code></p>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select-classes","title":"Classes","text":""},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect","title":"<code>TriggerSelect</code>","text":"<p>Object used to select a trigger in many trigger related functions. For ease of use, the alias <code>TS</code> can be called. You can also use those in combination with the class methods (factory methods). Like so:</p> Selecting a trigger by its ID doesn't require this object <p>Most functions allow you to just input <code>4</code> into the trigger_select parameter (instead of: <code>TS.index(4)</code>)</p> <p>Examples:</p> <p><code>TS.index(4)</code>  To select the trigger with index 4</p> <p><code>TS.display(4)</code>  Trigger with display index 4</p> <p><code>TS.trigger(trigger)</code>  Well... The trigger object given...</p> Source code in <code>AoE2ScenarioParser/objects/support/trigger_select.py</code> <pre><code>class TriggerSelect:\n    \"\"\"\n    Object used to select a trigger in many trigger related functions. For ease of use, the alias `TS` can be\n    called. You can also use those in combination with the class methods (factory methods). Like so:\n\n    Tip: Selecting a trigger by its ID doesn't require this object\n        Most functions allow you to just input `4` into the trigger_select parameter (instead of: `TS.index(4)`)\n\n    Examples:\n        `TS.index(4)`  To select the trigger with index 4\n\n        `TS.display(4)`  Trigger with display index 4\n\n        `TS.trigger(trigger)`  Well... The trigger object given...\n    \"\"\"\n    def __init__(self, trigger_index: int = None, display_index: int = None, trigger: Trigger = None):\n        \"\"\"\n        Args:\n            trigger_index: The index of the trigger. Starting from 0, based on creation time\n            display_index: The display index of a trigger. Starting from 0, based on display order in the editor\n            trigger: The trigger object itself.\n        \"\"\"\n        self.trigger = trigger\n        self.display_index = display_index\n        self.trigger_index = trigger_index\n\n    @classmethod\n    def index(cls, index: int):\n        return cls(trigger_index=index)\n\n    @classmethod\n    def display(cls, display_index: int):\n        return cls(display_index=display_index)\n\n    @classmethod\n    def trigger(cls, trigger: Trigger):\n        return cls(trigger=trigger)\n</code></pre>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.display_index","title":"<code>display_index = display_index</code>  <code>instance-attribute</code>","text":"Value: <code>display_index</code>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.trigger_index","title":"<code>trigger_index = trigger_index</code>  <code>instance-attribute</code>","text":"Value: <code>trigger_index</code>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect-functions","title":"Functions","text":""},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger_index</code> <code>int</code> <p>The index of the trigger. Starting from 0, based on creation time</p> <code>None</code> <code>display_index</code> <code>int</code> <p>The display index of a trigger. Starting from 0, based on display order in the editor</p> <code>None</code> <code>trigger</code> <code>Trigger</code> <p>The trigger object itself.</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/trigger_select.py</code> <pre><code>def __init__(self, trigger_index: int = None, display_index: int = None, trigger: Trigger = None):\n    \"\"\"\n    Args:\n        trigger_index: The index of the trigger. Starting from 0, based on creation time\n        display_index: The display index of a trigger. Starting from 0, based on display order in the editor\n        trigger: The trigger object itself.\n    \"\"\"\n    self.trigger = trigger\n    self.display_index = display_index\n    self.trigger_index = trigger_index\n</code></pre>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.display","title":"<code>def display(...)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>display_index</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/trigger_select.py</code> <pre><code>@classmethod\ndef display(cls, display_index: int):\n    return cls(display_index=display_index)\n</code></pre>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.index","title":"<code>def index(...)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/trigger_select.py</code> <pre><code>@classmethod\ndef index(cls, index: int):\n    return cls(trigger_index=index)\n</code></pre>"},{"location":"api_docs/trigger/trigger_select/#AoE2ScenarioParser.objects.support.trigger_select.TriggerSelect.trigger","title":"<code>def trigger(...)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger</code> <code>Trigger</code>  - required Source code in <code>AoE2ScenarioParser/objects/support/trigger_select.py</code> <pre><code>@classmethod\ndef trigger(cls, trigger: Trigger):\n    return cls(trigger=trigger)\n</code></pre>"},{"location":"api_docs/trigger/variable/","title":"Variable","text":""},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable-classes","title":"Classes","text":""},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Object for handling a variable.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/variable.py</code> <pre><code>class Variable(AoE2Object):\n    \"\"\"Object for handling a variable.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Triggers\", \"variable_data[__index__]\", group=[\n            RetrieverObjectLink(\"variable_id\"),\n            RetrieverObjectLink(\"name\", link=\"variable_name\"),\n        ])\n    ]\n\n    def __init__(self, variable_id: int, name: str, **kwargs):\n        self.variable_id = variable_id\n        self.name = name\n\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":"Value: <code>name</code>"},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable.variable_id","title":"<code>variable_id = variable_id</code>  <code>instance-attribute</code>","text":"Value: <code>variable_id</code>"},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable-functions","title":"Functions","text":""},{"location":"api_docs/trigger/variable/#AoE2ScenarioParser.objects.data_objects.variable.Variable.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>variable_id</code> <code>int</code>  - required <code>name</code> <code>str</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/variable.py</code> <pre><code>def __init__(self, variable_id: int, name: str, **kwargs):\n    self.variable_id = variable_id\n    self.name = name\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"api_docs/trigger/conditions/condition/","title":"Condition","text":""},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition-classes","title":"Classes","text":""},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition","title":"<code>Condition</code>","text":"<p>               Bases: <code>AoE2Object</code>, <code>TriggerComponent</code></p> <p>Object for handling a condition.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/condition.py</code> <pre><code>class Condition(AoE2Object, TriggerComponent):\n    \"\"\"Object for handling a condition.\"\"\"\n    hidden_attribute = 'condition_type'\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Triggers\", \"trigger_data[__index__].condition_data[__index__]\", group=[\n            RetrieverObjectLink(\"condition_type\"),\n            RetrieverObjectLink(\"quantity\"),\n            RetrieverObjectLink(\"attribute\"),\n            RetrieverObjectLink(\"unit_object\"),\n            RetrieverObjectLink(\"next_object\"),\n            RetrieverObjectLink(\"object_list\"),\n            RetrieverObjectLink(\"source_player\"),\n            RetrieverObjectLink(\"technology\"),\n            RetrieverObjectLink(\"timer\"),\n            RetrieverObjectLink(\"area_x1\"),\n            RetrieverObjectLink(\"area_y1\"),\n            RetrieverObjectLink(\"area_x2\"),\n            RetrieverObjectLink(\"area_y2\"),\n            RetrieverObjectLink(\"object_group\"),\n            RetrieverObjectLink(\"object_type\"),\n            RetrieverObjectLink(\"ai_signal\"),\n            RetrieverObjectLink(\"inverted\"),\n            RetrieverObjectLink(\"variable\"),\n            RetrieverObjectLink(\"comparison\"),\n            RetrieverObjectLink(\"target_player\"),\n            RetrieverObjectLink(\"unit_ai_action\", support=Support(since=1.40)),\n            RetrieverObjectLink(\"object_state\", support=Support(since=1.42)),\n            RetrieverObjectLink(\"timer_id\", support=Support(since=1.46)),\n            RetrieverObjectLink(\"victory_timer_type\", support=Support(since=1.46)),\n            RetrieverObjectLink(\"include_changeable_weapon_objects\", support=Support(since=1.46)),\n            RetrieverObjectLink(\"xs_function\", support=Support(since=1.40)),\n        ])\n    ]\n\n    def __init__(\n            self,\n            condition_type: int = None,\n            quantity: int = None,\n            attribute: int = None,\n            unit_object: int = None,\n            next_object: int = None,\n            object_list: int = None,\n            source_player: int | IntEnum = None,\n            technology: int | IntEnum = None,\n            timer: int = None,\n            area_x1: int = None,\n            area_y1: int = None,\n            area_x2: int = None,\n            area_y2: int = None,\n            object_group: int = None,\n            object_type: int = None,\n            ai_signal: int = None,\n            inverted: int = None,\n            variable: int = None,\n            comparison: int = None,\n            target_player: int | IntEnum = None,\n            unit_ai_action: int = None,\n            object_state: int = None,\n            timer_id: int = None,\n            victory_timer_type: int = None,\n            include_changeable_weapon_objects: int = None,\n            xs_function: str = None,\n            **kwargs\n    ):\n        raise_if_not_int_subclass([object_list, technology])\n        area_x1, area_y1, area_x2, area_y2 = validate_coords(area_x1, area_y1, area_x2, area_y2)\n\n        self.condition_type: int = condition_type\n        self.quantity: int = quantity\n        self.attribute: int = attribute\n        self.unit_object: int = unit_object\n        self.next_object: int = next_object\n        self.object_list: int = object_list\n        self.source_player: int = source_player\n        self.technology: int = technology\n        self.timer: int = timer\n        self.area_x1: int = area_x1\n        self.area_y1: int = area_y1\n        self.area_x2: int = area_x2\n        self.area_y2: int = area_y2\n        self.object_group: int = object_group\n        self.object_type: int = object_type\n        self.ai_signal: int = ai_signal\n        self.inverted: int = inverted\n        self.variable: int = variable\n        self.comparison: int = comparison\n        self.target_player: int = target_player\n        self.unit_ai_action: int = unit_ai_action\n        self.object_state: int = object_state\n        self.timer_id: int = timer_id\n        self.victory_timer_type: int = victory_timer_type\n        self.include_changeable_weapon_objects: int = include_changeable_weapon_objects\n        self.xs_function: str = xs_function\n\n        super().__init__(**kwargs)\n\n    def _should_be_displayed(self, attr: str, val: Any) -&gt; bool:\n        # Include the only exception to the -1 == invalid rule\n        if self.condition_type == ConditionId.DIFFICULTY_LEVEL and attr == 'quantity' and val == -1:\n            return True\n\n        return super()._should_be_displayed(attr, val)\n\n    def get_content_as_string(self, include_condition_definition: bool = False) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing all content of this condition.\n\n        This is also the function that is called when doing: `print(condition)`\n\n        Args:\n            include_condition_definition: If the condition meta-data should be added by this function\n\n        Returns:\n            The created string\n        \"\"\"\n        if self.condition_type not in conditions.attributes:\n            attributes_list = conditions.empty_attributes\n        else:\n            attributes_list = conditions.attributes[self.condition_type]\n\n        return_string = \"\"\n        for attribute in attributes_list:\n            val = getattr(self, attribute)\n            if not self._should_be_displayed(attribute, val):\n                continue\n\n            value_string = transform_condition_attr_value(self.condition_type, attribute, val, self._uuid)\n            return_string += f\"{attribute}: {value_string}\\n\"\n\n        if return_string == \"\":\n            return \"&lt;&lt; No Attributes &gt;&gt;\\n\"\n\n        if include_condition_definition:\n            return f\"{conditions.condition_names[self.condition_type]}:\\n{add_tabs(return_string, 1)}\"\n\n        return return_string\n\n    def __str__(self):\n        return f\"[Condition] {self.get_content_as_string(include_condition_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.ai_signal","title":"<code>ai_signal: int = ai_signal</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>ai_signal</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.area_x1","title":"<code>area_x1: int = area_x1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_x1</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.area_x2","title":"<code>area_x2: int = area_x2</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_x2</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.area_y1","title":"<code>area_y1: int = area_y1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_y1</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.area_y2","title":"<code>area_y2: int = area_y2</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_y2</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.attribute","title":"<code>attribute: int = attribute</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>attribute</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.comparison","title":"<code>comparison: int = comparison</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>comparison</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.condition_type","title":"<code>condition_type: int = condition_type</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>condition_type</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.hidden_attribute","title":"<code>hidden_attribute = 'condition_type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'condition_type'</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.include_changeable_weapon_objects","title":"<code>include_changeable_weapon_objects: int = include_changeable_weapon_objects</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>include_changeable_weapon_objects</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.inverted","title":"<code>inverted: int = inverted</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>inverted</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.next_object","title":"<code>next_object: int = next_object</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>next_object</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.object_group","title":"<code>object_group: int = object_group</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_group</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.object_list","title":"<code>object_list: int = object_list</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_list</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.object_state","title":"<code>object_state: int = object_state</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_state</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.object_type","title":"<code>object_type: int = object_type</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_type</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.quantity","title":"<code>quantity: int = quantity</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>quantity</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.source_player","title":"<code>source_player: int = source_player</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>source_player</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.target_player","title":"<code>target_player: int = target_player</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>target_player</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.technology","title":"<code>technology: int = technology</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>technology</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.timer","title":"<code>timer: int = timer</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>timer</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.timer_id","title":"<code>timer_id: int = timer_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>timer_id</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.unit_ai_action","title":"<code>unit_ai_action: int = unit_ai_action</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>unit_ai_action</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.unit_object","title":"<code>unit_object: int = unit_object</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>unit_object</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.variable","title":"<code>variable: int = variable</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>variable</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.victory_timer_type","title":"<code>victory_timer_type: int = victory_timer_type</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>victory_timer_type</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.xs_function","title":"<code>xs_function: str = xs_function</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>xs_function</code>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition-functions","title":"Functions","text":""},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>condition_type</code> <code>int</code>  - <code>None</code> <code>quantity</code> <code>int</code>  - <code>None</code> <code>attribute</code> <code>int</code>  - <code>None</code> <code>unit_object</code> <code>int</code>  - <code>None</code> <code>next_object</code> <code>int</code>  - <code>None</code> <code>object_list</code> <code>int</code>  - <code>None</code> <code>source_player</code> <code>int | IntEnum</code>  - <code>None</code> <code>technology</code> <code>int | IntEnum</code>  - <code>None</code> <code>timer</code> <code>int</code>  - <code>None</code> <code>area_x1</code> <code>int</code>  - <code>None</code> <code>area_y1</code> <code>int</code>  - <code>None</code> <code>area_x2</code> <code>int</code>  - <code>None</code> <code>area_y2</code> <code>int</code>  - <code>None</code> <code>object_group</code> <code>int</code>  - <code>None</code> <code>object_type</code> <code>int</code>  - <code>None</code> <code>ai_signal</code> <code>int</code>  - <code>None</code> <code>inverted</code> <code>int</code>  - <code>None</code> <code>variable</code> <code>int</code>  - <code>None</code> <code>comparison</code> <code>int</code>  - <code>None</code> <code>target_player</code> <code>int | IntEnum</code>  - <code>None</code> <code>unit_ai_action</code> <code>int</code>  - <code>None</code> <code>object_state</code> <code>int</code>  - <code>None</code> <code>timer_id</code> <code>int</code>  - <code>None</code> <code>victory_timer_type</code> <code>int</code>  - <code>None</code> <code>include_changeable_weapon_objects</code> <code>int</code>  - <code>None</code> <code>xs_function</code> <code>str</code>  - <code>None</code> <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/condition.py</code> <pre><code>def __init__(\n        self,\n        condition_type: int = None,\n        quantity: int = None,\n        attribute: int = None,\n        unit_object: int = None,\n        next_object: int = None,\n        object_list: int = None,\n        source_player: int | IntEnum = None,\n        technology: int | IntEnum = None,\n        timer: int = None,\n        area_x1: int = None,\n        area_y1: int = None,\n        area_x2: int = None,\n        area_y2: int = None,\n        object_group: int = None,\n        object_type: int = None,\n        ai_signal: int = None,\n        inverted: int = None,\n        variable: int = None,\n        comparison: int = None,\n        target_player: int | IntEnum = None,\n        unit_ai_action: int = None,\n        object_state: int = None,\n        timer_id: int = None,\n        victory_timer_type: int = None,\n        include_changeable_weapon_objects: int = None,\n        xs_function: str = None,\n        **kwargs\n):\n    raise_if_not_int_subclass([object_list, technology])\n    area_x1, area_y1, area_x2, area_y2 = validate_coords(area_x1, area_y1, area_x2, area_y2)\n\n    self.condition_type: int = condition_type\n    self.quantity: int = quantity\n    self.attribute: int = attribute\n    self.unit_object: int = unit_object\n    self.next_object: int = next_object\n    self.object_list: int = object_list\n    self.source_player: int = source_player\n    self.technology: int = technology\n    self.timer: int = timer\n    self.area_x1: int = area_x1\n    self.area_y1: int = area_y1\n    self.area_x2: int = area_x2\n    self.area_y2: int = area_y2\n    self.object_group: int = object_group\n    self.object_type: int = object_type\n    self.ai_signal: int = ai_signal\n    self.inverted: int = inverted\n    self.variable: int = variable\n    self.comparison: int = comparison\n    self.target_player: int = target_player\n    self.unit_ai_action: int = unit_ai_action\n    self.object_state: int = object_state\n    self.timer_id: int = timer_id\n    self.victory_timer_type: int = victory_timer_type\n    self.include_changeable_weapon_objects: int = include_changeable_weapon_objects\n    self.xs_function: str = xs_function\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.__str__","title":"<code>def __str__(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/data_objects/condition.py</code> <pre><code>def __str__(self):\n    return f\"[Condition] {self.get_content_as_string(include_condition_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition.Condition.get_content_as_string","title":"<code>def get_content_as_string(...)</code>","text":"<p>Create a human-readable string showcasing all content of this condition.</p> <p>This is also the function that is called when doing: <code>print(condition)</code></p> <p>Parameters:</p> Name Type Description Default <code>include_condition_definition</code> <code>bool</code> <p>If the condition meta-data should be added by this function</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/condition.py</code> <pre><code>def get_content_as_string(self, include_condition_definition: bool = False) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing all content of this condition.\n\n    This is also the function that is called when doing: `print(condition)`\n\n    Args:\n        include_condition_definition: If the condition meta-data should be added by this function\n\n    Returns:\n        The created string\n    \"\"\"\n    if self.condition_type not in conditions.attributes:\n        attributes_list = conditions.empty_attributes\n    else:\n        attributes_list = conditions.attributes[self.condition_type]\n\n    return_string = \"\"\n    for attribute in attributes_list:\n        val = getattr(self, attribute)\n        if not self._should_be_displayed(attribute, val):\n            continue\n\n        value_string = transform_condition_attr_value(self.condition_type, attribute, val, self._uuid)\n        return_string += f\"{attribute}: {value_string}\\n\"\n\n    if return_string == \"\":\n        return \"&lt;&lt; No Attributes &gt;&gt;\\n\"\n\n    if include_condition_definition:\n        return f\"{conditions.condition_names[self.condition_type]}:\\n{add_tabs(return_string, 1)}\"\n\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition-functions","title":"Functions","text":""},{"location":"api_docs/trigger/conditions/condition/#AoE2ScenarioParser.objects.data_objects.condition-modules","title":"Modules","text":""},{"location":"api_docs/trigger/conditions/new_condition/","title":"NewCondition","text":""},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition-classes","title":"Classes","text":""},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport","title":"<code>NewConditionSupport</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>class NewConditionSupport:\n    def __init__(self, trigger_ref):\n        self._trigger_ref = trigger_ref\n\n    def none(\n            self,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.NONE,\n        )\n\n    def bring_object_to_area(\n            self,\n            unit_object: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.BRING_OBJECT_TO_AREA,\n            unit_object=unit_object,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            inverted=inverted,\n        )\n\n    def bring_object_to_object(\n            self,\n            unit_object: int | None = None,\n            next_object: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.BRING_OBJECT_TO_OBJECT,\n            unit_object=unit_object,\n            next_object=next_object,\n            inverted=inverted,\n        )\n\n    def own_objects(\n            self,\n            quantity: int | None = None,\n            object_list: int | None = None,\n            source_player: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            include_changeable_weapon_objects: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OWN_OBJECTS,\n            quantity=quantity,\n            object_list=object_list,\n            source_player=source_player,\n            object_group=object_group,\n            object_type=object_type,\n            include_changeable_weapon_objects=include_changeable_weapon_objects,\n        )\n\n    def own_fewer_objects(\n            self,\n            quantity: int | None = None,\n            object_list: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            include_changeable_weapon_objects: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OWN_FEWER_OBJECTS,\n            quantity=quantity,\n            object_list=object_list,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            include_changeable_weapon_objects=include_changeable_weapon_objects,\n        )\n\n    def objects_in_area(\n            self,\n            quantity: int | None = None,\n            object_list: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            inverted: int | None = None,\n            object_state: int | None = None,\n            include_changeable_weapon_objects: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECTS_IN_AREA,\n            quantity=quantity,\n            object_list=object_list,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            inverted=inverted,\n            object_state=object_state,\n            include_changeable_weapon_objects=include_changeable_weapon_objects,\n        )\n\n    def destroy_object(\n            self,\n            unit_object: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.DESTROY_OBJECT,\n            unit_object=unit_object,\n            inverted=inverted,\n        )\n\n    def capture_object(\n            self,\n            unit_object: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.CAPTURE_OBJECT,\n            unit_object=unit_object,\n            source_player=source_player,\n            inverted=inverted,\n        )\n\n    def accumulate_attribute(\n            self,\n            quantity: int | None = None,\n            attribute: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.ACCUMULATE_ATTRIBUTE,\n            quantity=quantity,\n            attribute=attribute,\n            source_player=source_player,\n            inverted=inverted,\n        )\n\n    def research_technology(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.RESEARCH_TECHNOLOGY,\n            source_player=source_player,\n            technology=technology,\n            inverted=inverted,\n        )\n\n    def timer(\n            self,\n            timer: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.TIMER,\n            timer=timer,\n            inverted=inverted,\n        )\n\n    def object_selected(\n            self,\n            unit_object: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_SELECTED,\n            unit_object=unit_object,\n            inverted=inverted,\n        )\n\n    def ai_signal(\n            self,\n            ai_signal: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.AI_SIGNAL,\n            ai_signal=ai_signal,\n            inverted=inverted,\n        )\n\n    def player_defeated(\n            self,\n            source_player: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.PLAYER_DEFEATED,\n            source_player=source_player,\n            inverted=inverted,\n        )\n\n    def object_has_target(\n            self,\n            unit_object: int | None = None,\n            next_object: int | None = None,\n            object_list: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_HAS_TARGET,\n            unit_object=unit_object,\n            next_object=next_object,\n            object_list=object_list,\n            object_group=object_group,\n            object_type=object_type,\n            inverted=inverted,\n        )\n\n    def object_visible(\n            self,\n            unit_object: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_VISIBLE,\n            unit_object=unit_object,\n        )\n\n    def object_not_visible(\n            self,\n            unit_object: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_NOT_VISIBLE,\n            unit_object=unit_object,\n        )\n\n    def researching_tech(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.RESEARCHING_TECH,\n            source_player=source_player,\n            technology=technology,\n            inverted=inverted,\n        )\n\n    def units_garrisoned(\n            self,\n            quantity: int | None = None,\n            unit_object: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.UNITS_GARRISONED,\n            quantity=quantity,\n            unit_object=unit_object,\n            inverted=inverted,\n        )\n\n    def difficulty_level(\n            self,\n            quantity: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.DIFFICULTY_LEVEL,\n            quantity=quantity,\n            inverted=inverted,\n        )\n\n    def chance(\n            self,\n            quantity: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.CHANCE,\n            quantity=quantity,\n        )\n\n    def technology_state(\n            self,\n            quantity: int | None = None,\n            source_player: int | None = None,\n            technology: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.TECHNOLOGY_STATE,\n            quantity=quantity,\n            source_player=source_player,\n            technology=technology,\n            inverted=inverted,\n        )\n\n    def variable_value(\n            self,\n            quantity: int | None = None,\n            inverted: int | None = None,\n            variable: int | None = None,\n            comparison: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.VARIABLE_VALUE,\n            quantity=quantity,\n            inverted=inverted,\n            variable=variable,\n            comparison=comparison,\n        )\n\n    def object_hp(\n            self,\n            quantity: int | None = None,\n            unit_object: int | None = None,\n            inverted: int | None = None,\n            comparison: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_HP,\n            quantity=quantity,\n            unit_object=unit_object,\n            inverted=inverted,\n            comparison=comparison,\n        )\n\n    def diplomacy_state(\n            self,\n            quantity: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n            target_player: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.DIPLOMACY_STATE,\n            quantity=quantity,\n            source_player=source_player,\n            inverted=inverted,\n            target_player=target_player,\n        )\n\n    def script_call(\n            self,\n            xs_function: str | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.SCRIPT_CALL,\n            xs_function=xs_function,\n        )\n\n    def object_visible_multiplayer(\n            self,\n            unit_object: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_VISIBLE_MULTIPLAYER,\n            unit_object=unit_object,\n            source_player=source_player,\n            inverted=inverted,\n        )\n\n    def object_selected_multiplayer(\n            self,\n            unit_object: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_SELECTED_MULTIPLAYER,\n            unit_object=unit_object,\n            source_player=source_player,\n            inverted=inverted,\n        )\n\n    def object_has_action(\n            self,\n            unit_object: int | None = None,\n            next_object: int | None = None,\n            object_list: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            inverted: int | None = None,\n            unit_ai_action: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OBJECT_HAS_ACTION,\n            unit_object=unit_object,\n            next_object=next_object,\n            object_list=object_list,\n            object_group=object_group,\n            object_type=object_type,\n            inverted=inverted,\n            unit_ai_action=unit_ai_action,\n        )\n\n    def or_(\n            self,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.OR,\n        )\n\n    def ai_signal_multiplayer(\n            self,\n            ai_signal: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.AI_SIGNAL_MULTIPLAYER,\n            ai_signal=ai_signal,\n            inverted=inverted,\n        )\n\n    def and_(\n            self,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.AND,\n        )\n\n    def building_is_trading(\n            self,\n            unit_object: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.BUILDING_IS_TRADING,\n            unit_object=unit_object,\n            inverted=inverted,\n        )\n\n    def display_timer_triggered(\n            self,\n            timer_id: int | None = None,\n            inverted: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.DISPLAY_TIMER_TRIGGERED,\n            timer_id=timer_id,\n            inverted=inverted,\n        )\n\n    def victory_timer(\n            self,\n            quantity: int | None = None,\n            source_player: int | None = None,\n            inverted: int | None = None,\n            comparison: int | None = None,\n            victory_timer_type: int | None = None,\n    ) -&gt; Condition:\n        return self._trigger_ref._add_condition(\n            ConditionId.VICTORY_TIMER,\n            quantity=quantity,\n            source_player=source_player,\n            inverted=inverted,\n            comparison=comparison,\n            victory_timer_type=victory_timer_type,\n        )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport-functions","title":"Functions","text":""},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger_ref</code>                              ?                       - required Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def __init__(self, trigger_ref):\n    self._trigger_ref = trigger_ref\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.accumulate_attribute","title":"<code>def accumulate_attribute(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>attribute</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def accumulate_attribute(\n        self,\n        quantity: int | None = None,\n        attribute: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.ACCUMULATE_ATTRIBUTE,\n        quantity=quantity,\n        attribute=attribute,\n        source_player=source_player,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.ai_signal","title":"<code>def ai_signal(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ai_signal</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def ai_signal(\n        self,\n        ai_signal: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.AI_SIGNAL,\n        ai_signal=ai_signal,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.ai_signal_multiplayer","title":"<code>def ai_signal_multiplayer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ai_signal</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def ai_signal_multiplayer(\n        self,\n        ai_signal: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.AI_SIGNAL_MULTIPLAYER,\n        ai_signal=ai_signal,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.and_","title":"<code>def and_(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def and_(\n        self,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.AND,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.bring_object_to_area","title":"<code>def bring_object_to_area(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def bring_object_to_area(\n        self,\n        unit_object: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.BRING_OBJECT_TO_AREA,\n        unit_object=unit_object,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.bring_object_to_object","title":"<code>def bring_object_to_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>next_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def bring_object_to_object(\n        self,\n        unit_object: int | None = None,\n        next_object: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.BRING_OBJECT_TO_OBJECT,\n        unit_object=unit_object,\n        next_object=next_object,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.building_is_trading","title":"<code>def building_is_trading(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def building_is_trading(\n        self,\n        unit_object: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.BUILDING_IS_TRADING,\n        unit_object=unit_object,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.capture_object","title":"<code>def capture_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def capture_object(\n        self,\n        unit_object: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.CAPTURE_OBJECT,\n        unit_object=unit_object,\n        source_player=source_player,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.chance","title":"<code>def chance(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def chance(\n        self,\n        quantity: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.CHANCE,\n        quantity=quantity,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.destroy_object","title":"<code>def destroy_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def destroy_object(\n        self,\n        unit_object: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.DESTROY_OBJECT,\n        unit_object=unit_object,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.difficulty_level","title":"<code>def difficulty_level(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def difficulty_level(\n        self,\n        quantity: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.DIFFICULTY_LEVEL,\n        quantity=quantity,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.diplomacy_state","title":"<code>def diplomacy_state(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def diplomacy_state(\n        self,\n        quantity: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n        target_player: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.DIPLOMACY_STATE,\n        quantity=quantity,\n        source_player=source_player,\n        inverted=inverted,\n        target_player=target_player,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.display_timer_triggered","title":"<code>def display_timer_triggered(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>timer_id</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def display_timer_triggered(\n        self,\n        timer_id: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.DISPLAY_TIMER_TRIGGERED,\n        timer_id=timer_id,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.none","title":"<code>def none(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def none(\n        self,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.NONE,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_has_action","title":"<code>def object_has_action(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>next_object</code> <code>int | None</code>  - <code>None</code> <code>object_list</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>unit_ai_action</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_has_action(\n        self,\n        unit_object: int | None = None,\n        next_object: int | None = None,\n        object_list: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        inverted: int | None = None,\n        unit_ai_action: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_HAS_ACTION,\n        unit_object=unit_object,\n        next_object=next_object,\n        object_list=object_list,\n        object_group=object_group,\n        object_type=object_type,\n        inverted=inverted,\n        unit_ai_action=unit_ai_action,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_has_target","title":"<code>def object_has_target(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>next_object</code> <code>int | None</code>  - <code>None</code> <code>object_list</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_has_target(\n        self,\n        unit_object: int | None = None,\n        next_object: int | None = None,\n        object_list: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_HAS_TARGET,\n        unit_object=unit_object,\n        next_object=next_object,\n        object_list=object_list,\n        object_group=object_group,\n        object_type=object_type,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_hp","title":"<code>def object_hp(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>comparison</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_hp(\n        self,\n        quantity: int | None = None,\n        unit_object: int | None = None,\n        inverted: int | None = None,\n        comparison: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_HP,\n        quantity=quantity,\n        unit_object=unit_object,\n        inverted=inverted,\n        comparison=comparison,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_not_visible","title":"<code>def object_not_visible(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_not_visible(\n        self,\n        unit_object: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_NOT_VISIBLE,\n        unit_object=unit_object,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_selected","title":"<code>def object_selected(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_selected(\n        self,\n        unit_object: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_SELECTED,\n        unit_object=unit_object,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_selected_multiplayer","title":"<code>def object_selected_multiplayer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_selected_multiplayer(\n        self,\n        unit_object: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_SELECTED_MULTIPLAYER,\n        unit_object=unit_object,\n        source_player=source_player,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_visible","title":"<code>def object_visible(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_visible(\n        self,\n        unit_object: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_VISIBLE,\n        unit_object=unit_object,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.object_visible_multiplayer","title":"<code>def object_visible_multiplayer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def object_visible_multiplayer(\n        self,\n        unit_object: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECT_VISIBLE_MULTIPLAYER,\n        unit_object=unit_object,\n        source_player=source_player,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.objects_in_area","title":"<code>def objects_in_area(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>object_state</code> <code>int | None</code>  - <code>None</code> <code>include_changeable_weapon_objects</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def objects_in_area(\n        self,\n        quantity: int | None = None,\n        object_list: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        inverted: int | None = None,\n        object_state: int | None = None,\n        include_changeable_weapon_objects: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OBJECTS_IN_AREA,\n        quantity=quantity,\n        object_list=object_list,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        inverted=inverted,\n        object_state=object_state,\n        include_changeable_weapon_objects=include_changeable_weapon_objects,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.or_","title":"<code>def or_(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def or_(\n        self,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OR,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.own_fewer_objects","title":"<code>def own_fewer_objects(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>include_changeable_weapon_objects</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def own_fewer_objects(\n        self,\n        quantity: int | None = None,\n        object_list: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        include_changeable_weapon_objects: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OWN_FEWER_OBJECTS,\n        quantity=quantity,\n        object_list=object_list,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        include_changeable_weapon_objects=include_changeable_weapon_objects,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.own_objects","title":"<code>def own_objects(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>include_changeable_weapon_objects</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def own_objects(\n        self,\n        quantity: int | None = None,\n        object_list: int | None = None,\n        source_player: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        include_changeable_weapon_objects: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.OWN_OBJECTS,\n        quantity=quantity,\n        object_list=object_list,\n        source_player=source_player,\n        object_group=object_group,\n        object_type=object_type,\n        include_changeable_weapon_objects=include_changeable_weapon_objects,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.player_defeated","title":"<code>def player_defeated(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def player_defeated(\n        self,\n        source_player: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.PLAYER_DEFEATED,\n        source_player=source_player,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.research_technology","title":"<code>def research_technology(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def research_technology(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.RESEARCH_TECHNOLOGY,\n        source_player=source_player,\n        technology=technology,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.researching_tech","title":"<code>def researching_tech(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def researching_tech(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.RESEARCHING_TECH,\n        source_player=source_player,\n        technology=technology,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.script_call","title":"<code>def script_call(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>xs_function</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def script_call(\n        self,\n        xs_function: str | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.SCRIPT_CALL,\n        xs_function=xs_function,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.technology_state","title":"<code>def technology_state(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def technology_state(\n        self,\n        quantity: int | None = None,\n        source_player: int | None = None,\n        technology: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.TECHNOLOGY_STATE,\n        quantity=quantity,\n        source_player=source_player,\n        technology=technology,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.timer","title":"<code>def timer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>timer</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def timer(\n        self,\n        timer: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.TIMER,\n        timer=timer,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.units_garrisoned","title":"<code>def units_garrisoned(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>unit_object</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def units_garrisoned(\n        self,\n        quantity: int | None = None,\n        unit_object: int | None = None,\n        inverted: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.UNITS_GARRISONED,\n        quantity=quantity,\n        unit_object=unit_object,\n        inverted=inverted,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.variable_value","title":"<code>def variable_value(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>variable</code> <code>int | None</code>  - <code>None</code> <code>comparison</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def variable_value(\n        self,\n        quantity: int | None = None,\n        inverted: int | None = None,\n        variable: int | None = None,\n        comparison: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.VARIABLE_VALUE,\n        quantity=quantity,\n        inverted=inverted,\n        variable=variable,\n        comparison=comparison,\n    )\n</code></pre>"},{"location":"api_docs/trigger/conditions/new_condition/#AoE2ScenarioParser.objects.support.new_condition.NewConditionSupport.victory_timer","title":"<code>def victory_timer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>inverted</code> <code>int | None</code>  - <code>None</code> <code>comparison</code> <code>int | None</code>  - <code>None</code> <code>victory_timer_type</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_condition.py</code> <pre><code>def victory_timer(\n        self,\n        quantity: int | None = None,\n        source_player: int | None = None,\n        inverted: int | None = None,\n        comparison: int | None = None,\n        victory_timer_type: int | None = None,\n) -&gt; Condition:\n    return self._trigger_ref._add_condition(\n        ConditionId.VICTORY_TIMER,\n        quantity=quantity,\n        source_player=source_player,\n        inverted=inverted,\n        comparison=comparison,\n        victory_timer_type=victory_timer_type,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/effect/","title":"Effect","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect-classes","title":"Classes","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect","title":"<code>Effect</code>","text":"<p>               Bases: <code>AoE2Object</code>, <code>TriggerComponent</code></p> <p>Object for handling an effect.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/effect.py</code> <pre><code>class Effect(AoE2Object, TriggerComponent):\n    \"\"\"Object for handling an effect.\"\"\"\n    hidden_attribute = 'effect_type'\n\n    _link_list = [\n        RetrieverObjectLinkGroup(\"Triggers\", \"trigger_data[__index__].effect_data[__index__]\", group=[\n            RetrieverObjectLink(\"effect_type\"),\n            RetrieverObjectLink(\"ai_script_goal\"),\n            RetrieverObjectLink(\"quantity\"),\n            RetrieverObjectLink(\"tribute_list\"),\n            RetrieverObjectLink(\"diplomacy\"),\n            RetrieverObjectLink(\"legacy_location_object_reference\"),\n            RetrieverObjectLink(\"object_list_unit_id\"),\n            RetrieverObjectLink(\"source_player\"),\n            RetrieverObjectLink(\"target_player\"),\n            RetrieverObjectLink(\"technology\"),\n            RetrieverObjectLink(\"string_id\"),\n            RetrieverObjectLink(\"display_time\"),\n            RetrieverObjectLink(\"trigger_id\"),\n            RetrieverObjectLink(\"location_x\"),\n            RetrieverObjectLink(\"location_y\"),\n            RetrieverObjectLink(\"location_object_reference\"),\n            RetrieverObjectLink(\"area_x1\"),\n            RetrieverObjectLink(\"area_y1\"),\n            RetrieverObjectLink(\"area_x2\"),\n            RetrieverObjectLink(\"area_y2\"),\n            RetrieverObjectLink(\"object_group\"),\n            RetrieverObjectLink(\"object_type\"),\n            RetrieverObjectLink(\"instruction_panel_position\"),\n            RetrieverObjectLink(\"attack_stance\"),\n            RetrieverObjectLink(\"time_unit\"),\n            RetrieverObjectLink(\"enabled\"),\n            RetrieverObjectLink(\"food\"),\n            RetrieverObjectLink(\"wood\"),\n            RetrieverObjectLink(\"stone\"),\n            RetrieverObjectLink(\"gold\"),\n            RetrieverObjectLink(\"item_id\"),\n            RetrieverObjectLink(\"flash_object\"),\n            RetrieverObjectLink(\"force_research_technology\"),\n            RetrieverObjectLink(\"visibility_state\"),\n            RetrieverObjectLink(\"scroll\"),\n            RetrieverObjectLink(\"operation\"),\n            RetrieverObjectLink(\"object_list_unit_id_2\"),\n            RetrieverObjectLink(\"button_location\"),\n            RetrieverObjectLink(\"ai_signal_value\"),\n            RetrieverObjectLink(\"object_attributes\"),\n            RetrieverObjectLink(\"variable\"),\n            RetrieverObjectLink(\"timer\"),\n            RetrieverObjectLink(\"facet\"),\n            RetrieverObjectLink(\"play_sound\"),\n            RetrieverObjectLink(\"player_color\", support=Support(since=1.40)),\n            RetrieverObjectLink(\"color_mood\", support=Support(since=1.42)),\n            RetrieverObjectLink(\"reset_timer\", support=Support(since=1.44)),\n            RetrieverObjectLink(\"object_state\", support=Support(since=1.44)),\n            RetrieverObjectLink(\"action_type\", support=Support(since=1.44)),\n            RetrieverObjectLink(\"message\", commit_callback=_add_trail_if_string_attr_is_used_in_effect),\n            RetrieverObjectLink(\"sound_name\", commit_callback=_add_trail_if_string_attr_is_used_in_effect),\n            RetrieverObjectLink(\"selected_object_ids\"),\n        ])\n    ]\n\n    def __init__(\n            self,\n            effect_type: int = None,\n            ai_script_goal: int = None,\n            armour_attack_quantity: int = None,\n            armour_attack_class: int = None,\n            quantity: int = None,\n            tribute_list: int = None,\n            diplomacy: int = None,\n            legacy_location_object_reference: int = None,\n            object_list_unit_id: int = None,\n            source_player: int = None,\n            target_player: int = None,\n            technology: int = None,\n            string_id: int = None,\n            display_time: int = None,\n            trigger_id: int = None,\n            location_x: int = None,\n            location_y: int = None,\n            location_object_reference: int = None,\n            area_x1: int = None,\n            area_y1: int = None,\n            area_x2: int = None,\n            area_y2: int = None,\n            object_group: int = None,\n            object_type: int = None,\n            instruction_panel_position: int = None,\n            attack_stance: int = None,\n            time_unit: int = None,\n            enabled: int = None,\n            food: int = None,\n            wood: int = None,\n            stone: int = None,\n            gold: int = None,\n            item_id: int = None,  # Unused (?)\n            flash_object: int = None,\n            force_research_technology: int = None,\n            visibility_state: int = None,\n            scroll: int = None,\n            operation: int = None,\n            object_list_unit_id_2: int = None,\n            button_location: int = None,\n            ai_signal_value: int = None,\n            object_attributes: int = None,\n            variable: int = None,\n            timer: int = None,\n            facet: int = None,\n            play_sound: int = None,\n            player_color: int = None,\n            color_mood: int = None,\n            reset_timer: int = None,\n            object_state: int = None,\n            action_type: int = None,\n            message: str = None,\n            sound_name: str = None,\n            selected_object_ids: List[int] = None,\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        raise_if_not_int_subclass([object_list_unit_id, technology, object_list_unit_id_2])\n\n        if selected_object_ids is None:\n            selected_object_ids = []\n\n        # Set flags\n        self._armour_attack_flag = _set_armour_attack_flag(effect_type, object_attributes)\n\n        # Handle armour effect attributes:\n        #   When effect is created through trigger.new_effect, aa values will be -1.\n        #   If created while reading a scenario, they both default to None.\n        if self._armour_attack_flag:\n            # If effect created through reading scenario file\n            if quantity is not None and armour_attack_class is None and armour_attack_quantity is None:\n                armour_attack_class, armour_attack_quantity = self._quantity_to_aa(quantity)\n                quantity = None\n            # If effect created through new_effect with aa values defined\n            elif value_is_valid(armour_attack_class) or value_is_valid(armour_attack_quantity):\n                quantity = None\n            # If created through new_effect with quantity defined instead of the aa values. Handled by quantity property\n            else:\n                pass\n        else:\n            armour_attack_class = armour_attack_quantity = None\n\n        area_x1, area_y1, area_x2, area_y2 = validate_coords(area_x1, area_y1, area_x2, area_y2)\n\n        if value_is_valid(legacy_location_object_reference):\n            location_object_reference = legacy_location_object_reference\n\n        # Bypass the @property which causes: self._update_armour_attack_flag()\n        self._effect_type: int = effect_type\n        self.ai_script_goal: int = ai_script_goal\n        self.armour_attack_quantity: int = armour_attack_quantity\n        self.armour_attack_class: int = armour_attack_class\n        self.quantity: int = quantity\n        self.tribute_list: int = tribute_list\n        self.diplomacy: int = diplomacy\n        self.object_list_unit_id: int = object_list_unit_id\n        self.source_player: int = source_player\n        self.target_player: int = target_player\n        self.technology: int = technology\n        self.string_id: int = string_id\n        self.display_time: int = display_time\n        self.trigger_id: int = trigger_id\n        self.location_x: int = location_x\n        self.location_y: int = location_y\n        self.location_object_reference: int = location_object_reference\n        self.area_x1: int = area_x1\n        self.area_y1: int = area_y1\n        self.area_x2: int = area_x2\n        self.area_y2: int = area_y2\n        self.object_group: int = object_group\n        self.object_type: int = object_type\n        self.instruction_panel_position: int = instruction_panel_position\n        self.attack_stance: int = attack_stance\n        self.time_unit: int = time_unit\n        self.enabled: int = enabled\n        self.food: int = food\n        self.wood: int = wood\n        self.stone: int = stone\n        self.gold: int = gold\n        # self.item_id: int = item_id  # Unused (?)\n        self.flash_object: int = flash_object\n        self.force_research_technology: int = force_research_technology\n        self.visibility_state: int = visibility_state\n        self.scroll: int = scroll\n        self.operation: int = operation\n        self.object_list_unit_id_2: int = object_list_unit_id_2\n        self.button_location: int = button_location\n        self.ai_signal_value: int = ai_signal_value\n        self.object_attributes: int = object_attributes\n        self.variable: int = variable\n        self.timer: int = timer\n        self.facet: int = facet\n        self.play_sound: int = play_sound\n        self.player_color: int = player_color\n        self.color_mood: int = color_mood\n        self.reset_timer = reset_timer\n        self.object_state = object_state\n        self.action_type = action_type\n        self.message: str = message\n        self.sound_name: str = sound_name\n        self.selected_object_ids: List[int] = selected_object_ids\n\n    @property\n    def legacy_location_object_reference(self) -&gt; int:\n        \"\"\"Getter for legacy object_reference location. Always returns `-1`.\"\"\"\n        return -1\n\n    @property\n    def player_color(self):\n        \"\"\"Get the player color attribute\"\"\"\n        return self._player_color\n\n    @player_color.setter\n    def player_color(self, value):\n        if type(value) in [PlayerColorId, PlayerId]:\n            value -= 1\n        self._player_color = value\n\n    @property\n    def item_id(self):\n        \"\"\"Get the currently selected item_id based on other attributes\"\"\"\n        if value_is_valid(self.object_list_unit_id):\n            return self.object_list_unit_id\n        if value_is_valid(self.technology):\n            return self.technology\n        if value_is_valid(self.tribute_list):\n            return self.tribute_list\n        return -1\n\n    @item_id.setter\n    def item_id(self, value):\n        raise ValueError(\"The `item_id` attribute is always equal to its corresponding attribute.\"\n                         \"Please use that attribute (i.e. 'object_list_unit_id' or 'technology' or 'tribute_list').\")\n\n    @property\n    def effect_type(self):\n        \"\"\"The type of the effect (EffectId dataset)\"\"\"\n        return self._effect_type\n\n    @effect_type.setter\n    def effect_type(self, value):\n        self._effect_type = value\n        self._update_armour_attack_flag()\n\n    @property\n    def object_attributes(self):\n        return self._object_attributes\n\n    @object_attributes.setter\n    def object_attributes(self, value):\n        self._object_attributes = value\n        self._update_armour_attack_flag()\n\n    @property\n    def armour_attack_quantity(self):\n        \"\"\"Helper property for handling the armour_attack related values\"\"\"\n        return self._armour_attack_quantity\n\n    @armour_attack_quantity.setter\n    def armour_attack_quantity(self, value):\n        if value is not None and value != [] and not self._armour_attack_flag:\n            warn(\"Setting 'effect.armour_attack_quantity' when the effect doesn't use armour/attack attributes \"\n                 \"might result in unintended behaviour.\", category=IncorrectArmorAttackUsageWarning)\n        self._armour_attack_quantity = value\n\n    @property\n    def armour_attack_class(self):\n        \"\"\"Helper property for handling the armour_attack related values\"\"\"\n        return self._armour_attack_class\n\n    @armour_attack_class.setter\n    def armour_attack_class(self, value):\n        if value is not None and value != [] and not self._armour_attack_flag:\n            warn(\"Setting 'effect.armour_attack_class' when the effect doesn't use armour/attack attributes \"\n                 \"might result in unintended behaviour.\", category=IncorrectArmorAttackUsageWarning)\n        self._armour_attack_class = value\n\n    @property\n    def quantity(self):\n        \"\"\"Getter for quantity, even if it is combined with `armour_attack_quantity` and `armour_attack_class`\"\"\"\n        if self._armour_attack_flag:\n            return self._aa_to_quantity(self.armour_attack_quantity, self.armour_attack_class)\n        return self._quantity\n\n    @quantity.setter\n    def quantity(self, value):\n        # Quantity by default, when unused is []\n        if value is not None and value != [] and self._armour_attack_flag:\n            warn(\n                message=\"Setting 'effect.quantity' directly in an effect that uses armour/attack attributes \"\n                        \"might result in unintended behaviour.\\nPlease use the 'effect.armour_attack_quantity' \"\n                        \"and 'effect.armour_attack_class' attributes instead.\",\n                category=IncorrectArmorAttackUsageWarning\n            )\n            self.armour_attack_class, self.armour_attack_quantity = self._quantity_to_aa(value)\n        self._quantity = value\n\n    @property\n    def selected_object_ids(self) -&gt; List[int]:\n        \"\"\"Get the current selected objects\"\"\"\n        return self._selected_object_ids\n\n    @selected_object_ids.setter\n    def selected_object_ids(self, val: List[int]):\n        if type(val) is int:\n            val = [val]\n        self._selected_object_ids = val\n\n    def _should_be_displayed(self, attr: str, val: Any) -&gt; bool:\n        # Ignore the quantity value in the print statement when flag is True.\n        if self._armour_attack_flag and attr == \"quantity\":\n            return False\n        if not self._armour_attack_flag and (attr == \"armour_attack_quantity\" or attr == \"armour_attack_class\"):\n            return False\n\n        return super()._should_be_displayed(attr, val)\n\n    def get_content_as_string(self, include_effect_definition: bool = False) -&gt; str:\n        \"\"\"\n        Create a human-readable string showcasing all content of this effect.\n\n        This is also the function that is called when doing: `print(effect)`\n\n        Args:\n            include_effect_definition: If the effect meta-data should be added by this function\n\n        Returns:\n            The created string\n        \"\"\"\n        if self.effect_type not in effects.attributes:  # Unknown effect\n            attributes_list = effects.empty_attributes\n        else:\n            attributes_list = effects.attributes[self.effect_type]\n\n        return_string = \"\"\n        for attribute in attributes_list:\n            val = getattr(self, attribute)\n            if not self._should_be_displayed(attribute, val):\n                continue\n\n            value_string = transform_effect_attr_value(self.effect_type, attribute, val, self._uuid)\n            return_string += f\"{attribute}: {value_string}\\n\"\n\n        if return_string == \"\":\n            return \"&lt;&lt; No Attributes &gt;&gt;\\n\"\n\n        if include_effect_definition:\n            try:\n                effect_name = effects.effect_names[self.effect_type]\n            except KeyError:\n                effect_name = \"Unknown\"\n\n            return f\"{effect_name}:\\n{add_tabs(return_string, 1)}\"\n        return return_string\n\n    def _update_armour_attack_flag(self):\n        self._armour_attack_flag = _set_armour_attack_flag(self.effect_type, self.object_attributes)\n\n    def _quantity_to_aa(self, quantity: int) -&gt; Tuple[int, int]:\n        \"\"\"\n        A function to convert the initial quantity value to the quantity and armor/attack values.\n        Unfortunately this problem has to be solved in the object due to how specific this was implemented in DE.\n\n        Args:\n            quantity: the initial quantity value\n\n        Returns:\n            The one byte armor/attack class as int and one byte armor/attack quantity as int\n\n        ----\n\n        **Trigger Version 2.4**::\n\n            Quantity value: (3, 5)\n            00000000 00000000 00000011 000000101\n                                aaq      aac\n\n        Final 2/4 bytes are aaq (1 byte), and aac (1 byte). First 2 are unused. Max value of both is 255.\n\n        **Trigger Version 2.5**::\n\n            Quantity value: (3, 5)\n            00000000 00000011 00000000 000000101\n              aaq      aaq      aac      aac\n\n        The 4/4 bytes are aaq (2 bytes), and aac (2 bytes). All are used. Max value of both is 65535.\n\n        ----\n        \"\"\"\n        trigger_version = getters.get_trigger_version(self._uuid)\n        if trigger_version &gt;= 2.5:\n            return quantity &gt;&gt; 16, quantity &amp; 65535\n        return quantity &gt;&gt; 8, quantity &amp; 255\n\n    def _aa_to_quantity(self, aa_quantity: int, aa_class: int) -&gt; int:\n        \"\"\"\n        A function to convert the quantity and armor/attack field to a quantity value.\n        Unfortunately this problem has to be solved in the object due to how specific this was implemented in DE.\n\n        Args:\n            aa_quantity: the armor quantity value\n            aa_class: the armor/attack value\n\n        Returns:\n            The one byte quantity and one byte armor/attack value\n        \"\"\"\n        trigger_version = getters.get_trigger_version(self._uuid)\n        if trigger_version &gt;= 2.5:\n            return aa_class * 65536 + aa_quantity\n\n        # Would use `aa_class &lt;&lt; 8` - but apparently multiplication is faster\n        return aa_class * 256 + aa_quantity\n\n    def __str__(self):\n        return f\"[Effect] {self.get_content_as_string(include_effect_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect-attributes","title":"Attributes","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.action_type","title":"<code>action_type = action_type</code>  <code>instance-attribute</code>","text":"Value: <code>action_type</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.ai_script_goal","title":"<code>ai_script_goal: int = ai_script_goal</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>ai_script_goal</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.ai_signal_value","title":"<code>ai_signal_value: int = ai_signal_value</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>ai_signal_value</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.area_x1","title":"<code>area_x1: int = area_x1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_x1</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.area_x2","title":"<code>area_x2: int = area_x2</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_x2</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.area_y1","title":"<code>area_y1: int = area_y1</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_y1</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.area_y2","title":"<code>area_y2: int = area_y2</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>area_y2</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.armour_attack_class","title":"<code>armour_attack_class</code>  <code>property</code> <code>writable</code>","text":"<p>Helper property for handling the armour_attack related values</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.armour_attack_quantity","title":"<code>armour_attack_quantity</code>  <code>property</code> <code>writable</code>","text":"<p>Helper property for handling the armour_attack related values</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.attack_stance","title":"<code>attack_stance: int = attack_stance</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>attack_stance</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.button_location","title":"<code>button_location: int = button_location</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>button_location</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.color_mood","title":"<code>color_mood: int = color_mood</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>color_mood</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.diplomacy","title":"<code>diplomacy: int = diplomacy</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>diplomacy</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.display_time","title":"<code>display_time: int = display_time</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>display_time</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.effect_type","title":"<code>effect_type</code>  <code>property</code> <code>writable</code>","text":"<p>The type of the effect (EffectId dataset)</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.enabled","title":"<code>enabled: int = enabled</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>enabled</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.facet","title":"<code>facet: int = facet</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>facet</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.flash_object","title":"<code>flash_object: int = flash_object</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>flash_object</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.food","title":"<code>food: int = food</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>food</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.force_research_technology","title":"<code>force_research_technology: int = force_research_technology</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>force_research_technology</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.gold","title":"<code>gold: int = gold</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>gold</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.hidden_attribute","title":"<code>hidden_attribute = 'effect_type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"Value: <code>'effect_type'</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.instruction_panel_position","title":"<code>instruction_panel_position: int = instruction_panel_position</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>instruction_panel_position</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.item_id","title":"<code>item_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the currently selected item_id based on other attributes</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.legacy_location_object_reference","title":"<code>legacy_location_object_reference: int</code>  <code>property</code>","text":"Type: <code>int</code> <p>Getter for legacy object_reference location. Always returns <code>-1</code>.</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.location_object_reference","title":"<code>location_object_reference: int = location_object_reference</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>location_object_reference</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.location_x","title":"<code>location_x: int = location_x</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>location_x</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.location_y","title":"<code>location_y: int = location_y</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>location_y</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.message","title":"<code>message: str = message</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>message</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_attributes","title":"<code>object_attributes</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_group","title":"<code>object_group: int = object_group</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_group</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_list_unit_id","title":"<code>object_list_unit_id: int = object_list_unit_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_list_unit_id</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_list_unit_id_2","title":"<code>object_list_unit_id_2: int = object_list_unit_id_2</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_list_unit_id_2</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_state","title":"<code>object_state = object_state</code>  <code>instance-attribute</code>","text":"Value: <code>object_state</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.object_type","title":"<code>object_type: int = object_type</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>object_type</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.operation","title":"<code>operation: int = operation</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>operation</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.play_sound","title":"<code>play_sound: int = play_sound</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>play_sound</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.player_color","title":"<code>player_color</code>  <code>property</code> <code>writable</code>","text":"<p>Get the player color attribute</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.quantity","title":"<code>quantity</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for quantity, even if it is combined with <code>armour_attack_quantity</code> and <code>armour_attack_class</code></p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.reset_timer","title":"<code>reset_timer = reset_timer</code>  <code>instance-attribute</code>","text":"Value: <code>reset_timer</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.scroll","title":"<code>scroll: int = scroll</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>scroll</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.selected_object_ids","title":"<code>selected_object_ids: List[int]</code>  <code>property</code> <code>writable</code>","text":"Type: <code>List[int]</code> <p>Get the current selected objects</p>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.sound_name","title":"<code>sound_name: str = sound_name</code>  <code>instance-attribute</code>","text":"Type: <code>str</code>                           Value: <code>sound_name</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.source_player","title":"<code>source_player: int = source_player</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>source_player</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.stone","title":"<code>stone: int = stone</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>stone</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.string_id","title":"<code>string_id: int = string_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>string_id</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.target_player","title":"<code>target_player: int = target_player</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>target_player</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.technology","title":"<code>technology: int = technology</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>technology</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.time_unit","title":"<code>time_unit: int = time_unit</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>time_unit</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.timer","title":"<code>timer: int = timer</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>timer</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.tribute_list","title":"<code>tribute_list: int = tribute_list</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>tribute_list</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.trigger_id","title":"<code>trigger_id: int = trigger_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>trigger_id</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.variable","title":"<code>variable: int = variable</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>variable</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.visibility_state","title":"<code>visibility_state: int = visibility_state</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>visibility_state</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.wood","title":"<code>wood: int = wood</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>wood</code>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect-functions","title":"Functions","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>effect_type</code> <code>int</code>  - <code>None</code> <code>ai_script_goal</code> <code>int</code>  - <code>None</code> <code>armour_attack_quantity</code> <code>int</code>  - <code>None</code> <code>armour_attack_class</code> <code>int</code>  - <code>None</code> <code>quantity</code> <code>int</code>  - <code>None</code> <code>tribute_list</code> <code>int</code>  - <code>None</code> <code>diplomacy</code> <code>int</code>  - <code>None</code> <code>legacy_location_object_reference</code> <code>int</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int</code>  - <code>None</code> <code>source_player</code> <code>int</code>  - <code>None</code> <code>target_player</code> <code>int</code>  - <code>None</code> <code>technology</code> <code>int</code>  - <code>None</code> <code>string_id</code> <code>int</code>  - <code>None</code> <code>display_time</code> <code>int</code>  - <code>None</code> <code>trigger_id</code> <code>int</code>  - <code>None</code> <code>location_x</code> <code>int</code>  - <code>None</code> <code>location_y</code> <code>int</code>  - <code>None</code> <code>location_object_reference</code> <code>int</code>  - <code>None</code> <code>area_x1</code> <code>int</code>  - <code>None</code> <code>area_y1</code> <code>int</code>  - <code>None</code> <code>area_x2</code> <code>int</code>  - <code>None</code> <code>area_y2</code> <code>int</code>  - <code>None</code> <code>object_group</code> <code>int</code>  - <code>None</code> <code>object_type</code> <code>int</code>  - <code>None</code> <code>instruction_panel_position</code> <code>int</code>  - <code>None</code> <code>attack_stance</code> <code>int</code>  - <code>None</code> <code>time_unit</code> <code>int</code>  - <code>None</code> <code>enabled</code> <code>int</code>  - <code>None</code> <code>food</code> <code>int</code>  - <code>None</code> <code>wood</code> <code>int</code>  - <code>None</code> <code>stone</code> <code>int</code>  - <code>None</code> <code>gold</code> <code>int</code>  - <code>None</code> <code>item_id</code> <code>int</code>  - <code>None</code> <code>flash_object</code> <code>int</code>  - <code>None</code> <code>force_research_technology</code> <code>int</code>  - <code>None</code> <code>visibility_state</code> <code>int</code>  - <code>None</code> <code>scroll</code> <code>int</code>  - <code>None</code> <code>operation</code> <code>int</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int</code>  - <code>None</code> <code>button_location</code> <code>int</code>  - <code>None</code> <code>ai_signal_value</code> <code>int</code>  - <code>None</code> <code>object_attributes</code> <code>int</code>  - <code>None</code> <code>variable</code> <code>int</code>  - <code>None</code> <code>timer</code> <code>int</code>  - <code>None</code> <code>facet</code> <code>int</code>  - <code>None</code> <code>play_sound</code> <code>int</code>  - <code>None</code> <code>player_color</code> <code>int</code>  - <code>None</code> <code>color_mood</code> <code>int</code>  - <code>None</code> <code>reset_timer</code> <code>int</code>  - <code>None</code> <code>object_state</code> <code>int</code>  - <code>None</code> <code>action_type</code> <code>int</code>  - <code>None</code> <code>message</code> <code>str</code>  - <code>None</code> <code>sound_name</code> <code>str</code>  - <code>None</code> <code>selected_object_ids</code> <code>List[int]</code>  - <code>None</code> <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/effect.py</code> <pre><code>def __init__(\n        self,\n        effect_type: int = None,\n        ai_script_goal: int = None,\n        armour_attack_quantity: int = None,\n        armour_attack_class: int = None,\n        quantity: int = None,\n        tribute_list: int = None,\n        diplomacy: int = None,\n        legacy_location_object_reference: int = None,\n        object_list_unit_id: int = None,\n        source_player: int = None,\n        target_player: int = None,\n        technology: int = None,\n        string_id: int = None,\n        display_time: int = None,\n        trigger_id: int = None,\n        location_x: int = None,\n        location_y: int = None,\n        location_object_reference: int = None,\n        area_x1: int = None,\n        area_y1: int = None,\n        area_x2: int = None,\n        area_y2: int = None,\n        object_group: int = None,\n        object_type: int = None,\n        instruction_panel_position: int = None,\n        attack_stance: int = None,\n        time_unit: int = None,\n        enabled: int = None,\n        food: int = None,\n        wood: int = None,\n        stone: int = None,\n        gold: int = None,\n        item_id: int = None,  # Unused (?)\n        flash_object: int = None,\n        force_research_technology: int = None,\n        visibility_state: int = None,\n        scroll: int = None,\n        operation: int = None,\n        object_list_unit_id_2: int = None,\n        button_location: int = None,\n        ai_signal_value: int = None,\n        object_attributes: int = None,\n        variable: int = None,\n        timer: int = None,\n        facet: int = None,\n        play_sound: int = None,\n        player_color: int = None,\n        color_mood: int = None,\n        reset_timer: int = None,\n        object_state: int = None,\n        action_type: int = None,\n        message: str = None,\n        sound_name: str = None,\n        selected_object_ids: List[int] = None,\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    raise_if_not_int_subclass([object_list_unit_id, technology, object_list_unit_id_2])\n\n    if selected_object_ids is None:\n        selected_object_ids = []\n\n    # Set flags\n    self._armour_attack_flag = _set_armour_attack_flag(effect_type, object_attributes)\n\n    # Handle armour effect attributes:\n    #   When effect is created through trigger.new_effect, aa values will be -1.\n    #   If created while reading a scenario, they both default to None.\n    if self._armour_attack_flag:\n        # If effect created through reading scenario file\n        if quantity is not None and armour_attack_class is None and armour_attack_quantity is None:\n            armour_attack_class, armour_attack_quantity = self._quantity_to_aa(quantity)\n            quantity = None\n        # If effect created through new_effect with aa values defined\n        elif value_is_valid(armour_attack_class) or value_is_valid(armour_attack_quantity):\n            quantity = None\n        # If created through new_effect with quantity defined instead of the aa values. Handled by quantity property\n        else:\n            pass\n    else:\n        armour_attack_class = armour_attack_quantity = None\n\n    area_x1, area_y1, area_x2, area_y2 = validate_coords(area_x1, area_y1, area_x2, area_y2)\n\n    if value_is_valid(legacy_location_object_reference):\n        location_object_reference = legacy_location_object_reference\n\n    # Bypass the @property which causes: self._update_armour_attack_flag()\n    self._effect_type: int = effect_type\n    self.ai_script_goal: int = ai_script_goal\n    self.armour_attack_quantity: int = armour_attack_quantity\n    self.armour_attack_class: int = armour_attack_class\n    self.quantity: int = quantity\n    self.tribute_list: int = tribute_list\n    self.diplomacy: int = diplomacy\n    self.object_list_unit_id: int = object_list_unit_id\n    self.source_player: int = source_player\n    self.target_player: int = target_player\n    self.technology: int = technology\n    self.string_id: int = string_id\n    self.display_time: int = display_time\n    self.trigger_id: int = trigger_id\n    self.location_x: int = location_x\n    self.location_y: int = location_y\n    self.location_object_reference: int = location_object_reference\n    self.area_x1: int = area_x1\n    self.area_y1: int = area_y1\n    self.area_x2: int = area_x2\n    self.area_y2: int = area_y2\n    self.object_group: int = object_group\n    self.object_type: int = object_type\n    self.instruction_panel_position: int = instruction_panel_position\n    self.attack_stance: int = attack_stance\n    self.time_unit: int = time_unit\n    self.enabled: int = enabled\n    self.food: int = food\n    self.wood: int = wood\n    self.stone: int = stone\n    self.gold: int = gold\n    # self.item_id: int = item_id  # Unused (?)\n    self.flash_object: int = flash_object\n    self.force_research_technology: int = force_research_technology\n    self.visibility_state: int = visibility_state\n    self.scroll: int = scroll\n    self.operation: int = operation\n    self.object_list_unit_id_2: int = object_list_unit_id_2\n    self.button_location: int = button_location\n    self.ai_signal_value: int = ai_signal_value\n    self.object_attributes: int = object_attributes\n    self.variable: int = variable\n    self.timer: int = timer\n    self.facet: int = facet\n    self.play_sound: int = play_sound\n    self.player_color: int = player_color\n    self.color_mood: int = color_mood\n    self.reset_timer = reset_timer\n    self.object_state = object_state\n    self.action_type = action_type\n    self.message: str = message\n    self.sound_name: str = sound_name\n    self.selected_object_ids: List[int] = selected_object_ids\n</code></pre>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.__str__","title":"<code>def __str__(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/data_objects/effect.py</code> <pre><code>def __str__(self):\n    return f\"[Effect] {self.get_content_as_string(include_effect_definition=True)}\"\n</code></pre>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect.Effect.get_content_as_string","title":"<code>def get_content_as_string(...)</code>","text":"<p>Create a human-readable string showcasing all content of this effect.</p> <p>This is also the function that is called when doing: <code>print(effect)</code></p> <p>Parameters:</p> Name Type Description Default <code>include_effect_definition</code> <code>bool</code> <p>If the effect meta-data should be added by this function</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The created string</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/effect.py</code> <pre><code>def get_content_as_string(self, include_effect_definition: bool = False) -&gt; str:\n    \"\"\"\n    Create a human-readable string showcasing all content of this effect.\n\n    This is also the function that is called when doing: `print(effect)`\n\n    Args:\n        include_effect_definition: If the effect meta-data should be added by this function\n\n    Returns:\n        The created string\n    \"\"\"\n    if self.effect_type not in effects.attributes:  # Unknown effect\n        attributes_list = effects.empty_attributes\n    else:\n        attributes_list = effects.attributes[self.effect_type]\n\n    return_string = \"\"\n    for attribute in attributes_list:\n        val = getattr(self, attribute)\n        if not self._should_be_displayed(attribute, val):\n            continue\n\n        value_string = transform_effect_attr_value(self.effect_type, attribute, val, self._uuid)\n        return_string += f\"{attribute}: {value_string}\\n\"\n\n    if return_string == \"\":\n        return \"&lt;&lt; No Attributes &gt;&gt;\\n\"\n\n    if include_effect_definition:\n        try:\n            effect_name = effects.effect_names[self.effect_type]\n        except KeyError:\n            effect_name = \"Unknown\"\n\n        return f\"{effect_name}:\\n{add_tabs(return_string, 1)}\"\n    return return_string\n</code></pre>"},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect-functions","title":"Functions","text":""},{"location":"api_docs/trigger/effects/effect/#AoE2ScenarioParser.objects.data_objects.effect-modules","title":"Modules","text":""},{"location":"api_docs/trigger/effects/new_effect/","title":"NewEffect","text":""},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect-classes","title":"Classes","text":""},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport","title":"<code>NewEffectSupport</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>class NewEffectSupport:\n    def __init__(self, trigger_ref):\n        self._trigger_ref = trigger_ref\n\n    def none(\n            self,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.NONE,\n        )\n\n    def change_diplomacy(\n            self,\n            diplomacy: int | None = None,\n            source_player: int | None = None,\n            target_player: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_DIPLOMACY,\n            diplomacy=diplomacy,\n            source_player=source_player,\n            target_player=target_player,\n        )\n\n    def research_technology(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            force_research_technology: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.RESEARCH_TECHNOLOGY,\n            source_player=source_player,\n            technology=technology,\n            force_research_technology=force_research_technology,\n        )\n\n    def send_chat(\n            self,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n            sound_name: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.SEND_CHAT,\n            source_player=source_player,\n            string_id=string_id,\n            message=message,\n            sound_name=sound_name,\n        )\n\n    def play_sound(\n            self,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            location_object_reference: int | None = None,\n            sound_name: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.PLAY_SOUND,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            location_object_reference=location_object_reference,\n            sound_name=sound_name,\n        )\n\n    def tribute(\n            self,\n            quantity: int | None = None,\n            tribute_list: int | None = None,\n            source_player: int | None = None,\n            target_player: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.TRIBUTE,\n            quantity=quantity,\n            tribute_list=tribute_list,\n            source_player=source_player,\n            target_player=target_player,\n        )\n\n    def unlock_gate(\n            self,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.UNLOCK_GATE,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def lock_gate(\n            self,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.LOCK_GATE,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def activate_trigger(\n            self,\n            trigger_id: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ACTIVATE_TRIGGER,\n            trigger_id=trigger_id,\n        )\n\n    def deactivate_trigger(\n            self,\n            trigger_id: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DEACTIVATE_TRIGGER,\n            trigger_id=trigger_id,\n        )\n\n    def ai_script_goal(\n            self,\n            ai_script_goal: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.AI_SCRIPT_GOAL,\n            ai_script_goal=ai_script_goal,\n        )\n\n    def create_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            facet: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CREATE_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            facet=facet,\n        )\n\n    def task_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            location_object_reference: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            action_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.TASK_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            location_object_reference=location_object_reference,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            action_type=action_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def declare_victory(\n            self,\n            source_player: int | None = None,\n            enabled: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DECLARE_VICTORY,\n            source_player=source_player,\n            enabled=enabled,\n        )\n\n    def kill_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.KILL_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def remove_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            object_state: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.REMOVE_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            object_state=object_state,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_view(\n            self,\n            quantity: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            scroll: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_VIEW,\n            quantity=quantity,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            scroll=scroll,\n        )\n\n    def unload(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            location_object_reference: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.UNLOAD,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            location_object_reference=location_object_reference,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_ownership(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            target_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            flash_object: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OWNERSHIP,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            target_player=target_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            flash_object=flash_object,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def patrol(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.PATROL,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def display_instructions(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            display_time: int | None = None,\n            instruction_panel_position: int | None = None,\n            play_sound: int | None = None,\n            message: str | None = None,\n            sound_name: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DISPLAY_INSTRUCTIONS,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            string_id=string_id,\n            display_time=display_time,\n            instruction_panel_position=instruction_panel_position,\n            play_sound=play_sound,\n            message=message,\n            sound_name=sound_name,\n        )\n\n    def clear_instructions(\n            self,\n            instruction_panel_position: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CLEAR_INSTRUCTIONS,\n            instruction_panel_position=instruction_panel_position,\n        )\n\n    def freeze_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.FREEZE_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def use_advanced_buttons(\n            self,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.USE_ADVANCED_BUTTONS,\n        )\n\n    def damage_object(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DAMAGE_OBJECT,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def place_foundation(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.PLACE_FOUNDATION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n        )\n\n    def change_object_name(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            message: str | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_NAME,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            string_id=string_id,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            message=message,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_hp(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_HP,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_attack(\n            self,\n            armour_attack_quantity: int | None = None,\n            armour_attack_class: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_ATTACK,\n            armour_attack_quantity=armour_attack_quantity,\n            armour_attack_class=armour_attack_class,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def stop_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.STOP_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def attack_move(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            location_object_reference: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ATTACK_MOVE,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            location_object_reference=location_object_reference,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_armor(\n            self,\n            armour_attack_quantity: int | None = None,\n            armour_attack_class: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_ARMOR,\n            armour_attack_quantity=armour_attack_quantity,\n            armour_attack_class=armour_attack_class,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_range(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_RANGE,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_speed(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_SPEED,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def heal_object(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.HEAL_OBJECT,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def teleport_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.TELEPORT_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_stance(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            attack_stance: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_STANCE,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            attack_stance=attack_stance,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def display_timer(\n            self,\n            string_id: int | None = None,\n            display_time: int | None = None,\n            time_unit: int | None = None,\n            timer: int | None = None,\n            reset_timer: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DISPLAY_TIMER,\n            string_id=string_id,\n            display_time=display_time,\n            time_unit=time_unit,\n            timer=timer,\n            reset_timer=reset_timer,\n            message=message,\n        )\n\n    def enable_disable_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            enabled: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_DISABLE_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            enabled=enabled,\n        )\n\n    def enable_disable_technology(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            enabled: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_DISABLE_TECHNOLOGY,\n            source_player=source_player,\n            technology=technology,\n            enabled=enabled,\n        )\n\n    def change_object_cost(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            food: int | None = None,\n            wood: int | None = None,\n            stone: int | None = None,\n            gold: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_COST,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            food=food,\n            wood=wood,\n            stone=stone,\n            gold=gold,\n        )\n\n    def set_player_visibility(\n            self,\n            source_player: int | None = None,\n            target_player: int | None = None,\n            visibility_state: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.SET_PLAYER_VISIBILITY,\n            source_player=source_player,\n            target_player=target_player,\n            visibility_state=visibility_state,\n        )\n\n    def change_object_icon(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_ICON,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            object_list_unit_id_2=object_list_unit_id_2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def replace_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            target_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.REPLACE_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            target_player=target_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            object_list_unit_id_2=object_list_unit_id_2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_description(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_DESCRIPTION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            string_id=string_id,\n            message=message,\n        )\n\n    def change_player_name(\n            self,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_PLAYER_NAME,\n            source_player=source_player,\n            string_id=string_id,\n            message=message,\n        )\n\n    def change_train_location(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            button_location: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TRAIN_LOCATION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            object_list_unit_id_2=object_list_unit_id_2,\n            button_location=button_location,\n        )\n\n    @deprecated('Use `change_technology_location` instead')\n    def change_research_location(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            button_location: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_LOCATION,\n            source_player=source_player,\n            technology=technology,\n            object_list_unit_id_2=object_list_unit_id_2,\n            button_location=button_location,\n        )\n\n    def change_technology_location(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            button_location: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_LOCATION,\n            source_player=source_player,\n            technology=technology,\n            object_list_unit_id_2=object_list_unit_id_2,\n            button_location=button_location,\n        )\n\n    def change_civilization_name(\n            self,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_CIVILIZATION_NAME,\n            source_player=source_player,\n            string_id=string_id,\n            message=message,\n        )\n\n    def create_garrisoned_object(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_list_unit_id_2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CREATE_GARRISONED_OBJECT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_list_unit_id_2=object_list_unit_id_2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def acknowledge_ai_signal(\n            self,\n            ai_signal_value: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ACKNOWLEDGE_AI_SIGNAL,\n            ai_signal_value=ai_signal_value,\n        )\n\n    def modify_attribute(\n            self,\n            quantity: int | None = None,\n            armour_attack_quantity: int | None = None,\n            armour_attack_class: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            operation: int | None = None,\n            object_attributes: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        \"\"\"\n        The parameters 'armour_attack_quantity' and 'armour_attack_class' are only used when object_attributes is Armor\n        or Attack (8 or 9). Use, 'quantity' otherwise.\n        \"\"\"\n        if (armour_attack_quantity is not None or armour_attack_class is not None) and quantity is not None:\n            raise ValueError(\"Cannot use 'armour_attack' attributes together with the 'quantity' attribute.\")\n\n        return self._trigger_ref._add_effect(\n            EffectId.MODIFY_ATTRIBUTE,\n            quantity=quantity,\n            armour_attack_quantity=armour_attack_quantity,\n            armour_attack_class=armour_attack_class,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            operation=operation,\n            object_attributes=object_attributes,\n            message=message\n        )\n\n    def modify_resource(\n            self,\n            quantity: int | None = None,\n            tribute_list: int | None = None,\n            source_player: int | None = None,\n            operation: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.MODIFY_RESOURCE,\n            quantity=quantity,\n            tribute_list=tribute_list,\n            source_player=source_player,\n            operation=operation,\n        )\n\n    def modify_resource_by_variable(\n            self,\n            tribute_list: int | None = None,\n            source_player: int | None = None,\n            operation: int | None = None,\n            variable: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.MODIFY_RESOURCE_BY_VARIABLE,\n            tribute_list=tribute_list,\n            source_player=source_player,\n            operation=operation,\n            variable=variable,\n        )\n\n    def set_building_gather_point(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.SET_BUILDING_GATHER_POINT,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def script_call(\n            self,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.SCRIPT_CALL,\n            string_id=string_id,\n            message=message,\n        )\n\n    def change_variable(\n            self,\n            quantity: int | None = None,\n            operation: int | None = None,\n            variable: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_VARIABLE,\n            quantity=quantity,\n            operation=operation,\n            variable=variable,\n            message=message,\n        )\n\n    def clear_timer(\n            self,\n            timer: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CLEAR_TIMER,\n            timer=timer,\n        )\n\n    def change_object_player_color(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            player_color: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_PLAYER_COLOR,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            player_color=player_color,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_civilization_name(\n            self,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            message: str | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_CIVILIZATION_NAME,\n            source_player=source_player,\n            string_id=string_id,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            message=message,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_object_player_name(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            string_id: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            message: str | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_OBJECT_PLAYER_NAME,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            string_id=string_id,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            message=message,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def disable_unit_targeting(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DISABLE_UNIT_TARGETING,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def enable_unit_targeting(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_UNIT_TARGETING,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_technology_cost(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            food: int | None = None,\n            wood: int | None = None,\n            stone: int | None = None,\n            gold: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_COST,\n            source_player=source_player,\n            technology=technology,\n            food=food,\n            wood=wood,\n            stone=stone,\n            gold=gold,\n        )\n\n    def change_technology_research_time(\n            self,\n            quantity: int | None = None,\n            source_player: int | None = None,\n            technology: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_RESEARCH_TIME,\n            quantity=quantity,\n            source_player=source_player,\n            technology=technology,\n        )\n\n    def change_technology_name(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_NAME,\n            source_player=source_player,\n            technology=technology,\n            string_id=string_id,\n            message=message,\n        )\n\n    def change_technology_description(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            string_id: int | None = None,\n            message: str | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_TECHNOLOGY_DESCRIPTION,\n            source_player=source_player,\n            technology=technology,\n            string_id=string_id,\n            message=message,\n        )\n\n    def enable_technology_stacking(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            quantity: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_TECHNOLOGY_STACKING,\n            source_player=source_player,\n            technology=technology,\n            quantity=quantity,\n        )\n\n    def disable_technology_stacking(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DISABLE_TECHNOLOGY_STACKING,\n            source_player=source_player,\n            technology=technology,\n        )\n\n    def acknowledge_multiplayer_ai_signal(\n            self,\n            ai_signal_value: int | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ACKNOWLEDGE_MULTIPLAYER_AI_SIGNAL,\n            ai_signal_value=ai_signal_value,\n        )\n\n    def disable_object_selection(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.DISABLE_OBJECT_SELECTION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def enable_object_selection(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ) -&gt; Effect:\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_OBJECT_SELECTION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def change_color_mood(\n            self,\n            quantity: int | None = None,\n            color_mood: int | None = None):\n        return self._trigger_ref._add_effect(\n            EffectId.CHANGE_COLOR_MOOD,\n            quantity=quantity,\n            color_mood=color_mood\n        )\n\n    def enable_object_deletion(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.ENABLE_OBJECT_DELETION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def disable_object_deletion(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.DISABLE_OBJECT_DELETION,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids,\n        )\n\n    def train_unit(\n            self,\n            quantity: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            location_x: int | None = None,\n            location_y: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.TRAIN_UNIT,\n            quantity=quantity,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            location_x=location_x,\n            location_y=location_y,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            selected_object_ids=selected_object_ids\n        )\n\n    def initiate_research(\n            self,\n            source_player: int | None = None,\n            technology: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.INITIATE_RESEARCH,\n            source_player=source_player,\n            technology=technology,\n            selected_object_ids=selected_object_ids\n        )\n\n    def create_object_attack(\n            self,\n            armour_attack_quantity: int | None = None,\n            armour_attack_class: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.CREATE_OBJECT_ATTACK,\n            armour_attack_quantity=armour_attack_quantity,\n            armour_attack_class=armour_attack_class,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids\n        )\n\n    def create_object_armor(\n            self,\n            armour_attack_quantity: int | None = None,\n            armour_attack_class: int | None = None,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            area_x1: int | None = None,\n            area_y1: int | None = None,\n            area_x2: int | None = None,\n            area_y2: int | None = None,\n            object_group: int | None = None,\n            object_type: int | None = None,\n            operation: int | None = None,\n            selected_object_ids: int | List[int] | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.CREATE_OBJECT_ARMOR,\n            armour_attack_quantity=armour_attack_quantity,\n            armour_attack_class=armour_attack_class,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            area_x1=area_x1,\n            area_y1=area_y1,\n            area_x2=area_x2,\n            area_y2=area_y2,\n            object_group=object_group,\n            object_type=object_type,\n            operation=operation,\n            selected_object_ids=selected_object_ids\n        )\n\n    def modify_attribute_by_variable(\n            self,\n            object_list_unit_id: int | None = None,\n            source_player: int | None = None,\n            operation: int | None = None,\n            object_attributes: int | None = None,\n            variable: int | None = None,\n            message: str | None = None,\n    ):\n        return self._trigger_ref._add_effect(\n            EffectId.MODIFY_ATTRIBUTE_BY_VARIABLE,\n            object_list_unit_id=object_list_unit_id,\n            source_player=source_player,\n            operation=operation,\n            object_attributes=object_attributes,\n            variable=variable,\n            message=message\n        )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport-functions","title":"Functions","text":""},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger_ref</code>                              ?                       - required Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def __init__(self, trigger_ref):\n    self._trigger_ref = trigger_ref\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.acknowledge_ai_signal","title":"<code>def acknowledge_ai_signal(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ai_signal_value</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def acknowledge_ai_signal(\n        self,\n        ai_signal_value: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ACKNOWLEDGE_AI_SIGNAL,\n        ai_signal_value=ai_signal_value,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.acknowledge_multiplayer_ai_signal","title":"<code>def acknowledge_multiplayer_ai_signal(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ai_signal_value</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def acknowledge_multiplayer_ai_signal(\n        self,\n        ai_signal_value: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ACKNOWLEDGE_MULTIPLAYER_AI_SIGNAL,\n        ai_signal_value=ai_signal_value,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.activate_trigger","title":"<code>def activate_trigger(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger_id</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def activate_trigger(\n        self,\n        trigger_id: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ACTIVATE_TRIGGER,\n        trigger_id=trigger_id,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.ai_script_goal","title":"<code>def ai_script_goal(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ai_script_goal</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def ai_script_goal(\n        self,\n        ai_script_goal: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.AI_SCRIPT_GOAL,\n        ai_script_goal=ai_script_goal,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.attack_move","title":"<code>def attack_move(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>location_object_reference</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def attack_move(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        location_object_reference: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ATTACK_MOVE,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        location_object_reference=location_object_reference,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_civilization_name","title":"<code>def change_civilization_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_civilization_name(\n        self,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_CIVILIZATION_NAME,\n        source_player=source_player,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_color_mood","title":"<code>def change_color_mood(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>color_mood</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_color_mood(\n        self,\n        quantity: int | None = None,\n        color_mood: int | None = None):\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_COLOR_MOOD,\n        quantity=quantity,\n        color_mood=color_mood\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_diplomacy","title":"<code>def change_diplomacy(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>diplomacy</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_diplomacy(\n        self,\n        diplomacy: int | None = None,\n        source_player: int | None = None,\n        target_player: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_DIPLOMACY,\n        diplomacy=diplomacy,\n        source_player=source_player,\n        target_player=target_player,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_armor","title":"<code>def change_object_armor(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>armour_attack_quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_class</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_armor(\n        self,\n        armour_attack_quantity: int | None = None,\n        armour_attack_class: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_ARMOR,\n        armour_attack_quantity=armour_attack_quantity,\n        armour_attack_class=armour_attack_class,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_attack","title":"<code>def change_object_attack(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>armour_attack_quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_class</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_attack(\n        self,\n        armour_attack_quantity: int | None = None,\n        armour_attack_class: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_ATTACK,\n        armour_attack_quantity=armour_attack_quantity,\n        armour_attack_class=armour_attack_class,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_civilization_name","title":"<code>def change_object_civilization_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_civilization_name(\n        self,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        message: str | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_CIVILIZATION_NAME,\n        source_player=source_player,\n        string_id=string_id,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        message=message,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_cost","title":"<code>def change_object_cost(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>food</code> <code>int | None</code>  - <code>None</code> <code>wood</code> <code>int | None</code>  - <code>None</code> <code>stone</code> <code>int | None</code>  - <code>None</code> <code>gold</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_cost(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        food: int | None = None,\n        wood: int | None = None,\n        stone: int | None = None,\n        gold: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_COST,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        food=food,\n        wood=wood,\n        stone=stone,\n        gold=gold,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_description","title":"<code>def change_object_description(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_description(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_DESCRIPTION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_hp","title":"<code>def change_object_hp(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_hp(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_HP,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_icon","title":"<code>def change_object_icon(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_icon(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_ICON,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        object_list_unit_id_2=object_list_unit_id_2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_name","title":"<code>def change_object_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_name(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        message: str | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_NAME,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        string_id=string_id,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        message=message,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_player_color","title":"<code>def change_object_player_color(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>player_color</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_player_color(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        player_color: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_PLAYER_COLOR,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        player_color=player_color,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_player_name","title":"<code>def change_object_player_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_player_name(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        message: str | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_PLAYER_NAME,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        string_id=string_id,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        message=message,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_range","title":"<code>def change_object_range(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_range(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_RANGE,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_speed","title":"<code>def change_object_speed(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_speed(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_SPEED,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_object_stance","title":"<code>def change_object_stance(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>attack_stance</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_object_stance(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        attack_stance: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OBJECT_STANCE,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        attack_stance=attack_stance,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_ownership","title":"<code>def change_ownership(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>flash_object</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_ownership(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        target_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        flash_object: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_OWNERSHIP,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        target_player=target_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        flash_object=flash_object,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_player_name","title":"<code>def change_player_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_player_name(\n        self,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_PLAYER_NAME,\n        source_player=source_player,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_research_location","title":"<code>def change_research_location(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>button_location</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>@deprecated('Use `change_technology_location` instead')\ndef change_research_location(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        button_location: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_LOCATION,\n        source_player=source_player,\n        technology=technology,\n        object_list_unit_id_2=object_list_unit_id_2,\n        button_location=button_location,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_technology_cost","title":"<code>def change_technology_cost(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>food</code> <code>int | None</code>  - <code>None</code> <code>wood</code> <code>int | None</code>  - <code>None</code> <code>stone</code> <code>int | None</code>  - <code>None</code> <code>gold</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_technology_cost(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        food: int | None = None,\n        wood: int | None = None,\n        stone: int | None = None,\n        gold: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_COST,\n        source_player=source_player,\n        technology=technology,\n        food=food,\n        wood=wood,\n        stone=stone,\n        gold=gold,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_technology_description","title":"<code>def change_technology_description(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_technology_description(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_DESCRIPTION,\n        source_player=source_player,\n        technology=technology,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_technology_location","title":"<code>def change_technology_location(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>button_location</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_technology_location(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        button_location: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_LOCATION,\n        source_player=source_player,\n        technology=technology,\n        object_list_unit_id_2=object_list_unit_id_2,\n        button_location=button_location,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_technology_name","title":"<code>def change_technology_name(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_technology_name(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_NAME,\n        source_player=source_player,\n        technology=technology,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_technology_research_time","title":"<code>def change_technology_research_time(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_technology_research_time(\n        self,\n        quantity: int | None = None,\n        source_player: int | None = None,\n        technology: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TECHNOLOGY_RESEARCH_TIME,\n        quantity=quantity,\n        source_player=source_player,\n        technology=technology,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_train_location","title":"<code>def change_train_location(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>button_location</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_train_location(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        button_location: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_TRAIN_LOCATION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        object_list_unit_id_2=object_list_unit_id_2,\n        button_location=button_location,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_variable","title":"<code>def change_variable(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>variable</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_variable(\n        self,\n        quantity: int | None = None,\n        operation: int | None = None,\n        variable: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_VARIABLE,\n        quantity=quantity,\n        operation=operation,\n        variable=variable,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.change_view","title":"<code>def change_view(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>scroll</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def change_view(\n        self,\n        quantity: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        scroll: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CHANGE_VIEW,\n        quantity=quantity,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        scroll=scroll,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.clear_instructions","title":"<code>def clear_instructions(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instruction_panel_position</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def clear_instructions(\n        self,\n        instruction_panel_position: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CLEAR_INSTRUCTIONS,\n        instruction_panel_position=instruction_panel_position,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.clear_timer","title":"<code>def clear_timer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>timer</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def clear_timer(\n        self,\n        timer: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CLEAR_TIMER,\n        timer=timer,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.create_garrisoned_object","title":"<code>def create_garrisoned_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def create_garrisoned_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CREATE_GARRISONED_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_list_unit_id_2=object_list_unit_id_2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.create_object","title":"<code>def create_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>facet</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def create_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        facet: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.CREATE_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        facet=facet,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.create_object_armor","title":"<code>def create_object_armor(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>armour_attack_quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_class</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def create_object_armor(\n        self,\n        armour_attack_quantity: int | None = None,\n        armour_attack_class: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.CREATE_OBJECT_ARMOR,\n        armour_attack_quantity=armour_attack_quantity,\n        armour_attack_class=armour_attack_class,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.create_object_attack","title":"<code>def create_object_attack(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>armour_attack_quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_class</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def create_object_attack(\n        self,\n        armour_attack_quantity: int | None = None,\n        armour_attack_class: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        operation: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.CREATE_OBJECT_ATTACK,\n        armour_attack_quantity=armour_attack_quantity,\n        armour_attack_class=armour_attack_class,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        operation=operation,\n        selected_object_ids=selected_object_ids\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.damage_object","title":"<code>def damage_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def damage_object(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DAMAGE_OBJECT,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.deactivate_trigger","title":"<code>def deactivate_trigger(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>trigger_id</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def deactivate_trigger(\n        self,\n        trigger_id: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DEACTIVATE_TRIGGER,\n        trigger_id=trigger_id,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.declare_victory","title":"<code>def declare_victory(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>enabled</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def declare_victory(\n        self,\n        source_player: int | None = None,\n        enabled: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DECLARE_VICTORY,\n        source_player=source_player,\n        enabled=enabled,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.disable_object_deletion","title":"<code>def disable_object_deletion(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def disable_object_deletion(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.DISABLE_OBJECT_DELETION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.disable_object_selection","title":"<code>def disable_object_selection(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def disable_object_selection(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DISABLE_OBJECT_SELECTION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.disable_technology_stacking","title":"<code>def disable_technology_stacking(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def disable_technology_stacking(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DISABLE_TECHNOLOGY_STACKING,\n        source_player=source_player,\n        technology=technology,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.disable_unit_targeting","title":"<code>def disable_unit_targeting(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def disable_unit_targeting(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DISABLE_UNIT_TARGETING,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.display_instructions","title":"<code>def display_instructions(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>display_time</code> <code>int | None</code>  - <code>None</code> <code>instruction_panel_position</code> <code>int | None</code>  - <code>None</code> <code>play_sound</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> <code>sound_name</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def display_instructions(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        display_time: int | None = None,\n        instruction_panel_position: int | None = None,\n        play_sound: int | None = None,\n        message: str | None = None,\n        sound_name: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DISPLAY_INSTRUCTIONS,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        string_id=string_id,\n        display_time=display_time,\n        instruction_panel_position=instruction_panel_position,\n        play_sound=play_sound,\n        message=message,\n        sound_name=sound_name,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.display_timer","title":"<code>def display_timer(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>display_time</code> <code>int | None</code>  - <code>None</code> <code>time_unit</code> <code>int | None</code>  - <code>None</code> <code>timer</code> <code>int | None</code>  - <code>None</code> <code>reset_timer</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def display_timer(\n        self,\n        string_id: int | None = None,\n        display_time: int | None = None,\n        time_unit: int | None = None,\n        timer: int | None = None,\n        reset_timer: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.DISPLAY_TIMER,\n        string_id=string_id,\n        display_time=display_time,\n        time_unit=time_unit,\n        timer=timer,\n        reset_timer=reset_timer,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_disable_object","title":"<code>def enable_disable_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>enabled</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_disable_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        enabled: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_DISABLE_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        enabled=enabled,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_disable_technology","title":"<code>def enable_disable_technology(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>enabled</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_disable_technology(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        enabled: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_DISABLE_TECHNOLOGY,\n        source_player=source_player,\n        technology=technology,\n        enabled=enabled,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_object_deletion","title":"<code>def enable_object_deletion(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_object_deletion(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_OBJECT_DELETION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_object_selection","title":"<code>def enable_object_selection(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_object_selection(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_OBJECT_SELECTION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_technology_stacking","title":"<code>def enable_technology_stacking(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>quantity</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_technology_stacking(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        quantity: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_TECHNOLOGY_STACKING,\n        source_player=source_player,\n        technology=technology,\n        quantity=quantity,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.enable_unit_targeting","title":"<code>def enable_unit_targeting(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def enable_unit_targeting(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.ENABLE_UNIT_TARGETING,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.freeze_object","title":"<code>def freeze_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def freeze_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.FREEZE_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.heal_object","title":"<code>def heal_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def heal_object(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.HEAL_OBJECT,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.initiate_research","title":"<code>def initiate_research(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def initiate_research(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.INITIATE_RESEARCH,\n        source_player=source_player,\n        technology=technology,\n        selected_object_ids=selected_object_ids\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.kill_object","title":"<code>def kill_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def kill_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.KILL_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.lock_gate","title":"<code>def lock_gate(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def lock_gate(\n        self,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.LOCK_GATE,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.modify_attribute","title":"<code>def modify_attribute(...)</code>","text":"<p>The parameters 'armour_attack_quantity' and 'armour_attack_class' are only used when object_attributes is Armor or Attack (8 or 9). Use, 'quantity' otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_quantity</code> <code>int | None</code>  - <code>None</code> <code>armour_attack_class</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>object_attributes</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def modify_attribute(\n        self,\n        quantity: int | None = None,\n        armour_attack_quantity: int | None = None,\n        armour_attack_class: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        operation: int | None = None,\n        object_attributes: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    \"\"\"\n    The parameters 'armour_attack_quantity' and 'armour_attack_class' are only used when object_attributes is Armor\n    or Attack (8 or 9). Use, 'quantity' otherwise.\n    \"\"\"\n    if (armour_attack_quantity is not None or armour_attack_class is not None) and quantity is not None:\n        raise ValueError(\"Cannot use 'armour_attack' attributes together with the 'quantity' attribute.\")\n\n    return self._trigger_ref._add_effect(\n        EffectId.MODIFY_ATTRIBUTE,\n        quantity=quantity,\n        armour_attack_quantity=armour_attack_quantity,\n        armour_attack_class=armour_attack_class,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        operation=operation,\n        object_attributes=object_attributes,\n        message=message\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.modify_attribute_by_variable","title":"<code>def modify_attribute_by_variable(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>object_attributes</code> <code>int | None</code>  - <code>None</code> <code>variable</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def modify_attribute_by_variable(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        operation: int | None = None,\n        object_attributes: int | None = None,\n        variable: int | None = None,\n        message: str | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.MODIFY_ATTRIBUTE_BY_VARIABLE,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        operation=operation,\n        object_attributes=object_attributes,\n        variable=variable,\n        message=message\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.modify_resource","title":"<code>def modify_resource(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>tribute_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def modify_resource(\n        self,\n        quantity: int | None = None,\n        tribute_list: int | None = None,\n        source_player: int | None = None,\n        operation: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.MODIFY_RESOURCE,\n        quantity=quantity,\n        tribute_list=tribute_list,\n        source_player=source_player,\n        operation=operation,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.modify_resource_by_variable","title":"<code>def modify_resource_by_variable(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tribute_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>operation</code> <code>int | None</code>  - <code>None</code> <code>variable</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def modify_resource_by_variable(\n        self,\n        tribute_list: int | None = None,\n        source_player: int | None = None,\n        operation: int | None = None,\n        variable: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.MODIFY_RESOURCE_BY_VARIABLE,\n        tribute_list=tribute_list,\n        source_player=source_player,\n        operation=operation,\n        variable=variable,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.none","title":"<code>def none(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def none(\n        self,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.NONE,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.patrol","title":"<code>def patrol(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def patrol(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.PATROL,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.place_foundation","title":"<code>def place_foundation(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def place_foundation(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.PLACE_FOUNDATION,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.play_sound","title":"<code>def play_sound(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>location_object_reference</code> <code>int | None</code>  - <code>None</code> <code>sound_name</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def play_sound(\n        self,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        location_object_reference: int | None = None,\n        sound_name: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.PLAY_SOUND,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        location_object_reference=location_object_reference,\n        sound_name=sound_name,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.remove_object","title":"<code>def remove_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>object_state</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def remove_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        object_state: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.REMOVE_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        object_state=object_state,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.replace_object","title":"<code>def replace_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id_2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def replace_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        target_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        object_list_unit_id_2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.REPLACE_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        target_player=target_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        object_list_unit_id_2=object_list_unit_id_2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.research_technology","title":"<code>def research_technology(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>technology</code> <code>int | None</code>  - <code>None</code> <code>force_research_technology</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def research_technology(\n        self,\n        source_player: int | None = None,\n        technology: int | None = None,\n        force_research_technology: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.RESEARCH_TECHNOLOGY,\n        source_player=source_player,\n        technology=technology,\n        force_research_technology=force_research_technology,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.script_call","title":"<code>def script_call(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def script_call(\n        self,\n        string_id: int | None = None,\n        message: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.SCRIPT_CALL,\n        string_id=string_id,\n        message=message,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.send_chat","title":"<code>def send_chat(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>string_id</code> <code>int | None</code>  - <code>None</code> <code>message</code> <code>str | None</code>  - <code>None</code> <code>sound_name</code> <code>str | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def send_chat(\n        self,\n        source_player: int | None = None,\n        string_id: int | None = None,\n        message: str | None = None,\n        sound_name: str | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.SEND_CHAT,\n        source_player=source_player,\n        string_id=string_id,\n        message=message,\n        sound_name=sound_name,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.set_building_gather_point","title":"<code>def set_building_gather_point(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def set_building_gather_point(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.SET_BUILDING_GATHER_POINT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.set_player_visibility","title":"<code>def set_player_visibility(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> <code>visibility_state</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def set_player_visibility(\n        self,\n        source_player: int | None = None,\n        target_player: int | None = None,\n        visibility_state: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.SET_PLAYER_VISIBILITY,\n        source_player=source_player,\n        target_player=target_player,\n        visibility_state=visibility_state,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.stop_object","title":"<code>def stop_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def stop_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.STOP_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.task_object","title":"<code>def task_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>location_object_reference</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>action_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def task_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        location_object_reference: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        action_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.TASK_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        location_object_reference=location_object_reference,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        action_type=action_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.teleport_object","title":"<code>def teleport_object(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def teleport_object(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.TELEPORT_OBJECT,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.train_unit","title":"<code>def train_unit(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def train_unit(\n        self,\n        quantity: int | None = None,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n):\n    return self._trigger_ref._add_effect(\n        EffectId.TRAIN_UNIT,\n        quantity=quantity,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        selected_object_ids=selected_object_ids\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.tribute","title":"<code>def tribute(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>int | None</code>  - <code>None</code> <code>tribute_list</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>target_player</code> <code>int | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def tribute(\n        self,\n        quantity: int | None = None,\n        tribute_list: int | None = None,\n        source_player: int | None = None,\n        target_player: int | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.TRIBUTE,\n        quantity=quantity,\n        tribute_list=tribute_list,\n        source_player=source_player,\n        target_player=target_player,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.unload","title":"<code>def unload(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>object_list_unit_id</code> <code>int | None</code>  - <code>None</code> <code>source_player</code> <code>int | None</code>  - <code>None</code> <code>location_x</code> <code>int | None</code>  - <code>None</code> <code>location_y</code> <code>int | None</code>  - <code>None</code> <code>location_object_reference</code> <code>int | None</code>  - <code>None</code> <code>area_x1</code> <code>int | None</code>  - <code>None</code> <code>area_y1</code> <code>int | None</code>  - <code>None</code> <code>area_x2</code> <code>int | None</code>  - <code>None</code> <code>area_y2</code> <code>int | None</code>  - <code>None</code> <code>object_group</code> <code>int | None</code>  - <code>None</code> <code>object_type</code> <code>int | None</code>  - <code>None</code> <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def unload(\n        self,\n        object_list_unit_id: int | None = None,\n        source_player: int | None = None,\n        location_x: int | None = None,\n        location_y: int | None = None,\n        location_object_reference: int | None = None,\n        area_x1: int | None = None,\n        area_y1: int | None = None,\n        area_x2: int | None = None,\n        area_y2: int | None = None,\n        object_group: int | None = None,\n        object_type: int | None = None,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.UNLOAD,\n        object_list_unit_id=object_list_unit_id,\n        source_player=source_player,\n        location_x=location_x,\n        location_y=location_y,\n        location_object_reference=location_object_reference,\n        area_x1=area_x1,\n        area_y1=area_y1,\n        area_x2=area_x2,\n        area_y2=area_y2,\n        object_group=object_group,\n        object_type=object_type,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.unlock_gate","title":"<code>def unlock_gate(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>selected_object_ids</code> <code>int | List[int] | None</code>  - <code>None</code> Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def unlock_gate(\n        self,\n        selected_object_ids: int | List[int] | None = None,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.UNLOCK_GATE,\n        selected_object_ids=selected_object_ids,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect.NewEffectSupport.use_advanced_buttons","title":"<code>def use_advanced_buttons(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/support/new_effect.py</code> <pre><code>def use_advanced_buttons(\n        self,\n) -&gt; Effect:\n    return self._trigger_ref._add_effect(\n        EffectId.USE_ADVANCED_BUTTONS,\n    )\n</code></pre>"},{"location":"api_docs/trigger/effects/new_effect/#AoE2ScenarioParser.objects.support.new_effect-functions","title":"Functions","text":""},{"location":"api_docs/units/unit/","title":"Unit","text":""},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit-classes","title":"Classes","text":""},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>A class representing a single unit on the map. This can be an archer, a gold mine, a house or even a tree.</p> Source code in <code>AoE2ScenarioParser/objects/data_objects/unit.py</code> <pre><code>class Unit(AoE2Object):\n    \"\"\"\n    A class representing a single unit on the map.\n    This can be an archer, a gold mine, a house or even a tree.\n    \"\"\"\n    _link_list = [\n        RetrieverObjectLink(\"player\", retrieve_history_number=0),\n        RetrieverObjectLinkGroup(\"Units\", \"players_units[__index__].units[__index__]\", group=[\n            RetrieverObjectLink(\"x\"),\n            RetrieverObjectLink(\"y\"),\n            RetrieverObjectLink(\"z\"),\n            RetrieverObjectLink(\"reference_id\"),\n            RetrieverObjectLink(\"unit_const\"),\n            RetrieverObjectLink(\"status\"),\n            RetrieverObjectLink(\"rotation\"),\n            RetrieverObjectLink(\"initial_animation_frame\"),\n            RetrieverObjectLink(\"garrisoned_in_id\"),\n        ])\n    ]\n\n    def __init__(self,\n                 player: int | PlayerId,\n                 x: float,\n                 y: float,\n                 z: float,\n                 reference_id: int,\n                 unit_const: int,\n                 status: int,\n                 rotation: float,\n                 initial_animation_frame: int,\n                 garrisoned_in_id: int,\n                 **kwargs\n                 ):\n        raise_if_not_int_subclass([unit_const])\n\n        super().__init__(**kwargs)\n\n        self._player: PlayerId = PlayerId(player)\n        self.x: float = x\n        self.y: float = y\n        self.z: float = z\n        self.reference_id: int = reference_id\n        self.unit_const: int = unit_const\n        self.status: int = status\n        self.rotation: float = rotation\n        self.initial_animation_frame: int = initial_animation_frame\n        self.garrisoned_in_id: int = garrisoned_in_id\n\n    @property\n    def player(self) -&gt; PlayerId:\n        \"\"\"The player that owns this unit\"\"\"\n        return self._player\n\n    @player.setter\n    def player(self, player: int | PlayerId):\n        actions.unit_change_ownership(self._uuid, player, self)\n        self._player = player\n\n    @property\n    def tile(self) -&gt; Tile:\n        \"\"\"The tile where the unit is located\"\"\"\n        return Tile(math.floor(self.x), math.floor(self.y))\n        # Floor x and y as location (0.9, 0.9) is still Tile[x=0, y=0]\n\n    @tile.setter\n    def tile(self, tile: Tile) -&gt; None:\n        self.x = tile.x\n        self.y = tile.y\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of the unit, nicely formatted\"\"\"\n        unit_enum = helper.get_enum_from_unit_const(self.unit_const)\n        if unit_enum:\n            return pretty_format_name(unit_enum.name)\n        else:\n            return f\"Unknown{self.unit_const}\"  # e.g.\"Unknown411\"\n</code></pre>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit-attributes","title":"Attributes","text":""},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.garrisoned_in_id","title":"<code>garrisoned_in_id: int = garrisoned_in_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>garrisoned_in_id</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.initial_animation_frame","title":"<code>initial_animation_frame: int = initial_animation_frame</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>initial_animation_frame</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.name","title":"<code>name: str</code>  <code>property</code>","text":"Type: <code>str</code> <p>The name of the unit, nicely formatted</p>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.player","title":"<code>player: PlayerId</code>  <code>property</code> <code>writable</code>","text":"Type: <code>PlayerId</code> <p>The player that owns this unit</p>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.reference_id","title":"<code>reference_id: int = reference_id</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>reference_id</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.rotation","title":"<code>rotation: float = rotation</code>  <code>instance-attribute</code>","text":"Type: <code>float</code>                           Value: <code>rotation</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.status","title":"<code>status: int = status</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>status</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.tile","title":"<code>tile: Tile</code>  <code>property</code> <code>writable</code>","text":"Type: <code>Tile</code> <p>The tile where the unit is located</p>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.unit_const","title":"<code>unit_const: int = unit_const</code>  <code>instance-attribute</code>","text":"Type: <code>int</code>                           Value: <code>unit_const</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.x","title":"<code>x: float = x</code>  <code>instance-attribute</code>","text":"Type: <code>float</code>                           Value: <code>x</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.y","title":"<code>y: float = y</code>  <code>instance-attribute</code>","text":"Type: <code>float</code>                           Value: <code>y</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.z","title":"<code>z: float = z</code>  <code>instance-attribute</code>","text":"Type: <code>float</code>                           Value: <code>z</code>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit-functions","title":"Functions","text":""},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit.Unit.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>player</code> <code>int | PlayerId</code>  - required <code>x</code> <code>float</code>  - required <code>y</code> <code>float</code>  - required <code>z</code> <code>float</code>  - required <code>reference_id</code> <code>int</code>  - required <code>unit_const</code> <code>int</code>  - required <code>status</code> <code>int</code>  - required <code>rotation</code> <code>float</code>  - required <code>initial_animation_frame</code> <code>int</code>  - required <code>garrisoned_in_id</code> <code>int</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/data_objects/unit.py</code> <pre><code>def __init__(self,\n             player: int | PlayerId,\n             x: float,\n             y: float,\n             z: float,\n             reference_id: int,\n             unit_const: int,\n             status: int,\n             rotation: float,\n             initial_animation_frame: int,\n             garrisoned_in_id: int,\n             **kwargs\n             ):\n    raise_if_not_int_subclass([unit_const])\n\n    super().__init__(**kwargs)\n\n    self._player: PlayerId = PlayerId(player)\n    self.x: float = x\n    self.y: float = y\n    self.z: float = z\n    self.reference_id: int = reference_id\n    self.unit_const: int = unit_const\n    self.status: int = status\n    self.rotation: float = rotation\n    self.initial_animation_frame: int = initial_animation_frame\n    self.garrisoned_in_id: int = garrisoned_in_id\n</code></pre>"},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit-functions","title":"Functions","text":""},{"location":"api_docs/units/unit/#AoE2ScenarioParser.objects.data_objects.unit-modules","title":"Modules","text":""},{"location":"api_docs/units/unit_manager/","title":"UnitManager","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager-classes","title":"Classes","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager","title":"<code>UnitManager</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of everything unit related.</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>class UnitManager(AoE2Object):\n    \"\"\"Manager of everything unit related.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLink(\"_player_units\", \"Units\", \"players_units\", process_as_object=PlayerUnits),\n        RetrieverObjectLink(\"next_unit_id\", \"DataHeader\", \"next_unit_id_to_place\")\n    ]\n\n    def __init__(\n            self,\n            _player_units: List[PlayerUnits],\n            next_unit_id: int,\n            **kwargs\n    ):\n        super().__init__(**kwargs)\n\n        self.units = [pu.units for pu in _player_units]\n        self.reference_id_generator = create_id_generator(next_unit_id)\n\n    @property\n    def next_unit_id(self):\n        return self.get_new_reference_id()\n\n    @property\n    def units(self):\n        return self._units\n\n    @units.setter\n    def units(self, value: List[List[Unit]]):\n        def _raise():\n            raise ValueError(\"Units should be list with a maximum of 9 sub lists, example: [[Unit], [Unit, Unit], ...]\")\n\n        if len(value) &gt; 9:\n            _raise()\n        elif len(value) &lt; 9:\n            value.extend([[] for _ in range(9 - len(value))])\n\n        self._units = UuidList(self._uuid, value)\n\n    def update_unit_player_values(self):\n        \"\"\"Function to update all player values in all units. Useful when units are moved manually (in mass).\"\"\"\n        for player in PlayerId.all():\n            for unit in self.units[player]:\n                unit._player = player\n\n    def clone_unit(\n            self,\n            unit: Unit,\n            player: int | PlayerId = None,\n            unit_const: int = None,\n            x: float = None,\n            y: float = None,\n            z: float = None,\n            rotation: float = None,\n            garrisoned_in_id: int = None,\n            animation_frame: int = None,\n            status: int = None,\n            reference_id: int = None,\n            tile: Tile | Tuple[int, int] = None,\n    ) -&gt; Unit:\n        \"\"\"\n        Clones an existing unit with the adjusted variables. Everything except the initial unit is optional.\n        When arguments are provided, they will override the corresponding values in the cloned unit.\n\n        Args:\n            unit: The unit to clone\n            player: The player to set the cloned unit to (If not provided, the original player will be used)\n            unit_const: The unit you're placing (If not provided, the original unit constant will be used)\n            x: The X coordinate of the cloned unit (If not provided, the original x coordinate will be used)\n            y: The Y coordinate of the cloned unit (If not provided, the original y coordinate will be used)\n            z: The Z coordinate of the cloned unit (If not provided, the original z coordinate will be used)\n            rotation: The rotation of the cloned unit (If not provided, the original rotation will be used)\n            garrisoned_in_id: The id of the garrisoned unit (If not provided, the original garrisoned id will be used)\n            animation_frame: The animation frame of the cloned unit (If not provided, the original animation frame will be used)\n            status: The status of the cloned unit (If not provided, the original status will be used)\n            reference_id: Reference id of the cloned unit (If not provided, a new reference id will be generated)\n            tile: The tile of the cloned unit (If not provided, the original x,y coordinates will be used)\n\n        Returns:\n            The cloned unit\n        \"\"\"\n\n        if (x is not None or y is not None) and tile is not None:\n            raise ValueError(\"Cannot use both x,y notation and tile notation at the same time\")\n\n        return self.add_unit(\n            player=player or unit.player,\n            unit_const=unit_const or unit.unit_const,\n            x=x or unit.x,\n            y=y or unit.y,\n            z=z or unit.z,\n            rotation=rotation or unit.rotation,\n            garrisoned_in_id=garrisoned_in_id or unit.garrisoned_in_id,\n            animation_frame=animation_frame or unit.initial_animation_frame,\n            status=status or unit.status,\n            reference_id=reference_id,\n            tile=tile,\n        )\n\n    def add_unit(\n            self,\n            player: int | PlayerId,\n            unit_const: int,\n            x: float = 0,\n            y: float = 0,\n            z: float = 0,\n            rotation: float = 0,\n            garrisoned_in_id: int = -1,\n            animation_frame: int = 0,\n            status: int = 2,\n            reference_id: int = None,\n            tile: Tile | Tuple[int, int] = None,\n    ) -&gt; Unit:\n        \"\"\"\n        Adds a unit to the scenario.\n\n        Args:\n            player: The player the unit belongs to.\n            unit_const: Defines what unit you're placing. The IDs used in the unit/buildings dataset.\n            x: The x location in the scenario.\n            y: The y location in the scenario.\n            z: The z (height) location in the scenario.\n            rotation: The rotation of the unit.\n            garrisoned_in_id: The reference_id of another unit this unit is garrisoned in.\n            animation_frame: The animation frame of the unit.\n            status: Unknown - Always 2. 0-6 no difference (?) | 7-255 makes it disappear. (Except from the mini-map)\n            reference_id: The reference ID of this unit. Normally added automatically. Used for garrisoning or reference\n                in triggers\n            tile: An object that represents a tile on the map. Replaces parameters x and y. Also, automatically adds\n                .5 to both ints to place the unit centered on the tile.\n\n        Returns:\n            The Unit created\n        \"\"\"\n        if reference_id is None:\n            reference_id = self.get_new_reference_id()\n\n        unit = Unit(\n            player=player,\n            x=x if tile is None else (tile[0] + .5),\n            y=y if tile is None else (tile[1] + .5),\n            z=z,\n            reference_id=reference_id,\n            unit_const=unit_const,\n            status=status,\n            rotation=rotation,\n            initial_animation_frame=animation_frame,\n            garrisoned_in_id=garrisoned_in_id,\n            uuid=self._uuid\n        )\n\n        self.units[player].append(unit)\n        return unit\n\n    def get_player_units(self, player: int | PlayerId) -&gt; List[Unit]:\n        \"\"\"\n        Returns a list of UnitObjects for the given player.\n\n        Raises:\n            ValueError: If player is not between 0 (GAIA) and 8 (EIGHT)\n        \"\"\"\n        if not 0 &lt;= player &lt;= 8:\n            raise ValueError(\"Player must have a value between 0 and 8\")\n        return self.units[player]\n\n    def get_all_units(self) -&gt; List[Unit]:\n        units = []\n        for player_units in self.units:\n            units += player_units\n        return units\n\n    def filter_units_by(\n            self,\n            attr: str,\n            unit_attrs: List[int],\n            blacklist: bool = False,\n            player_list: List[Union[int, PlayerId]] = None,\n            unit_list: List[Unit] = None\n    ) -&gt; List[Unit]:\n        \"\"\"\n        Filter units based on a given attribute of units\n\n        Args:\n            attr: The attribute to filter by\n            unit_attrs: The values for the attributes to filter with\n            blacklist: Use the given constant list as blacklist instead of whitelist\n            player_list: A list of players to filter from. If not used, all players are used.\n            unit_list: A set of units to filter from. If not used, all units are used.\n\n        Returns:\n            A list of units\n\n        Raises:\n            AttributeError: If the provided attr does not exist on objects of the Unit class\n        \"\"\"\n\n        if unit_list is None:\n            unit_list = self.get_all_units()\n        if player_list is not None:\n            unit_list = [unit for unit in unit_list if unit.player in player_list]\n\n        if len(unit_list) == 0:\n            return []\n\n        unit = unit_list[0]\n        if not hasattr(unit, attr):\n            raise AttributeError(f\"Cannot filter Unit objects by {attr}\")\n\n        # Both return statements can be combined using: ((unit.unit_const in unit_consts) != blacklist)\n        # But splitting them helps performance (not checking against blacklist for each entry)\n        if not blacklist:\n            return [unit for unit_attr in unit_attrs for unit in unit_list if getattr(unit, attr) == unit_attr]\n        return [unit for unit_attr in unit_attrs for unit in unit_list if getattr(unit, attr) != unit_attr]\n\n    def filter_units_by_const(\n            self,\n            unit_consts: List[int],\n            blacklist: bool = False,\n            player_list: List[Union[int, PlayerId]] = None,\n            unit_list: List[Unit] = None\n    ) -&gt; List[Unit]:\n        \"\"\"\n        Filter unit on their unit_const value.\n\n        Args:\n            unit_consts: The constants to filter with\n            blacklist: Use the given constant list as blacklist instead of whitelist\n            player_list: A list of players to filter from. If not used, all players are used.\n            unit_list: A set of units to filter from. If not used, all units are used.\n\n        Returns:\n            A list of units\n        \"\"\"\n        return self.filter_units_by(\"unit_const\", unit_consts, blacklist, player_list, unit_list)\n\n    def filter_units_by_reference_id(\n            self,\n            unit_reference_ids: List[int],\n            blacklist: bool = False,\n            player_list: List[Union[int, PlayerId]] = None,\n            unit_list: List[Unit] = None\n    ) -&gt; List[Unit]:\n        \"\"\"\n        Filter unit on their unit_const value.\n\n        Args:\n            unit_reference_ids (List[int]): The reference_ids to filter with\n            blacklist (bool): Use the given constant list as blacklist instead of whitelist\n            player_list (List[int]): A list of players to filter from. If not used, all players are used.\n            unit_list (List[Unit]): A set of units to filter from. If not used, all units are used.\n\n        Returns:\n            A list of units\n        \"\"\"\n        return self.filter_units_by(\"reference_id\", unit_reference_ids, blacklist, player_list, unit_list)\n\n    def get_units_in_area(\n            self,\n            x1: float = None,\n            y1: float = None,\n            x2: float = None,\n            y2: float = None,\n            tile1: Tile = None,\n            tile2: Tile = None,\n            unit_list: List[Unit] = None,\n            players: List[Union[int, PlayerId]] = None,\n            ignore_players: List[PlayerId] = None\n    ) -&gt; List[Unit]:\n        \"\"\"\n        Returns all units in the square with left corner (x1, y1) and right corner (x2, y2). Both corners inclusive.\n\n        Args:\n            x1: The X location of the left corner\n            y1: The Y location of the left corner\n            x2: The X location of the right corner\n            y2: The Y location of the right corner\n            tile1: The x,y location of the 1st corner as Tile Object\n            tile2: The x,y location of the 2nd corner as Tile Object\n            unit_list: (Optional) A list of units (Defaults to all units in the map, including GAIA (Trees etc.)\n            players: (Optional) A list of Players which units need to be selected from the selected area\n            ignore_players: (Optional) A list of Players which units need to be ignored from the selected area\n\n        Raises:\n            ValueError: if not all 4 (x1, y1, x2 and y2) are used simultaneously.\n                Or if both (tile1 and tile2) are not used simultaneously.\n                Or if any of the 4 (x1, y1, x2, y2) is used together with any of (tile1, tile2). Use one or the other.\n                Or if players and ignore_players are used simultaneously.\n        \"\"\"\n        if (x1 is not None or y1 is not None or x2 is not None or y2 is not None) and any([tile1, tile2]):\n            raise ValueError(\"Cannot use both x1,y1,x2,y2 notation and tile1,tile2 notation at the same time\")\n        if (x1 is not None or y1 is not None or x2 is not None or y2 is not None) and \\\n                (x1 is None or y1 is None or x2 is None or y2 is None):\n            raise ValueError(\"Cannot use some but not all from x1,y1,x2,y2.\")\n        if (not all([tile1, tile2])) and any([tile1, tile2]):\n            raise ValueError(\"Cannot use one from tile1, tile2. Use both.\")\n        if players is not None and ignore_players is not None:\n            raise ValueError(\"Cannot use both whitelist (players) and blacklist (ignore_players) at the same time\")\n\n        if tile1:\n            x1 = tile1.x\n            y1 = tile1.y\n            x2 = tile2.x\n            y2 = tile2.y\n        else:\n            # Inclusive selection\n            x2 += 1\n            y2 += 1\n\n        if players is not None:\n            players = players\n        elif ignore_players is not None:\n            players = [p for p in PlayerId if p not in ignore_players]\n        else:\n            players = [p for p in PlayerId]\n\n        if unit_list is None:\n            unit_list = self.get_all_units()\n\n        return [unit for unit in unit_list if x1 &lt;= unit.x &lt;= x2 and y1 &lt;= unit.y &lt;= y2 and unit.player in players]\n\n    @staticmethod\n    def change_ownership(unit: Unit | List[Unit], to_player: int | PlayerId) -&gt; None:\n        \"\"\"\n        Changes a unit's ownership to the given player.\n\n        Args:\n            unit: The unit object which ownership will be changed\n            to_player: The player that'll get ownership over the unit (using PlayerId enum)\n        \"\"\"\n        if isinstance(unit, list):\n            for u in unit:\n                u.player = to_player\n        else:\n            unit.player = to_player\n\n    def get_new_reference_id(self) -&gt; int:\n        \"\"\"\n        Get a new ID each time the function is called. Starting from the current highest ID.\n\n        Returns:\n            The newly generated ID\n        \"\"\"\n        return next(self.reference_id_generator)\n\n    def find_highest_reference_id(self) -&gt; int:\n        \"\"\"\n        Find the highest ID in the map. Searches through all units for the highest ID.\n\n        Returns:\n            The highest ID in the map\n        \"\"\"\n        highest_id = 0  # If no units, default to 0\n        for player in PlayerId.all():\n            for unit in self.units[player]:\n                highest_id = max(highest_id, unit.reference_id)\n        return highest_id\n\n    def remove_unit(self, reference_id: int = None, unit: Unit = None) -&gt; None:\n        \"\"\"\n        Removes a unit. Please note that `unit=...` is a lot faster than `reference_id=...` due to reference_id having\n        to search through all units on the map. And unit has an ownership (player) attribute which is used for knowing\n        which list to remove the unit from.\n\n        Args:\n            reference_id: The id of the unit. Note that this is NOT a unit constant (So NOT: UnitInfo.ARCHER)\n            unit: The Unit object to be removed.\n        \"\"\"\n        if reference_id is not None and unit is not None:\n            raise ValueError(\"Cannot use both unit_ref_id and unit arguments. Use one or the other.\")\n        if reference_id is None and unit is None:\n            raise ValueError(\"Both unit_ref_id and unit arguments were unused. Use one.\")\n\n        if reference_id is not None:\n            for player in range(0, 9):\n                for i, unit in enumerate(self.units[player]):\n                    if unit.reference_id == reference_id:\n                        del self.units[player][i]\n                        return\n        elif unit is not None:\n            self.units[unit.player].remove(unit)\n\n    def remove_eye_candy(self) -&gt; None:\n        eye_candy_ids = [1351, 1352, 1353, 1354, 1355, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366]\n        self.units[0] = [gaia_unit for gaia_unit in self.units[0] if gaia_unit.unit_const not in eye_candy_ids]\n\n    # ###############################################################################################\n    # ################################# Functions for reconstruction ################################\n    # ###############################################################################################\n\n    @property\n    def _player_units(self):\n        player_units = []\n        for i in range(9):\n            units = self.get_player_units(i)\n            player_units.append(PlayerUnits(unit_count=len(units), units=units))\n\n        return UuidList(self._uuid, player_units)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager-attributes","title":"Attributes","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.next_unit_id","title":"<code>next_unit_id</code>  <code>property</code>","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.reference_id_generator","title":"<code>reference_id_generator = create_id_generator(next_unit_id)</code>  <code>instance-attribute</code>","text":"Value: <code>create_id_generator(next_unit_id)</code>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.units","title":"<code>units</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager-functions","title":"Functions","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>_player_units</code> <code>List[PlayerUnits]</code>  - required <code>next_unit_id</code> <code>int</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def __init__(\n        self,\n        _player_units: List[PlayerUnits],\n        next_unit_id: int,\n        **kwargs\n):\n    super().__init__(**kwargs)\n\n    self.units = [pu.units for pu in _player_units]\n    self.reference_id_generator = create_id_generator(next_unit_id)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.add_unit","title":"<code>def add_unit(...)</code>","text":"<p>Adds a unit to the scenario.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>int | PlayerId</code> <p>The player the unit belongs to.</p> required <code>unit_const</code> <code>int</code> <p>Defines what unit you're placing. The IDs used in the unit/buildings dataset.</p> required <code>x</code> <code>float</code> <p>The x location in the scenario.</p> <code>0</code> <code>y</code> <code>float</code> <p>The y location in the scenario.</p> <code>0</code> <code>z</code> <code>float</code> <p>The z (height) location in the scenario.</p> <code>0</code> <code>rotation</code> <code>float</code> <p>The rotation of the unit.</p> <code>0</code> <code>garrisoned_in_id</code> <code>int</code> <p>The reference_id of another unit this unit is garrisoned in.</p> <code>-1</code> <code>animation_frame</code> <code>int</code> <p>The animation frame of the unit.</p> <code>0</code> <code>status</code> <code>int</code> <p>Unknown - Always 2. 0-6 no difference (?) | 7-255 makes it disappear. (Except from the mini-map)</p> <code>2</code> <code>reference_id</code> <code>int</code> <p>The reference ID of this unit. Normally added automatically. Used for garrisoning or reference in triggers</p> <code>None</code> <code>tile</code> <code>Tile | Tuple[int, int]</code> <p>An object that represents a tile on the map. Replaces parameters x and y. Also, automatically adds .5 to both ints to place the unit centered on the tile.</p> <code>None</code> <p>Returns:</p> Type Description <code>Unit</code> <p>The Unit created</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def add_unit(\n        self,\n        player: int | PlayerId,\n        unit_const: int,\n        x: float = 0,\n        y: float = 0,\n        z: float = 0,\n        rotation: float = 0,\n        garrisoned_in_id: int = -1,\n        animation_frame: int = 0,\n        status: int = 2,\n        reference_id: int = None,\n        tile: Tile | Tuple[int, int] = None,\n) -&gt; Unit:\n    \"\"\"\n    Adds a unit to the scenario.\n\n    Args:\n        player: The player the unit belongs to.\n        unit_const: Defines what unit you're placing. The IDs used in the unit/buildings dataset.\n        x: The x location in the scenario.\n        y: The y location in the scenario.\n        z: The z (height) location in the scenario.\n        rotation: The rotation of the unit.\n        garrisoned_in_id: The reference_id of another unit this unit is garrisoned in.\n        animation_frame: The animation frame of the unit.\n        status: Unknown - Always 2. 0-6 no difference (?) | 7-255 makes it disappear. (Except from the mini-map)\n        reference_id: The reference ID of this unit. Normally added automatically. Used for garrisoning or reference\n            in triggers\n        tile: An object that represents a tile on the map. Replaces parameters x and y. Also, automatically adds\n            .5 to both ints to place the unit centered on the tile.\n\n    Returns:\n        The Unit created\n    \"\"\"\n    if reference_id is None:\n        reference_id = self.get_new_reference_id()\n\n    unit = Unit(\n        player=player,\n        x=x if tile is None else (tile[0] + .5),\n        y=y if tile is None else (tile[1] + .5),\n        z=z,\n        reference_id=reference_id,\n        unit_const=unit_const,\n        status=status,\n        rotation=rotation,\n        initial_animation_frame=animation_frame,\n        garrisoned_in_id=garrisoned_in_id,\n        uuid=self._uuid\n    )\n\n    self.units[player].append(unit)\n    return unit\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.change_ownership","title":"<code>def change_ownership(...)</code>  <code>staticmethod</code>","text":"<p>Changes a unit's ownership to the given player.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit | List[Unit]</code> <p>The unit object which ownership will be changed</p> required <code>to_player</code> <code>int | PlayerId</code> <p>The player that'll get ownership over the unit (using PlayerId enum)</p> required Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>@staticmethod\ndef change_ownership(unit: Unit | List[Unit], to_player: int | PlayerId) -&gt; None:\n    \"\"\"\n    Changes a unit's ownership to the given player.\n\n    Args:\n        unit: The unit object which ownership will be changed\n        to_player: The player that'll get ownership over the unit (using PlayerId enum)\n    \"\"\"\n    if isinstance(unit, list):\n        for u in unit:\n            u.player = to_player\n    else:\n        unit.player = to_player\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.clone_unit","title":"<code>def clone_unit(...)</code>","text":"<p>Clones an existing unit with the adjusted variables. Everything except the initial unit is optional. When arguments are provided, they will override the corresponding values in the cloned unit.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The unit to clone</p> required <code>player</code> <code>int | PlayerId</code> <p>The player to set the cloned unit to (If not provided, the original player will be used)</p> <code>None</code> <code>unit_const</code> <code>int</code> <p>The unit you're placing (If not provided, the original unit constant will be used)</p> <code>None</code> <code>x</code> <code>float</code> <p>The X coordinate of the cloned unit (If not provided, the original x coordinate will be used)</p> <code>None</code> <code>y</code> <code>float</code> <p>The Y coordinate of the cloned unit (If not provided, the original y coordinate will be used)</p> <code>None</code> <code>z</code> <code>float</code> <p>The Z coordinate of the cloned unit (If not provided, the original z coordinate will be used)</p> <code>None</code> <code>rotation</code> <code>float</code> <p>The rotation of the cloned unit (If not provided, the original rotation will be used)</p> <code>None</code> <code>garrisoned_in_id</code> <code>int</code> <p>The id of the garrisoned unit (If not provided, the original garrisoned id will be used)</p> <code>None</code> <code>animation_frame</code> <code>int</code> <p>The animation frame of the cloned unit (If not provided, the original animation frame will be used)</p> <code>None</code> <code>status</code> <code>int</code> <p>The status of the cloned unit (If not provided, the original status will be used)</p> <code>None</code> <code>reference_id</code> <code>int</code> <p>Reference id of the cloned unit (If not provided, a new reference id will be generated)</p> <code>None</code> <code>tile</code> <code>Tile | Tuple[int, int]</code> <p>The tile of the cloned unit (If not provided, the original x,y coordinates will be used)</p> <code>None</code> <p>Returns:</p> Type Description <code>Unit</code> <p>The cloned unit</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def clone_unit(\n        self,\n        unit: Unit,\n        player: int | PlayerId = None,\n        unit_const: int = None,\n        x: float = None,\n        y: float = None,\n        z: float = None,\n        rotation: float = None,\n        garrisoned_in_id: int = None,\n        animation_frame: int = None,\n        status: int = None,\n        reference_id: int = None,\n        tile: Tile | Tuple[int, int] = None,\n) -&gt; Unit:\n    \"\"\"\n    Clones an existing unit with the adjusted variables. Everything except the initial unit is optional.\n    When arguments are provided, they will override the corresponding values in the cloned unit.\n\n    Args:\n        unit: The unit to clone\n        player: The player to set the cloned unit to (If not provided, the original player will be used)\n        unit_const: The unit you're placing (If not provided, the original unit constant will be used)\n        x: The X coordinate of the cloned unit (If not provided, the original x coordinate will be used)\n        y: The Y coordinate of the cloned unit (If not provided, the original y coordinate will be used)\n        z: The Z coordinate of the cloned unit (If not provided, the original z coordinate will be used)\n        rotation: The rotation of the cloned unit (If not provided, the original rotation will be used)\n        garrisoned_in_id: The id of the garrisoned unit (If not provided, the original garrisoned id will be used)\n        animation_frame: The animation frame of the cloned unit (If not provided, the original animation frame will be used)\n        status: The status of the cloned unit (If not provided, the original status will be used)\n        reference_id: Reference id of the cloned unit (If not provided, a new reference id will be generated)\n        tile: The tile of the cloned unit (If not provided, the original x,y coordinates will be used)\n\n    Returns:\n        The cloned unit\n    \"\"\"\n\n    if (x is not None or y is not None) and tile is not None:\n        raise ValueError(\"Cannot use both x,y notation and tile notation at the same time\")\n\n    return self.add_unit(\n        player=player or unit.player,\n        unit_const=unit_const or unit.unit_const,\n        x=x or unit.x,\n        y=y or unit.y,\n        z=z or unit.z,\n        rotation=rotation or unit.rotation,\n        garrisoned_in_id=garrisoned_in_id or unit.garrisoned_in_id,\n        animation_frame=animation_frame or unit.initial_animation_frame,\n        status=status or unit.status,\n        reference_id=reference_id,\n        tile=tile,\n    )\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.filter_units_by","title":"<code>def filter_units_by(...)</code>","text":"<p>Filter units based on a given attribute of units</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The attribute to filter by</p> required <code>unit_attrs</code> <code>List[int]</code> <p>The values for the attributes to filter with</p> required <code>blacklist</code> <code>bool</code> <p>Use the given constant list as blacklist instead of whitelist</p> <code>False</code> <code>player_list</code> <code>List[Union[int, PlayerId]]</code> <p>A list of players to filter from. If not used, all players are used.</p> <code>None</code> <code>unit_list</code> <code>List[Unit]</code> <p>A set of units to filter from. If not used, all units are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Unit]</code> <p>A list of units</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the provided attr does not exist on objects of the Unit class</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def filter_units_by(\n        self,\n        attr: str,\n        unit_attrs: List[int],\n        blacklist: bool = False,\n        player_list: List[Union[int, PlayerId]] = None,\n        unit_list: List[Unit] = None\n) -&gt; List[Unit]:\n    \"\"\"\n    Filter units based on a given attribute of units\n\n    Args:\n        attr: The attribute to filter by\n        unit_attrs: The values for the attributes to filter with\n        blacklist: Use the given constant list as blacklist instead of whitelist\n        player_list: A list of players to filter from. If not used, all players are used.\n        unit_list: A set of units to filter from. If not used, all units are used.\n\n    Returns:\n        A list of units\n\n    Raises:\n        AttributeError: If the provided attr does not exist on objects of the Unit class\n    \"\"\"\n\n    if unit_list is None:\n        unit_list = self.get_all_units()\n    if player_list is not None:\n        unit_list = [unit for unit in unit_list if unit.player in player_list]\n\n    if len(unit_list) == 0:\n        return []\n\n    unit = unit_list[0]\n    if not hasattr(unit, attr):\n        raise AttributeError(f\"Cannot filter Unit objects by {attr}\")\n\n    # Both return statements can be combined using: ((unit.unit_const in unit_consts) != blacklist)\n    # But splitting them helps performance (not checking against blacklist for each entry)\n    if not blacklist:\n        return [unit for unit_attr in unit_attrs for unit in unit_list if getattr(unit, attr) == unit_attr]\n    return [unit for unit_attr in unit_attrs for unit in unit_list if getattr(unit, attr) != unit_attr]\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.filter_units_by_const","title":"<code>def filter_units_by_const(...)</code>","text":"<p>Filter unit on their unit_const value.</p> <p>Parameters:</p> Name Type Description Default <code>unit_consts</code> <code>List[int]</code> <p>The constants to filter with</p> required <code>blacklist</code> <code>bool</code> <p>Use the given constant list as blacklist instead of whitelist</p> <code>False</code> <code>player_list</code> <code>List[Union[int, PlayerId]]</code> <p>A list of players to filter from. If not used, all players are used.</p> <code>None</code> <code>unit_list</code> <code>List[Unit]</code> <p>A set of units to filter from. If not used, all units are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Unit]</code> <p>A list of units</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def filter_units_by_const(\n        self,\n        unit_consts: List[int],\n        blacklist: bool = False,\n        player_list: List[Union[int, PlayerId]] = None,\n        unit_list: List[Unit] = None\n) -&gt; List[Unit]:\n    \"\"\"\n    Filter unit on their unit_const value.\n\n    Args:\n        unit_consts: The constants to filter with\n        blacklist: Use the given constant list as blacklist instead of whitelist\n        player_list: A list of players to filter from. If not used, all players are used.\n        unit_list: A set of units to filter from. If not used, all units are used.\n\n    Returns:\n        A list of units\n    \"\"\"\n    return self.filter_units_by(\"unit_const\", unit_consts, blacklist, player_list, unit_list)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.filter_units_by_reference_id","title":"<code>def filter_units_by_reference_id(...)</code>","text":"<p>Filter unit on their unit_const value.</p> <p>Parameters:</p> Name Type Description Default <code>unit_reference_ids</code> <code>List[int]</code> <p>The reference_ids to filter with</p> required <code>blacklist</code> <code>bool</code> <p>Use the given constant list as blacklist instead of whitelist</p> <code>False</code> <code>player_list</code> <code>List[int]</code> <p>A list of players to filter from. If not used, all players are used.</p> <code>None</code> <code>unit_list</code> <code>List[Unit]</code> <p>A set of units to filter from. If not used, all units are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Unit]</code> <p>A list of units</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def filter_units_by_reference_id(\n        self,\n        unit_reference_ids: List[int],\n        blacklist: bool = False,\n        player_list: List[Union[int, PlayerId]] = None,\n        unit_list: List[Unit] = None\n) -&gt; List[Unit]:\n    \"\"\"\n    Filter unit on their unit_const value.\n\n    Args:\n        unit_reference_ids (List[int]): The reference_ids to filter with\n        blacklist (bool): Use the given constant list as blacklist instead of whitelist\n        player_list (List[int]): A list of players to filter from. If not used, all players are used.\n        unit_list (List[Unit]): A set of units to filter from. If not used, all units are used.\n\n    Returns:\n        A list of units\n    \"\"\"\n    return self.filter_units_by(\"reference_id\", unit_reference_ids, blacklist, player_list, unit_list)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.find_highest_reference_id","title":"<code>def find_highest_reference_id(...)</code>","text":"<p>Find the highest ID in the map. Searches through all units for the highest ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>The highest ID in the map</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def find_highest_reference_id(self) -&gt; int:\n    \"\"\"\n    Find the highest ID in the map. Searches through all units for the highest ID.\n\n    Returns:\n        The highest ID in the map\n    \"\"\"\n    highest_id = 0  # If no units, default to 0\n    for player in PlayerId.all():\n        for unit in self.units[player]:\n            highest_id = max(highest_id, unit.reference_id)\n    return highest_id\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.get_all_units","title":"<code>def get_all_units(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def get_all_units(self) -&gt; List[Unit]:\n    units = []\n    for player_units in self.units:\n        units += player_units\n    return units\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.get_new_reference_id","title":"<code>def get_new_reference_id(...)</code>","text":"<p>Get a new ID each time the function is called. Starting from the current highest ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>The newly generated ID</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def get_new_reference_id(self) -&gt; int:\n    \"\"\"\n    Get a new ID each time the function is called. Starting from the current highest ID.\n\n    Returns:\n        The newly generated ID\n    \"\"\"\n    return next(self.reference_id_generator)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.get_player_units","title":"<code>def get_player_units(...)</code>","text":"<p>Returns a list of UnitObjects for the given player.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If player is not between 0 (GAIA) and 8 (EIGHT)</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>int | PlayerId</code>  - required Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def get_player_units(self, player: int | PlayerId) -&gt; List[Unit]:\n    \"\"\"\n    Returns a list of UnitObjects for the given player.\n\n    Raises:\n        ValueError: If player is not between 0 (GAIA) and 8 (EIGHT)\n    \"\"\"\n    if not 0 &lt;= player &lt;= 8:\n        raise ValueError(\"Player must have a value between 0 and 8\")\n    return self.units[player]\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.get_units_in_area","title":"<code>def get_units_in_area(...)</code>","text":"<p>Returns all units in the square with left corner (x1, y1) and right corner (x2, y2). Both corners inclusive.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>float</code> <p>The X location of the left corner</p> <code>None</code> <code>y1</code> <code>float</code> <p>The Y location of the left corner</p> <code>None</code> <code>x2</code> <code>float</code> <p>The X location of the right corner</p> <code>None</code> <code>y2</code> <code>float</code> <p>The Y location of the right corner</p> <code>None</code> <code>tile1</code> <code>Tile</code> <p>The x,y location of the 1<sup>st</sup> corner as Tile Object</p> <code>None</code> <code>tile2</code> <code>Tile</code> <p>The x,y location of the 2<sup>nd</sup> corner as Tile Object</p> <code>None</code> <code>unit_list</code> <code>List[Unit]</code> <p>(Optional) A list of units (Defaults to all units in the map, including GAIA (Trees etc.)</p> <code>None</code> <code>players</code> <code>List[Union[int, PlayerId]]</code> <p>(Optional) A list of Players which units need to be selected from the selected area</p> <code>None</code> <code>ignore_players</code> <code>List[PlayerId]</code> <p>(Optional) A list of Players which units need to be ignored from the selected area</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if not all 4 (x1, y1, x2 and y2) are used simultaneously. Or if both (tile1 and tile2) are not used simultaneously. Or if any of the 4 (x1, y1, x2, y2) is used together with any of (tile1, tile2). Use one or the other. Or if players and ignore_players are used simultaneously.</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def get_units_in_area(\n        self,\n        x1: float = None,\n        y1: float = None,\n        x2: float = None,\n        y2: float = None,\n        tile1: Tile = None,\n        tile2: Tile = None,\n        unit_list: List[Unit] = None,\n        players: List[Union[int, PlayerId]] = None,\n        ignore_players: List[PlayerId] = None\n) -&gt; List[Unit]:\n    \"\"\"\n    Returns all units in the square with left corner (x1, y1) and right corner (x2, y2). Both corners inclusive.\n\n    Args:\n        x1: The X location of the left corner\n        y1: The Y location of the left corner\n        x2: The X location of the right corner\n        y2: The Y location of the right corner\n        tile1: The x,y location of the 1st corner as Tile Object\n        tile2: The x,y location of the 2nd corner as Tile Object\n        unit_list: (Optional) A list of units (Defaults to all units in the map, including GAIA (Trees etc.)\n        players: (Optional) A list of Players which units need to be selected from the selected area\n        ignore_players: (Optional) A list of Players which units need to be ignored from the selected area\n\n    Raises:\n        ValueError: if not all 4 (x1, y1, x2 and y2) are used simultaneously.\n            Or if both (tile1 and tile2) are not used simultaneously.\n            Or if any of the 4 (x1, y1, x2, y2) is used together with any of (tile1, tile2). Use one or the other.\n            Or if players and ignore_players are used simultaneously.\n    \"\"\"\n    if (x1 is not None or y1 is not None or x2 is not None or y2 is not None) and any([tile1, tile2]):\n        raise ValueError(\"Cannot use both x1,y1,x2,y2 notation and tile1,tile2 notation at the same time\")\n    if (x1 is not None or y1 is not None or x2 is not None or y2 is not None) and \\\n            (x1 is None or y1 is None or x2 is None or y2 is None):\n        raise ValueError(\"Cannot use some but not all from x1,y1,x2,y2.\")\n    if (not all([tile1, tile2])) and any([tile1, tile2]):\n        raise ValueError(\"Cannot use one from tile1, tile2. Use both.\")\n    if players is not None and ignore_players is not None:\n        raise ValueError(\"Cannot use both whitelist (players) and blacklist (ignore_players) at the same time\")\n\n    if tile1:\n        x1 = tile1.x\n        y1 = tile1.y\n        x2 = tile2.x\n        y2 = tile2.y\n    else:\n        # Inclusive selection\n        x2 += 1\n        y2 += 1\n\n    if players is not None:\n        players = players\n    elif ignore_players is not None:\n        players = [p for p in PlayerId if p not in ignore_players]\n    else:\n        players = [p for p in PlayerId]\n\n    if unit_list is None:\n        unit_list = self.get_all_units()\n\n    return [unit for unit in unit_list if x1 &lt;= unit.x &lt;= x2 and y1 &lt;= unit.y &lt;= y2 and unit.player in players]\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.remove_eye_candy","title":"<code>def remove_eye_candy(...)</code>","text":"Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def remove_eye_candy(self) -&gt; None:\n    eye_candy_ids = [1351, 1352, 1353, 1354, 1355, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366]\n    self.units[0] = [gaia_unit for gaia_unit in self.units[0] if gaia_unit.unit_const not in eye_candy_ids]\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.remove_unit","title":"<code>def remove_unit(...)</code>","text":"<p>Removes a unit. Please note that <code>unit=...</code> is a lot faster than <code>reference_id=...</code> due to reference_id having to search through all units on the map. And unit has an ownership (player) attribute which is used for knowing which list to remove the unit from.</p> <p>Parameters:</p> Name Type Description Default <code>reference_id</code> <code>int</code> <p>The id of the unit. Note that this is NOT a unit constant (So NOT: UnitInfo.ARCHER)</p> <code>None</code> <code>unit</code> <code>Unit</code> <p>The Unit object to be removed.</p> <code>None</code> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def remove_unit(self, reference_id: int = None, unit: Unit = None) -&gt; None:\n    \"\"\"\n    Removes a unit. Please note that `unit=...` is a lot faster than `reference_id=...` due to reference_id having\n    to search through all units on the map. And unit has an ownership (player) attribute which is used for knowing\n    which list to remove the unit from.\n\n    Args:\n        reference_id: The id of the unit. Note that this is NOT a unit constant (So NOT: UnitInfo.ARCHER)\n        unit: The Unit object to be removed.\n    \"\"\"\n    if reference_id is not None and unit is not None:\n        raise ValueError(\"Cannot use both unit_ref_id and unit arguments. Use one or the other.\")\n    if reference_id is None and unit is None:\n        raise ValueError(\"Both unit_ref_id and unit arguments were unused. Use one.\")\n\n    if reference_id is not None:\n        for player in range(0, 9):\n            for i, unit in enumerate(self.units[player]):\n                if unit.reference_id == reference_id:\n                    del self.units[player][i]\n                    return\n    elif unit is not None:\n        self.units[unit.player].remove(unit)\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.UnitManager.update_unit_player_values","title":"<code>def update_unit_player_values(...)</code>","text":"<p>Function to update all player values in all units. Useful when units are moved manually (in mass).</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def update_unit_player_values(self):\n    \"\"\"Function to update all player values in all units. Useful when units are moved manually (in mass).\"\"\"\n    for player in PlayerId.all():\n        for unit in self.units[player]:\n            unit._player = player\n</code></pre>"},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager-functions","title":"Functions","text":""},{"location":"api_docs/units/unit_manager/#AoE2ScenarioParser.objects.managers.unit_manager.create_id_generator","title":"<code>def create_id_generator(...)</code>","text":"<p>Create generator for increasing value</p> <p>Parameters:</p> Name Type Description Default <code>start_id</code> <code>int</code> <p>The id to start returning</p> required <p>Returns:</p> Type Description <code>Generator[int]</code> <p>A generator which will return a +1 ID value for each time called with next.</p> Source code in <code>AoE2ScenarioParser/objects/managers/unit_manager.py</code> <pre><code>def create_id_generator(start_id: int) -&gt; Generator[int]:\n    \"\"\"\n    Create generator for increasing value\n\n    Args:\n        start_id: The id to start returning\n\n    Returns:\n        A generator which will return a +1 ID value for each time called with next.\n    \"\"\"\n    while True:\n        yield start_id\n        start_id += 1\n</code></pre>"},{"location":"api_docs/units/unit_manager_de/","title":"UnitManagerDE","text":""},{"location":"api_docs/units/unit_manager_de/#AoE2ScenarioParser.objects.managers.de.unit_manager_de-classes","title":"Classes","text":""},{"location":"api_docs/units/unit_manager_de/#AoE2ScenarioParser.objects.managers.de.unit_manager_de.UnitManagerDE","title":"<code>UnitManagerDE</code>","text":"<p>               Bases: <code>UnitManager</code></p> <p>Manager of all DE unit related features</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/unit_manager_de.py</code> <pre><code>class UnitManagerDE(UnitManager):\n    \"\"\"Manager of all DE unit related features\"\"\"\n\n    def __init__(self, _player_units: List[PlayerUnits], **kwargs):\n        super().__init__(_player_units, **kwargs)\n</code></pre>"},{"location":"api_docs/units/unit_manager_de/#AoE2ScenarioParser.objects.managers.de.unit_manager_de.UnitManagerDE-functions","title":"Functions","text":""},{"location":"api_docs/units/unit_manager_de/#AoE2ScenarioParser.objects.managers.de.unit_manager_de.UnitManagerDE.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>_player_units</code> <code>List[PlayerUnits]</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/unit_manager_de.py</code> <pre><code>def __init__(self, _player_units: List[PlayerUnits], **kwargs):\n    super().__init__(_player_units, **kwargs)\n</code></pre>"},{"location":"api_docs/xs/xs_manager_de/","title":"XsManager","text":""},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de-classes","title":"Classes","text":""},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE","title":"<code>XsManagerDE</code>","text":"<p>               Bases: <code>AoE2Object</code></p> <p>Manager of everything XS related.</p> Source code in <code>AoE2ScenarioParser/objects/managers/de/xs_manager_de.py</code> <pre><code>class XsManagerDE(AoE2Object):\n    \"\"\"Manager of everything XS related.\"\"\"\n\n    _link_list = [\n        RetrieverObjectLink(\"script_name\", \"Map\", \"script_name\", Support(since=1.40)),\n    ]\n\n    def __init__(self, script_name: str, **kwargs):\n        super().__init__(**kwargs)\n\n        self._script_name = script_name\n        \"\"\"\n        Using script files (added through this attribute) will NOT work for spectators.\n        You can work around this issue by using: ```xs_manager.add_script(xs_file_path='path/to/script.xs')```\n        For more information check out: https://ksneijders.github.io/AoE2ScenarioParser/cheatsheets/xs/\n        \"\"\"\n\n        # --- XS Script Call Trigger ---\n        self._initialized = False\n        self._xs_trigger: Optional[Trigger] = Trigger(\n            name=\"XS SCRIPT\",\n            enabled=False,\n            description=\"Due to the lack of support for transferring XS files between systems in Age of Empires II:DE, \"\n                        \"this trigger adds the entire script to an effect script call. This will add the script to\"\n                        \"each system once the game starts in the default0.xs file. -- Created using AoE2ScenarioParser\",\n        )\n\n    @property\n    def script_name(self):\n        \"\"\"The XS script name to include in the scenario\"\"\"\n        return self._script_name\n\n    @script_name.setter\n    def script_name(self, value):\n        self._script_name = value\n\n    @property\n    def xs_trigger(self):\n        \"\"\"The trigger holding the script call effect holding all the XS\"\"\"\n        if not self._initialized:\n            self.initialise_xs_trigger()\n        return self._xs_trigger\n\n    @xs_trigger.setter\n    def xs_trigger(self, value):\n        self._xs_trigger = value\n\n    def initialise_xs_trigger(self, insert_index: int = -1) -&gt; None:\n        \"\"\"\n        Creates the XS trigger on a desired location. If you don't care about the location, the `add_script()` function\n        adds the trigger when calling it the first time too.\n\n        If you want the trigger to be (almost) at the top of the list, and you're reading a scenario with barely any to\n        no triggers, it is recommended to call this somewhere at the start of the script.\n\n        Insert index is used to move this trigger to a desired index.\n        Keep in mind that moving triggers like this might take some time when you have a lot of triggers (thousands).\n\n        Args:\n            insert_index: The index where the xs trigger is added. Will be added at the end of the list if left empty\n        \"\"\"\n        if self._initialized:\n            return\n\n        try:\n            self._xs_trigger.new_effect.script_call(message=\"\")\n        except UnsupportedAttributeError:\n            raise UnsupportedVersionError(\n                f\"The scenario version ({get_scenario_version(self._uuid)}) does not support XS. \"\n                f\"Save the scenario in the editor to update the scenario to allow for XS.\"\n            ) from None\n        self._initialized = True\n        actions.import_triggers(self._uuid, [self.xs_trigger], insert_index, deepcopy=False)\n\n    def _append_to_xs(self, title, string) -&gt; None:\n        self.xs_trigger.effects[0].message += f\"// {'-' * 25} {title} {'-' * 25}\\n{string}\\n\\n\"\n\n    def add_script(self, xs_file_path: str = \"\", xs_string: str = \"\"):\n        \"\"\"\n        Add a script to the script call effect in the XS trigger\n\n        Args:\n            xs_file_path: Path to an XS file\n            xs_string: Raw XS\n        \"\"\"\n        if xs_file_path:\n            path = Path(xs_file_path)\n            with path.open() as xs_file:\n                self._append_to_xs(path.name, xs_file.read())\n        if xs_string:\n            self._append_to_xs(f\"XS string\", xs_string)\n\n    def _debug_write_script_to_file(self, filename: str = \"xs.txt\"):\n        with open(filename, 'w') as file:\n            file.write(self.xs_trigger.effects[0].message)\n</code></pre>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE-attributes","title":"Attributes","text":""},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE.script_name","title":"<code>script_name</code>  <code>property</code> <code>writable</code>","text":"<p>The XS script name to include in the scenario</p>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE.xs_trigger","title":"<code>xs_trigger</code>  <code>property</code> <code>writable</code>","text":"<p>The trigger holding the script call effect holding all the XS</p>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE-functions","title":"Functions","text":""},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE.__init__","title":"<code>def __init__(...)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>script_name</code> <code>str</code>  - required <code>kwargs</code>                              ?                       - <code>{}</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/xs_manager_de.py</code> <pre><code>def __init__(self, script_name: str, **kwargs):\n    super().__init__(**kwargs)\n\n    self._script_name = script_name\n    \"\"\"\n    Using script files (added through this attribute) will NOT work for spectators.\n    You can work around this issue by using: ```xs_manager.add_script(xs_file_path='path/to/script.xs')```\n    For more information check out: https://ksneijders.github.io/AoE2ScenarioParser/cheatsheets/xs/\n    \"\"\"\n\n    # --- XS Script Call Trigger ---\n    self._initialized = False\n    self._xs_trigger: Optional[Trigger] = Trigger(\n        name=\"XS SCRIPT\",\n        enabled=False,\n        description=\"Due to the lack of support for transferring XS files between systems in Age of Empires II:DE, \"\n                    \"this trigger adds the entire script to an effect script call. This will add the script to\"\n                    \"each system once the game starts in the default0.xs file. -- Created using AoE2ScenarioParser\",\n    )\n</code></pre>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE.add_script","title":"<code>def add_script(...)</code>","text":"<p>Add a script to the script call effect in the XS trigger</p> <p>Parameters:</p> Name Type Description Default <code>xs_file_path</code> <code>str</code> <p>Path to an XS file</p> <code>''</code> <code>xs_string</code> <code>str</code> <p>Raw XS</p> <code>''</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/xs_manager_de.py</code> <pre><code>def add_script(self, xs_file_path: str = \"\", xs_string: str = \"\"):\n    \"\"\"\n    Add a script to the script call effect in the XS trigger\n\n    Args:\n        xs_file_path: Path to an XS file\n        xs_string: Raw XS\n    \"\"\"\n    if xs_file_path:\n        path = Path(xs_file_path)\n        with path.open() as xs_file:\n            self._append_to_xs(path.name, xs_file.read())\n    if xs_string:\n        self._append_to_xs(f\"XS string\", xs_string)\n</code></pre>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de.XsManagerDE.initialise_xs_trigger","title":"<code>def initialise_xs_trigger(...)</code>","text":"<p>Creates the XS trigger on a desired location. If you don't care about the location, the <code>add_script()</code> function adds the trigger when calling it the first time too.</p> <p>If you want the trigger to be (almost) at the top of the list, and you're reading a scenario with barely any to no triggers, it is recommended to call this somewhere at the start of the script.</p> <p>Insert index is used to move this trigger to a desired index. Keep in mind that moving triggers like this might take some time when you have a lot of triggers (thousands).</p> <p>Parameters:</p> Name Type Description Default <code>insert_index</code> <code>int</code> <p>The index where the xs trigger is added. Will be added at the end of the list if left empty</p> <code>-1</code> Source code in <code>AoE2ScenarioParser/objects/managers/de/xs_manager_de.py</code> <pre><code>def initialise_xs_trigger(self, insert_index: int = -1) -&gt; None:\n    \"\"\"\n    Creates the XS trigger on a desired location. If you don't care about the location, the `add_script()` function\n    adds the trigger when calling it the first time too.\n\n    If you want the trigger to be (almost) at the top of the list, and you're reading a scenario with barely any to\n    no triggers, it is recommended to call this somewhere at the start of the script.\n\n    Insert index is used to move this trigger to a desired index.\n    Keep in mind that moving triggers like this might take some time when you have a lot of triggers (thousands).\n\n    Args:\n        insert_index: The index where the xs trigger is added. Will be added at the end of the list if left empty\n    \"\"\"\n    if self._initialized:\n        return\n\n    try:\n        self._xs_trigger.new_effect.script_call(message=\"\")\n    except UnsupportedAttributeError:\n        raise UnsupportedVersionError(\n            f\"The scenario version ({get_scenario_version(self._uuid)}) does not support XS. \"\n            f\"Save the scenario in the editor to update the scenario to allow for XS.\"\n        ) from None\n    self._initialized = True\n    actions.import_triggers(self._uuid, [self.xs_trigger], insert_index, deepcopy=False)\n</code></pre>"},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de-functions","title":"Functions","text":""},{"location":"api_docs/xs/xs_manager_de/#AoE2ScenarioParser.objects.managers.de.xs_manager_de-modules","title":"Modules","text":""},{"location":"cheatsheets/area/","title":"Area","text":"<p>The <code>Area</code> object is a powerful object to get access to specific regions on the map.  This page will try to explain a bit on how to use it and what the possibilities are.</p> <p>First of all, the <code>Area</code> object uses \"Method Chaining\".  This means that methods inside the <code>Area</code> object return the <code>Area</code> object itself. This allows you to call another method straight after the first: </p> <pre><code>obj.x()\nobj.y()\nobj.z()\n# With method chaining you can do:\nobj.x().y().z()\n</code></pre> <p>This is perfect for a highly configurable and flexible objects like the <code>Area</code> object.</p>"},{"location":"cheatsheets/area/#why-would-i-use-the-area-object","title":"Why would I use the <code>Area</code> object?","text":"<p>If you want to do anything with more than a single coordinate, it's quite the hassle sometimes. That's the problem this object is trying (feature suggestions always welcome!) to solve.</p> <p>Note</p> <p>The <code>Area</code> object strength comes from selecting specific pattern/tiles. If you want to do a similar thing with  every tile on the map this object won't help you much. </p>"},{"location":"cheatsheets/area/#examples","title":"Examples","text":"<p>Below are a couple examples that show why this object can be very useful when working with coordinates.</p>"},{"location":"cheatsheets/area/#creating-a-stack-of-units","title":"Creating a stack of units","text":"<p>Let's say you want to place 16 units, in a 4x4 area on the map.  This is not necessarily difficult to do, it'd probably look something like the following:</p> <pre><code>for x in range(10, 14):\n    for y in range(50, 54):\n        unit_manager.add_unit(\n            player=PlayerId.ONE, \n            unit_const=UnitInfo.KNIGHT.ID, \n            x=x+.5, \n            y=y+.5\n        )\n</code></pre> <p>This would create 16 units in a 4x4 area and isn't too bad to read or write. Though, having an object which manages the area would be a lot cleaner than looping through coordinates. So, let's see how we'd do it with the <code>Area</code> object.</p> <pre><code>area = scenario.new.area()  # Create a new area object\n\n# Select the area and convert it to a set of all coordinates inside of it\nfor tile in area.select(10, 50, 13, 53).to_coords():\n    # Every tile is a NamedTuple with an 'x' and 'y' value\n    unit_manager.add_unit(\n        player=PlayerId.ONE, \n        unit_const=UnitInfo.KNIGHT.ID, \n        x=tile.x + .5, \n        y=tile.y + .5\n    )\n</code></pre> <p>Above we can see the creation of a new <code>Area</code> object through the new Object Factory inside a scenario. We use the <code>select</code> method to select our area. </p> <p>Note</p> <p>Keep in mind that <code>Area.select</code> uses an inclusive selection.  This means that doing: <code>area.select(1, 1, 3, 3)</code> will select a 3x3 area.</p>"},{"location":"cheatsheets/area/#castle-surrounded-by-walls","title":"Castle surrounded by walls","text":"<p>Now, the above example was quite a simple one. The real power comes with the configuration! So let's take a more complicated example! Like creating a wall around a castle! This will be quite the difference, so let's do it in steps, first we create the castle and the area object.</p> <pre><code>castle = unit_manager.add_unit(player=PlayerId.ONE, unit_const=BuildingInfo.CASTLE.ID, x=30, y=30)\narea = scenario.new.area()\n</code></pre> <p>Now let's select the area of the castle itself, so the 4x4 area.</p> <pre><code>area.center(castle.x, castle.y).size(4)\n# Or using separate width and height calls:\narea.center(castle.x, castle.y).width(4).height(4)\n</code></pre> <p>This sets the center of the area to the castles coordinates.  After that we change the size of the selection from the default (1x1) to (4x4). We now have the castle area selected. Let's say we want the wall 6 tiles around the castle. Let's expand our selection by 6 tiles.</p> <pre><code># On it's own line\narea.expand(6)\n# Or add it to the above line\narea.center(castle_object.x, castle_object.y).size(4).expand(6)\n</code></pre> <p>Now we have a 16 by 16 tile area selected. The 4x4 from the castle plus the 6 tiles we expanded to all four sides.</p> <p>We could do the same thing as above with the knights in the 4x4 but there's a problem. The selection covers all those 256 (16*16) tiles. So we'd be filling everything with walls.  We just want the edges so, let's do that. For that we use a so called \"use\" function.</p> <pre><code># On it's own line\narea.use_only_edge()\n# Or, again, add it to the above line\narea.center(castle_object.x, castle_object.y).size(4).expand(6).use_only_edge()\n</code></pre> <p>This tells the area object we only want the outer edge of the selection. Now let's convert that to coordinates and place those walls! We can use <code>area.to_coords()</code> again!</p> <pre><code>castle = unit_manager.add_unit(player=PlayerId.ONE, unit_const=BuildingInfo.CASTLE.ID, x=30, y=30)\narea = scenario.new.area()\n\nfor tile in area.center(castle.x, castle.y).size(4).expand(6).use_only_edge().to_coords():\n    unit_manager.add_unit(\n        player=PlayerId.ONE, unit_const=BuildingInfo.STONE_WALL.ID, x=tile.x, y=tile.y\n    )\n</code></pre> <p>And that's it! The castle has walls around it. With such ease!</p> <p></p>"},{"location":"cheatsheets/area/#checkers-pattern","title":"Checkers pattern","text":"<p>So, let's say we want to create a checkers pattern.  Where we create squares of ice and black terrain alternately. To do this we basically need all tiles on the map but in separate squares. So selecting the entire map alone isn't enough here as we want them all separated.</p> <p>So, what we want is blocks of 3x3 over the course of the map.  The map we're reading is a tiny 2 player map which has a size of 120 by 120 tiles.</p> <p>What we'll do is select the entire map and use the grid pattern.  Then we use a block size of 3 and a gap size of 0. This way we get 3x3 areas.</p> <p>Though, we cannot use the <code>area.to_coords()</code> function we used before.  The reason for that is because the function returns all tiles in the selection.  And because we use all tiles in the map, this function will just return a large list of all tiles. What we need for this is: <code>area.to_chunks()</code>. Let's get started and see how it works!</p> <p>Alright, first, let's create the main <code>Area</code> object and select the entire map. </p> <pre><code>area = scenario.new.area()\narea.select_entire_map()\n</code></pre> <p>After that, let's set it so that it uses the grid pattern. You can do this in two ways:</p> <pre><code># Append to the same line\narea = scenario.new.area()\narea.select_entire_map().use_pattern_grid()\n\n# Or add it after the last line\narea = scenario.new.area()\narea.select_entire_map()\narea.use_pattern_grid()\n</code></pre> <p>Now this would be default return a grid with gaps of 1 and blocks of 1x1. We want blocks of 3x3 and no gaps (gap of 0). Below you can see the steps and the difference these configurations have:</p> <p></p> <p>Now that we know what we want, we can add some configuration to the function, we can do this in four ways, choose  the one you like the most (We'll continue with the first option):</p> <pre><code># For the third option:\nfrom AoE2ScenarioParser.objects.support.area import AreaAttr\n\n...\narea.use_pattern_grid(block_size=3, gap_size=0)\n...\narea.use_pattern_grid().attr('block_size', 3)\narea.use_pattern_grid().attr('gap_size', 0)\n...\narea.use_pattern_grid().attr(AreaAttr.BLOCK_SIZE, 3)\narea.use_pattern_grid().attr(AreaAttr.GAP_SIZE, 0)\n...\narea.use_pattern_grid().attrs(block_size=3, gap_size=0)\n</code></pre> <p>You can differentiate the X and Y</p> <p>In many functions you can use the general option like <code>gap_size</code>.  But there's also options for <code>gap_size_x</code> and <code>gap_size_y</code> if you want different selections.</p> <p>Now that we have the grid, let's add the final piece where we change the terrain itself.  We can use the function <code>to_chunks()</code> to return our grid as 'chunks'.</p> <p>Chunks will be returned in a list and every chunk will be returned as an <code>OrderedSet</code>. These <code>OrderedSet</code>s will contain <code>Tile</code> objects by default. These objects just contain their <code>x</code> and <code>y</code> values. We can change this behaviour with the <code>as_terrain</code> parameter.  Setting this to <code>True</code> will return the <code>OrderedSet</code>s with <code>TerrainTile</code> objects.  These objects allow you to directly change the terrain on this tile.  These are also the same objects returned by the Map Manager.</p> <pre><code>for index, chunk in enumerate(area.to_chunks(as_terrain=True)):\n    for terrain_tile in chunk:\n        terrain_tile.terrain_id = TerrainId.BLACK if index % 2 == 0 else TerrainId.ICE\n</code></pre> <p>So the code above loops through all the 3x3 squares returned by the <code>to_chunks</code> function. Then for each square it loops through all the terrain tiles in the <code>OrderedSet</code>. We then set the terrain to <code>BLACK</code> or <code>ICE</code> depending on the index reduced by modulo 2. This will alternate the tiles between the two terrain types.</p> <p>There's one small adjustment we need to make. Because the map 120 tiles and the squares have a length of 3 we can fit 40 squares per row. This is an even number. So just alternating <code>BLACK</code> and <code>ICE</code> terrain based on index will cause it to create lines instead of alternating each row. We can fix this by adding the row with the index and reduce that by modulo 2 to get our ideal situation. </p> <pre><code>for index, chunk in enumerate(area.to_chunks(as_terrain=True)):\n    for terrain_tile in chunk:\n        row = index // (map_manager.map_size / 3)  # 3 as the size of the grid blocks\n        terrain_tile.terrain_id = TerrainId.BLACK if (index + row) % 2 == 0 else TerrainId.ICE\n</code></pre> <p>Another way to get around this is make sure the squares fit an odd amount of times in the length of the map.  So using the earlier loop, without the row, with a map size of 117 (39 times) would result in the same pattern as the  code above.</p> <p></p> <p>The entire code block for this example:</p> <pre><code>area = scenario.new.area()\narea.select_entire_map().use_pattern_grid(block_size=3, gap_size=0)\n\nfor index, chunk in enumerate(area.to_chunks(as_terrain=True)):\n    for terrain_tile in chunk:\n        row = index // (map_manager.map_size / 3)  # 3 as the size of the grid blocks\n        terrain_tile.terrain_id = TerrainId.BLACK if (index + row) % 2 == 0 else TerrainId.ICE\n</code></pre>"},{"location":"cheatsheets/area/#api","title":"API","text":""},{"location":"cheatsheets/area/#functions","title":"Functions","text":"<p>In this section the functions are shown. This will eventually be replaced by a proper API doc for everything. But  until then, this will have to do. Enjoy!</p>"},{"location":"cheatsheets/area/#functions-to-convert-to-other-datatype","title":"Functions to convert to other datatype:","text":"<p>.to_coords(as_terrain)</p> <p>Converts the selection to an OrderedSet of (x, y) coordinates</p> Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. <p>Returns: <code>OrderedSet[Tile | 'TerrainTile']</code></p> <p>.to_chunks(as_terrain)</p> <p>Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates. The separation between chunks is based on if they're connected to each other. So the tiles must share an edge (i.e. they should be non-diagonal).</p> Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. <p>Returns: <code>List[OrderedSet[Tile | 'TerrainTile']]</code></p> <p>.to_dict(prefix)</p> <p>Converts the 2 corners of the selection to area keys for use in effects etc. This can be used by adding double stars (**) before this function.</p> Parameter Type Default Description prefix str \"area_\" The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key) <p>Returns: <code>Dict[str, int]</code></p>"},{"location":"cheatsheets/area/#functions-to-get-information-from-the-area-object","title":"Functions to get information from the <code>Area</code> object:","text":"<p>.get_selection()</p> <p>Get the four values of the selection as: ((x1, y1), (x2, y2))</p> <p>Returns: <code>Tuple[Tuple[int, int], Tuple[int, int]]</code></p> <p>.get_raw_selection()</p> <p>Get the four values of the selection (even if they are outside the map) as: ((x1, y1), (x2, y2))</p> <p>Returns: <code>Tuple[Tuple[int, int], Tuple[int, int]]</code></p> <p>.get_center()</p> <p>Get center of current selection</p> <p>Returns: <code>Tuple[float, float]</code></p> <p>.get_center_int()</p> <p>Get center of current selection, coords can only be integers. If even length, the value is ceiled</p> <p>Returns: <code>Tuple[int, int]</code></p> <p>.get_range_x()</p> <p>Returns a range object for the x coordinates.</p> <p>Returns: <code>range</code></p> <p>.get_range_y()</p> <p>Returns a range object for the y coordinates.</p> <p>Returns: <code>range</code></p> <p>.get_width()</p> <p>Returns the length of the x side of the selection.</p> <p>Returns: <code>int</code></p> <p>.get_height()</p> <p>Returns the length of the y side of the selection.</p> <p>Returns: <code>int</code></p> <p>.get_dimensions()</p> <p>Returns the lengths of the x &amp; y side of the selection (in that order).</p> <p>Returns: <code>Tuple[int, int]</code></p>"},{"location":"cheatsheets/area/#functions-to-set-what-patternselection-format-to-use","title":"Functions to set what pattern/selection format to use:","text":"<p>.use_full()</p> <p>Sets the area object to use the entire selection</p> <p>Returns: <code>Area</code></p> <p>.use_only_edge(line_width, line_width_x, line_width_y)</p> <p>Sets the area object to only use the edge of the selection</p> Parameter Type Default Description line_width int None The width of the x &amp; y edge line line_width_x int None The width of the x edge line line_width_y int None The width of the y edge line <p>Returns: <code>Area</code></p> <p>.use_only_corners(corner_size, corner_size_x, corner_size_y)</p> <p>Sets the area object to only use the corners pattern within the selection.</p> Parameter Type Default Description corner_size int None The size along both the x and y axis of the corner areas corner_size_x int None The size along the x axis of the corner areas corner_size_y int None The size along the y axis of the corner areas <p>Returns: <code>Area</code></p> <p>.use_pattern_grid(block_size, gap_size, block_size_x, block_size_y, gap_size_x, gap_size_y)</p> <p>Sets the area object to use a grid pattern within the selection.</p> Parameter Type Default Description block_size int None The size of the gaps between lines gap_size int None The width of the grid lines block_size_x int None The size of the x gaps between lines block_size_y int None The size of the y gaps between lines gap_size_x int None The width of the x grid lines gap_size_y int None The width of the y grid lines <p>Returns: <code>Area</code></p> <p>.use_pattern_lines(axis, gap_size, line_width)</p> <p>Sets the area object to use a lines pattern within the selection.</p> Parameter Type Default Description axis str None The axis the lines should follow. Can either be \"x\" or \"y\" gap_size int None The size of the gaps between lines line_width int None The width of the x &amp; y lines <p>Returns: <code>Area</code></p>"},{"location":"cheatsheets/area/#functions-to-change-the-selection-in-one-way-or-another","title":"Functions to change the selection in one way or another:","text":"<p>.invert()</p> <p>Inverts the inverted boolean. Causes the <code>to_coords</code> to return the inverted selection. (Especially useful for the grid state. Not as useful for the edge which would be the same as shrinking the selection. When used with the fill state an empty set is returned.</p> <p>Returns: <code>Area</code></p> <p>.along_axis(axis)</p> <p>Sets the axis. Can be either \"x\" or \"y\".</p> Parameter Type Default Description axis str - - <p>Returns: <code>Area</code></p> <p>.attr(key, value)</p> <p>Sets the attribute to the given value. AreaAttr or str can be used as key</p> Parameter Type Default Description key str | AreaAttr - - value int - - <p>Returns: <code>Area</code></p> <p>.attrs(x1, y1, x2, y2, gap_size, gap_size_x, gap_size_y, line_width, line_width_x, line_width_y, axis, corner_size, corner_size_x, corner_size_y, block_size, block_size_x, block_size_y)</p> <p>Sets multiple attributes to the corresponding values.</p> Parameter Type Default Description x1 int None - y1 int None - x2 int None - y2 int None - gap_size int None - gap_size_x int None - gap_size_y int None - line_width int None - line_width_x int None - line_width_y int None - axis str None - corner_size int None - corner_size_x int None - corner_size_y int None - block_size int None - block_size_x int None - block_size_y int None - <p>Returns: <code>Area</code></p> <p>.size(n)</p> <p>Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become <code>((3,3), (5,5))</code> </p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.height(n)</p> <p>Sets the height (y axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. </p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.width(n)</p> <p>Sets the width (x axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. </p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.center(x, y)</p> <p>Moves the selection center to a given position. When the given center forces the selection of the edge of the map the off-map tiles will not be returned. When moving the selection back into the map the tiles will be returned again.</p> Parameter Type Default Description x int - - y int - - <p>Returns: <code>Area</code></p> <p>.center_bounded(x, y)</p> <p>Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge of the map. The selection will be forced against the edge of the map and the selection will not be decreased in size. </p> Parameter Type Default Description x int - - y int - - <p>Returns: <code>Area</code></p> <p>.select_entire_map()</p> <p>Sets the selection to the entire map</p> <p>Returns: <code>Area</code></p> <p>.select(x1, y1, x2, y2)</p> <p>Sets the selection to the given coordinates</p> Parameter Type Default Description x1 int - - y1 int - - x2 int None - y2 int None - <p>Returns: <code>Area</code></p> <p>.select_centered(x, y, dx, dy)</p> <p>Sets the selection to the given coordinates</p> Parameter Type Default Description x int - - y int - - dx int 1 - dy int 1 - <p>Returns: <code>Area</code></p> <p>.shrink(n)</p> <p>Shrinks the selection from all sides</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.shrink_x1(n)</p> <p>Shrinks the selection from the first corner on the X axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.shrink_y1(n)</p> <p>Shrinks the selection from the first corner on the Y axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.shrink_x2(n)</p> <p>Shrinks the selection from the second corner on the X axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.shrink_y2(n)</p> <p>Shrinks the selection from the second corner on the Y axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.expand(n)</p> <p>Expands the selection from all sides</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.expand_x1(n)</p> <p>Expands the selection from the first corner on the X axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.expand_y1(n)</p> <p>Expands the selection from the first corner on the Y axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.expand_x2(n)</p> <p>Expands the selection from the second corner on the X axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p> <p>.expand_y2(n)</p> <p>Expands the selection from the second corner on the Y axis by n</p> Parameter Type Default Description n int - - <p>Returns: <code>Area</code></p>"},{"location":"cheatsheets/area/#other-relevant-functions","title":"Other relevant functions:","text":"<p>.is_within_selection(x, y, tile)</p> <p>If a given (x,y) location is within the selection.</p> Parameter Type Default Description x int -1 The X coordinate y int -1 The Y coordinate tile Tile None A Tile object, replacing the x &amp; y coordinates <p>Returns: <code>bool</code></p> <p>.associate_scenario(scenario)</p> <p>Associate area with scenario. Saves scenario UUID in this area object.</p> Parameter Type Default Description scenario AoE2Scenario - The scenario to associate with <p>Returns: <code>None</code></p> <p>.copy()</p> <p>Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source with small tweaks.</p> <p>Returns: <code>Area</code></p>"},{"location":"cheatsheets/data_triggers/","title":"Data Triggers","text":"<p>Data Triggers is a new feature to the parser.  They allow you to transfer the power of visuals from the in-game editor into the parser!</p>"},{"location":"cheatsheets/data_triggers/#what-are-these-data-triggers","title":"What are these data triggers?","text":"<p>Data triggers are basically triggers with specifically set names. The triggers also have some effects and conditions which selects stuff like: areas, units, triggers or tiles.</p>"},{"location":"cheatsheets/data_triggers/#why-do-i-need-them","title":"Why do I need them?","text":"<p>If you ever wanted to do something with an area or specific objects or triggers that are already present in the scenario before reading with the parser, you'd need to select them through their coordinates or names etc. This can be a bit of a challenge or annoying to keep doing over and over at best.</p> <p>So, that's what data triggers are for. You use conditions and effects to select those aspects of the map and in the  parser you can use a simple, single line of code to get all this data easily accessible to you.</p>"},{"location":"cheatsheets/data_triggers/#creating-the-data-triggers","title":"Creating the data triggers","text":"<p>So, how do we create the data triggers? Well, like so:</p> <ol> <li>Open your scenario in-game</li> <li>Create a trigger</li> <li>Change the name of the trigger to \"area:cool_middle_area\"</li> <li>Create a <code>Bring Object to Area</code> conditions. (It doesn't matter which condition or effect you choose. As long as an area can be selected with it)</li> <li>Use the <code>Set Area</code> button to select an area on the map</li> <li>Save the scenario</li> <li>Use the parser to load the map</li> <li>Use the code below to get the area object:</li> </ol> <pre><code>scenario = ... # Load scenario stuff here\n\ntrigger_data = scenario.actions.load_data_triggers()\ncool_area = trigger_data.areas['cool_middle_area']\n</code></pre> <p>And that's it! Now you have a list of <code>Area</code> objects which contains all the areas that you selected in the trigger! You can add more effects/conditions with areas to that trigger, and they'll be added to the list.  You can also create another trigger with the same <code>area:&lt;name&gt;</code> name and add more effects or conditions to it to create  different selections.</p> <p>The data triggers are automatically removed</p> <p>The function <code>.load_data_triggers()</code> automatically removes all triggers it finds with the proper prefix. If you'd like to keep these triggers you can use the <code>remove_template_triggers</code> parameter and set it to <code>False</code>.</p>"},{"location":"cheatsheets/data_triggers/#different-data-types","title":"Different data types","text":"<p>Currently, there's 4 data types you can use to select information on the map. These are:</p>"},{"location":"cheatsheets/data_triggers/#area","title":"Area","text":"<p>Create an <code>Area</code> object based on an area selected using the <code>Set Area</code> button in-game (Effects &amp; Conditions).</p>"},{"location":"cheatsheets/data_triggers/#tile","title":"Tile","text":"<p>Create <code>Tile</code> objects based on a single tile selected using the <code>Set Location</code> button (Effects) or a bunch of tiles selected using the <code>Set Area</code> button (Effects and Conditions) in-game.</p>"},{"location":"cheatsheets/data_triggers/#object","title":"Object","text":"<p>Select a <code>Unit</code> object (or multiple <code>Unit</code> objects) based on the selected units using the <code>Set objects</code> button (Effects and Conditions) or <code>Set location</code> button (Effects) (Works with both selecting a unit AND the tile a unit is  standing on). It also allows selecting an area using the <code>Set Area</code> button (Effects and Conditions) and all units within that area will be included.</p>"},{"location":"cheatsheets/data_triggers/#trigger","title":"Trigger","text":"<p>Select a <code>Trigger</code> object based on the selected trigger in (de)activation effects using the <code>Trigger List</code> dropdown.</p>"},{"location":"cheatsheets/data_triggers/#mechanics","title":"Mechanics","text":"<p>The <code>load_data_triggers()</code> function looks for a specific prefix in the trigger names. The prefixes are as follows:</p> Type Prefixes <code>Area</code> \"area:\", \"areas:\" <code>Tile</code> \"tile:\", \"tiles:\" <code>Object</code> \"object:\", \"objects:\" <code>Trigger</code> \"trigger:\", \"triggers:\" <p>When it finds a prefix it uses the name after the colon to store the objects in a dictionary, so these should be  unique per data type.</p> <p>The function then goes through all the effects and conditions within the trigger. The effect or condition type doesn't  matter. The function just checks the proper attributes (for example: the <code>area_x1</code>, <code>area_y1</code>, <code>area_x2</code> &amp; <code>area_y2</code>  attributes) for the area data type. If all of those attributes are set, it creates/finds the proper object accordingly.</p> <p>The object returned by <code>load_data_triggers()</code> has 4 attributes which will return the corresponding dictionaries. So, for example, you could store the dicts directly like so:</p> <pre><code>from typing import List\n\nfrom AoE2ScenarioParser.helper.attr_dict import AttrDict\n\nfrom AoE2ScenarioParser.objects.data_objects.trigger import Trigger\nfrom AoE2ScenarioParser.objects.data_objects.unit import Unit\nfrom AoE2ScenarioParser.objects.support.area import Area\nfrom AoE2ScenarioParser.objects.support.tile import Tile\n\nscenario = ... # Load scenario stuff here\n\ntrigger_data = scenario.actions.load_data_triggers()\n\n# You could leave out the 'AttrDict[...]' parts (and the corresponding imports). \n# That being said, they do help your IDE understand the proper types for type hinting later on\nareas: AttrDict[str, List[Area]] = trigger_data.areas\ntiles: AttrDict[str, List[Tile]] = trigger_data.tiles\ntriggers: AttrDict[str, List[Trigger]] = trigger_data.triggers\nobjects: AttrDict[str, List[Unit]] = trigger_data.objects\n</code></pre> <p>The dictionaries are also special in that they allow attribute access instead of only key access. So to get the key \"TCs\" you can use either of these with the same result: </p> <pre><code>trigger_data.objects['TCs']\ntrigger_data.objects.TCs\n</code></pre> <p>Keys with spaces won't work with attribute access</p> <p>When your key has characters like spaces (or other special chars) you have to use:  <pre><code>trigger_data.objects['name with space here']\n</code></pre></p>"},{"location":"cheatsheets/data_triggers/#examples","title":"Examples","text":""},{"location":"cheatsheets/data_triggers/#area_1","title":"Area","text":"<p>This trigger was made to make an area object around berries. (Don't ask why). You can see multiple conditions in the list.  All of them have an area selected so the list for the <code>berries</code> will have 6 <code>Area</code> objects</p> <p></p>"},{"location":"cheatsheets/data_triggers/#tile_1","title":"Tile","text":"<p>This trigger just selects a bunch of tiles. As you can see in the image, tiles can also be selected by the <code>Set Area</code> button. This will result in multiple <code>Tile</code> objects being created for one effect. The list for this trigger will return at least the 7 <code>Tile</code> objects selected by this condition.</p> <p></p>"},{"location":"cheatsheets/data_triggers/#object_1","title":"Object","text":"<p>This trigger was made to easily select the 'main army' of a player. The <code>Set Objects</code> button was used to select multiple units at once.  As you can see multiple effects and conditions were used in this trigger.  All of them have units selected through the <code>Set Objects</code> or <code>Set Location</code> buttons.  This list will be longer than just 3 <code>Unit</code> objects as the shown effect already selects 3 units on its own.  So, if the other 2 only selected 1 unit each, the list would have 5 <code>Unit</code> objects in total.</p> <p></p>"},{"location":"cheatsheets/data_triggers/#trigger_1","title":"Trigger","text":"<p>This trigger selects 2 triggers with the name 'main'. Data triggers for selecting triggers is the simplest as you can only select 1 Trigger per effect. So this list will have 2 triggers in it.</p> <p></p>"},{"location":"cheatsheets/datasets/","title":"Datasets","text":"<p>The project currently contains multiple datasets. You can get access to the datasets by importing them.</p> <pre><code># Information about the conditions &amp; effects and their attributes\nfrom AoE2ScenarioParser.datasets.conditions import ConditionId\nfrom AoE2ScenarioParser.datasets.effects import EffectId\nfrom AoE2ScenarioParser.datasets.object_support import Civilization, StartingAge\nfrom AoE2ScenarioParser.datasets.trigger_lists import \\\n    DiplomacyState, Operation, ButtonLocation, PanelLocation, \\\n    TimeUnit, VisibilityState, DifficultyLevel, TechnologyState, \\\n    Comparison, ObjectAttribute, Attribute, UnitAIAction, \\\n    AttackStance, ObjectType, ObjectClass, DamageClass, \\\n    HeroStatusFlag, Hotkey, BlastLevel, TerrainRestrictions, \\\n    ColorMood, ObjectState, SecondaryGameMode, ChargeType, \\\n    ChargeEvent, CombatAbility, FogVisibility, GarrisonType, \\\n    OcclusionMode, ProjectileHitMode, ProjectileVanishMode, \\\n    UnitTrait, ProjectileSmartMode, Age, ActionType, VictoryTimerType\n\n# Information of unit/building/hero and tech IDs\nfrom AoE2ScenarioParser.datasets.projectiles import ProjectileInfo\nfrom AoE2ScenarioParser.datasets.buildings import BuildingInfo\nfrom AoE2ScenarioParser.datasets.heroes import HeroInfo\nfrom AoE2ScenarioParser.datasets.other import OtherInfo\nfrom AoE2ScenarioParser.datasets.techs import TechInfo\nfrom AoE2ScenarioParser.datasets.units import UnitInfo\n\n# Information about terrain IDs\nfrom AoE2ScenarioParser.datasets.terrains import TerrainId\n\n# Information about player IDs\nfrom AoE2ScenarioParser.datasets.players import PlayerId, PlayerColorId, ColorId\n</code></pre> <p>A special thanks to Alian713 for doing A LOT of the work in contributing the data needed for these datasets. </p>"},{"location":"cheatsheets/datasets/#conditions-effects","title":"Conditions &amp; Effects","text":"<p>The condition and effect datasets aren't really necessary in regular scripting after adding the new methods for adding effects &amp; conditions:</p> <pre><code>effect = trigger.new_effect.change_diplomacy(...)\n</code></pre> <p>They can still be used if you want the effect &amp; condition IDs for other purposes.</p> <pre><code>ConditionId.OBJECTS_IN_AREA  # 5\nEffectId.PATROL  # 19\n</code></pre> <pre><code># Checking the docs for EffectId.CHANGE_DIPLOMACY will show:\n\"\"\"\nAttributes for the **change_diplomacy** effect are:\n- diplomacy\n- player_source\n- player_target\n\"\"\"\n</code></pre>"},{"location":"cheatsheets/datasets/#conditions-effects-lists","title":"Conditions &amp; Effects lists","text":"<p>Many conditions and effects have dropdown lists with options. These options are, like everything else, impossible to remember. That's why these datasets have been added:</p> Names Explanation Example DiplomacyState Used in the <code>Change Diplomacy</code> effect and the <code>Diplomacy State</code> condition. <code>DiplomacyState.ALLY</code> Operation Used in many effects. Generally related to variables. <code>Operation.MULTIPLY</code> ButtonLocation * Used in the <code>Change Research Location</code> and <code>Change Train Location</code> effects. * <code>ButtonLocation.r2c3</code> PanelLocation Used in the <code>Display Instructions</code> effect. <code>PanelLocation.CENTER</code> TimeUnit Used in the <code>Display Timer</code> effect. <code>TimeUnit.YEARS</code> VisibilityState Used in the <code>Set Player Visibility</code> effect. <code>VisibilityState.EXPLORED</code> DifficultyLevel Used in the <code>Difficulty Level</code> condition. <code>DifficultyLevel.HARDEST</code> TechnologyState Used in the <code>Technology State</code> condition. <code>TechnologyState.RESEARCHING</code> Comparison Used in many effects and conditions. Generally related to variables. <code>Comparison.EQUAL</code> ObjectAttribute Used in the <code>Modify Attribute</code> effect. <code>ObjectAttribute.CARRY_CAPACITY</code> Attribute Used in the <code>Accumulate Attribute</code> effect. <code>Attribute.ALL_TECHS_ACHIEVED</code> UnitAIAction Used in the <code>Object has Action</code> condition. <code>UnitAIAction.ATTACK</code> AttackStance Used in the <code>Change Object Stance</code> effect. <code>AttackStance.AGGRESSIVE_STANCE</code> ObjectType Used in every unit selection effect &amp; condition. <code>ObjectType.DOPPELGANGER</code> ObjectClass Used in every unit selection effect &amp; condition. <code>ObjectClass.INFANTRY</code> DamageClass Used in the <code>Change Object Attack/Armour</code> effects. <code>DamageClass.SPEARMEN</code> HeroStatusFlag * Can be used for changing the <code>HERO_STATUS</code> in <code>ObjectAttribute</code>. * <code>HeroStatusFlag.HERO_REGENERATION</code> Hotkey Can be used for changing the <code>HOTKEY_ID</code> in <code>ObjectAttribute</code>. <code>Hotkey.SPACE</code> BlastLevel Can be used for changing the <code>BLAST_&lt;&gt;_LEVEL</code> properties in <code>ObjectAttribute</code>. <code>BlastLevel.NEARBY_UNITS</code> TerrainRestrictions Can be used for changing the <code>TERRAIN_RESTRICTION_ID</code> in <code>ObjectAttribute</code>. <code>TerrainRestrictions.LAND</code> ProjectileSmartMode Can be used for changing the <code>ENABLE_SMART_PROJECTILES</code> in <code>ObjectAttribute</code>. <code>ProjectileSmartMode.TARGET_FUTURE_LOCATION</code> ColorMood Used in the <code>Change Color Mood</code> effect. <code>ColorMood.WINTER</code> ObjectState Used in the <code>Objects in area</code> condition. <code>ObjectState.DEAD</code> ColorId Used in the player manager for setting the player color. <code>ColorId.GREEN</code> Civilization Used in the player manager for setting the player civilization. <code>Civilization.MAYANS</code> StartingAge Used in the player manager for setting the player starting age. <code>StartingAge.FEUDAL_AGE</code> SecondaryGameMode Used for setting the secondary victory conditions. <code>SecondaryGameMode.SUDDEN_DEATH</code> ChargeType Used in the <code>Modify Attribute</code> effect. With the <code>Charge Type</code> attribute. <code>ChargeType.AREA_ATTACK_CHARGE</code> ChargeEvent Used in the <code>Modify Attribute</code> effect. With the <code>Charge Event</code> attribute. <code>ChargeEvent.NO_CHARGE_DEPLETED</code> CombatAbility Used in the <code>Modify Attribute</code> effect. With the <code>Combat Ability</code> attribute. <code>CombatAbility.ATTACK_GROUND</code> FogVisibility Used in the <code>Modify Attribute</code> effect. With the <code>Fog Visibility</code> attribute. <code>FogVisibility.ALWAYS_VISIBLE</code> GarrisonType Used in the <code>Modify Attribute</code> effect. With the <code>Garrison Type</code> attribute. <code>GarrisonType.CAVALRY</code> OcclusionMode Used in the <code>Modify Attribute</code> effect. With the <code>Occlusion Mode</code> attribute. <code>OcclusionMode.DISPLAY_OUTLINE</code> ProjectileHitMode Used in the <code>Modify Attribute</code> effect. With the <code>Projectile Hit Mode</code> attribute. <code>ProjectileHitMode.ANY_PLAYER_UNIT</code> ProjectileVanishMode Used in the <code>Modify Attribute</code> effect. With the <code>Projectile Vanish Mode</code> attribute. <code>ProjectileVanishMode.PASS_THROUGH</code> UnitTrait Used in the <code>Modify Attribute</code> effect. With the <code>Unit Trait</code> attribute. <code>UnitTrait.SHIP</code> <p>*: Means extra functionality listed below.</p>"},{"location":"cheatsheets/datasets/#buttonlocation","title":"ButtonLocation","text":"<pre><code>ButtonLocation.row_col(1, 3)  # ButtonLocation.r1c3\n</code></pre>"},{"location":"cheatsheets/datasets/#herostatusflag","title":"HeroStatusFlag","text":"<pre><code># Both have the same result\nhsf = HeroStatusFlag.CANNOT_BE_CONVERTED + HeroStatusFlag.DELETE_CONFIRMATION\nhsf = HeroStatusFlag.combine(\n    cannot_be_converted=True,\n    delete_confirmation=True\n)\n</code></pre>"},{"location":"cheatsheets/datasets/#general-usage-examples","title":"General usage examples:","text":"<pre><code>trigger = trigger_manager.add_trigger(\"Inform Betrayal!\")\ncondition = trigger.new_condition.diplomacy_state(\n    quantity=DiplomacyState.ALLY,  # &lt;-- DiplomacyState dataset\n    source_player=PlayerId.TWO,\n    target_player=PlayerId.THREE\n)\n\neffect = trigger.new_effect.display_instructions(\n    source_player=PlayerId.ONE,\n    message=\"Spy: Your ally has betrayed you! He allied the enemy!\",\n    instruction_panel_position=PanelLocation.CENTER,  # &lt;-- PanelLocation dataset\n    display_time=10\n)\n</code></pre>"},{"location":"cheatsheets/datasets/#unit-building-techs-etc","title":"Unit, Building, Techs etc.","text":"<p>The Units and Buildings datasets are very useful when adding units. They're also, together with the <code>Tech</code> dataset, very useful when adding or editing triggers.</p>"},{"location":"cheatsheets/datasets/#general-usage","title":"General Usage","text":"<p>These are the biggest and most powerful datasets:</p> Dataset Description <code>UnitInfo</code> Dataset for units <code>BuildingInfo</code> Dataset for buildings <code>HeroInfo</code> Dataset for heroes <code>OtherInfo</code> Dataset for other units (like relics and gold piles) <code>TechInfo</code> Dataset for technologies <p>The use of the <code>.ID</code> suffix</p> <p>These datasets contain more info about the object than just the ID. To be able to access all this info from a single entry, suffix are needed to specifically request the right  information. If you want the normal ID of a unit/building etc. you need to use: <code>.ID</code> after the dataset entry. This will look something like: <code>UnitInfo.PALADIN.ID</code></p> <p>For adding units it'll look something like the following:</p> <pre><code>unit_manager.add_unit(PlayerId.ONE,  UnitInfo.CONQUISTADOR.ID,    x=10, y=20)\nunit_manager.add_unit(PlayerId.TWO,  UnitInfo.PALADIN.ID,         x=20, y=20)\nunit_manager.add_unit(PlayerId.GAIA, BuildingInfo.FEITORIA.ID,    x=30, y=20)\nunit_manager.add_unit(PlayerId.GAIA, HeroInfo.WILLIAM_WALLACE.ID, x=40, y=20)\nunit_manager.add_unit(PlayerId.GAIA, OtherInfo.GOLD_MINE.ID,      x=50, y=20)\n</code></pre> <p>With the triggers you can do similar stuff like:</p> <pre><code>...\neffect = trigger.new_effect.create_object(\n    object_list_unit_id=OtherInfo.RELIC.ID\n)\n...\neffect = trigger.new_effect.research_technology(\n    source_player=PlayerId.THREE,\n    technology=TechInfo.BLOODLINES.ID\n)\n...\n</code></pre>"},{"location":"cheatsheets/datasets/#unitinfo-functions","title":"UnitInfo functions","text":"<p>Some useful functions for the <code>UnitInfo</code> dataset is <code>vils()</code> and <code>unique_units()</code></p> <pre><code># Get all villager units (e.g. FARMER, HUNTER, LUMBERJACK etc.) \n# You can disable certain categories like:\n# - exclude_male\n# - exclude_female\n# Example:\nmale_vils = UnitInfo.vils(exclude_female=True)  \n</code></pre> <pre><code># Get all unique units (e.g. HUSKARL, CONQUISTADOR, LONGBOAT, SLINGER etc.)\n# You can disable certain categories like:\n# - exclude_elite_units\n# - exclude_non_elite_units\n# - exclude_castle_units  (From the castle building)\n# - exclude_non_castle_units  (From anything but the castle building)\n# Example:\nall_unique_non_castle_non_elite_units = UnitInfo.unique_units(exclude_elite_units=True, exclude_castle_units=True)  \n</code></pre>"},{"location":"cheatsheets/datasets/#techinfo-functions","title":"TechInfo functions","text":"<p>Some useful functions for the <code>TechInfo</code> dataset are:</p> <ul> <li><code>unique_techs()</code></li> </ul> <pre><code># Get all unique techs (e.g. BEARDED_AXE, CHIEFTAINS, FIRST_CRUSADE etc.)\n# You can disable certain categories like:\n# - exclude_castle_techs\n# - exclude_imp_techs\n# Example:\nimp_unique_techs = TechInfo.unique_techs(exclude_castle_techs=True)  \n</code></pre> <ul> <li><code>unique_unit_upgrades()</code></li> </ul> <pre><code># Get all unique unit techs (e.g. ELITE_LONGBOWMAN, ELITE_TEUTONIC_KNIGHT etc.)\n# You can disable certain categories like:\n# - exclude_castle_techs\n# - exclude_non_castle_techs  (Excludes stuff like: ELITE_LONGBOAT, IMPERIAL_SKIRMISHER)\n# Example:\nuu_castle_upgrades = TechInfo.unique_unit_upgrades(exclude_non_castle_techs=True)  \n</code></pre> <ul> <li><code>blacksmith_techs()</code></li> <li><code>monastery_techs()</code></li> <li><code>university_techs()</code></li> <li><code>town_center_techs()</code></li> </ul> <pre><code># Get all blacksmith/monastery/university techs\n# You can filter on ages, like so:\nall_blacksmith_techs = TechInfo.blacksmith_techs()\nfeudal_blacksmith_techs = TechInfo.blacksmith_techs(Age.FEUDAL_AGE)\nnon_imp_blacksmith_techs = TechInfo.blacksmith_techs([Age.FEUDAL_AGE, Age.CASTLE_AGE])\n# Same goes for:\n#   - TechInfo.monastery_techs(...)\n#   - TechInfo.university_techs(...)\n#   - TechInfo.town_center_techs(...)\n</code></pre> <ul> <li><code>eco_techs()</code></li> </ul> <pre><code># Get all economic techs\nall_eco_techs = TechInfo.eco_techs()\n# You can filter on ages (like with blacksmith_techs etc.):\ndark_age_eco_techs = TechInfo.eco_techs(ages=Age.DARK_AGE)  # Only returns LOOM\n# Or filter on buildings\nmining_and_lumber_upgrades = TechInfo.eco_techs(\n    buildings=[BuildingInfo.MINING_CAMP.ID, BuildingInfo.LUMBER_CAMP.ID]\n)\n# Or both:\nimp_tc_upgrades = TechInfo.eco_techs(\n    ages=Age.IMPERIAL_AGE,\n    buildings=BuildingInfo.TOWN_CENTER.ID,\n)\n</code></pre>"},{"location":"cheatsheets/datasets/#otherinfo-functions","title":"OtherInfo functions","text":"<p>One useful function for the <code>OtherInfo</code> dataset is <code>trees()</code>:</p> <pre><code># Get all tree objects (e.g. OAK_TREE, PINE_TREE, BAMBOO etc.)\n# Example:\nall_trees = OtherInfo.trees()  \n</code></pre>"},{"location":"cheatsheets/datasets/#icon-dead-hotkey-ids","title":"Icon, Dead &amp; Hotkey IDs","text":"<p>Besides normal IDs, you might want to access their icon or dead version. Almost every unit, building, hero and tech has an icon. Most units, buildings and heroes also have a dead unit version to represent the dying animation. You can access these values using the same datasets:</p> <pre><code>archer_id =        UnitInfo.ARCHER.ID         # 4\narcher_icon =      UnitInfo.ARCHER.ICON_ID    # 17\narcher_death =     UnitInfo.ARCHER.DEAD_ID    # 3\narcher_hotkey_id = UnitInfo.ARCHER.HOTKEY_ID  # 16083\n\n# You can also get the datasets from these values\nUnitInfo.from_id(4)             # UnitInfo.ARCHER\nUnitInfo.from_icon_id(17)       # UnitInfo.ARCHER\nUnitInfo.from_dead_id(3)        # UnitInfo.ARCHER\nUnitInfo.from_hotkey_id(16083)  # UnitInfo.ARCHER\n\n# It's also still possible to use the string like normal enums:\nUnitInfo[\"ARCHER\"]  # UnitInfo.ARCHER\n</code></pre>"},{"location":"cheatsheets/datasets/#gaia","title":"GAIA","text":"<p>If you want to know if a unit etc. is a gaia only object, you can do:</p> <pre><code>UnitInfo.ARCHER.IS_GAIA_ONLY  # False\nUnitInfo.WOLF.IS_GAIA_ONLY  # True\n\n# Or for a list:\nUnitInfo.gaia_only()  # Returns all units which have 'IS_GAIA_ONLY' as True\nUnitInfo.non_gaia()  # Returns all units which have 'IS_GAIA_ONLY' as False\n</code></pre>"},{"location":"cheatsheets/datasets/#projectiles","title":"Projectiles","text":"<p>If you wanted to change a projectile of archers to that of an arambai, you could do:</p> <pre><code>trigger.new_effect.modify_attribute(\n    quantity=ProjectileInfo.ARAMBAI.ID,\n    object_list_unit_id=UnitInfo.ARCHER.ID,\n    source_player=PlayerId.ONE,\n    operation=Operation.SET,\n    object_attributes=ObjectAttribute.PROJECTILE_UNIT\n)\n</code></pre> <p>Not all projectiles have the most obvious names. So you can use the following to find projectiles easier.</p> <pre><code># Get the second projectile that a CHU KO NU shoots. (Pre-chemistry arrows)\nProjectileInfo.get_unit_projectile(UnitInfo.CHU_KO_NU.ID, has_chemistry=False, secondary=True)\n</code></pre>"},{"location":"cheatsheets/datasets/#terrains","title":"Terrains","text":"<p>The terrain dataset can be used for changing terrain types.</p> <pre><code>TerrainId.BEACH  # 2\nTerrainId.FOREST_OAK  # 10\nTerrainId.UNDERBUSH_LEAVES  # 71\n\n# Changing the terrain could be done like so:\nmap_manager.terrain[0].terrain_id = TerrainId.GRASS_1\n</code></pre>"},{"location":"cheatsheets/datasets/#players","title":"Players","text":"<p>For selecting players it can be as easy as typing <code>1</code>. Unfortunately not all parts of the scenario file are structured like: <code>0: Gaia, 1: Player1 ... 8: Player8</code>. So because of this a representation layer has been added. It's a simple Enum which looks like this:</p> <pre><code>PlayerId.GAIA,\nPlayerId.ONE, PlayerId.TWO, PlayerId.THREE, PlayerId.FOUR,\nPlayerId.FIVE, PlayerId.SIX, PlayerId.SEVEN, PlayerId.EIGHT\n</code></pre> <p>If you want to loop through players, you have 2 options:</p> <pre><code># Python built-in range function:\nfor player in range(9):  # Or range(1, 9) if you want to exclude GAIA\n# ... code...\n\n# The PlayerId function:\nfor player in PlayerId.all():  # Or PlayerId.all(exclude_gaia=True) if you want to exclude GAIA\n# ... code...    \n</code></pre> <p>You can also address the players by color if you prefer it:</p> <pre><code>PlayerColorId.BLUE, PlayerColorId.RED, PlayerColorId.GREEN, PlayerColorId.YELLOW,\nPlayerColorId.AQUA, PlayerColorId.PURPLE, PlayerColorId.GRAY, PlayerColorId.ORANGE\n</code></pre>"},{"location":"cheatsheets/map/","title":"Map","text":"<p>You can use the map manager to adjust the terrain, elevation, map size and other attributes.</p>"},{"location":"cheatsheets/map/#map-size","title":"Map Size","text":"<p>You can adjust the map size using the parser. </p> <p>Only rectangular maps</p> <p>The game only supports square maps. Changing the size to a rectangle that is not a square will cause the game to crash.</p> <p>Maximum size is 480</p> <p>The game does not support maps over the size of 480. Beyond this size the game will crash when you test the scenario.</p> <p>You can adjust the map size like so:</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# File &amp; Folder setup\n# Define paths to the scenario folder.\n# You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder'\nscenario_folder = \"your/path/to/the/scenario/folder/\"  # &lt;-- Final slash is important\nscenario_name = \"name_of_your_scenario\"\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(f\"{scenario_folder}{scenario_name}.aoe2scenario\")\n\n# Add Trigger\nmap_manager = scenario.map_manager\n# Set it to a nice small 10x10 map :)\nmap_manager.map_size = 10\n\n# Write to same folder with name + '_output'\nscenario.write_to_file(f\"{scenario_folder}{scenario_name}_output.aoe2scenario\")\n</code></pre>"},{"location":"cheatsheets/map/#terrain","title":"Terrain","text":"<p>You can also edit terrain tiles.</p>"},{"location":"cheatsheets/map/#terrain-tiles","title":"Terrain Tiles","text":"<p>Each terrain tile has 3 properties. It's <code>elevation</code>, <code>terrain_id</code> and <code>layer</code>. You can request this information using: </p> <pre><code>tile = map_manager.get_tile(0, 0)\ntile.terrain_id\ntile.elevation\ntile.layer\n</code></pre> <p>You can also edit this information, for example if you want to change tile 20 into water, you can:</p> <pre><code>from AoE2ScenarioParser.datasets.terrains import TerrainId\n\ntile = map_manager.get_tile(i=19)  # (0 based, 0 is the 1st tile, 1 is the second tile etc.)\ntile.terrain_id = TerrainId.WATER_SHALLOW\n</code></pre> <p>You can also request <code>readonly</code> properties from a tile, like its index or coordinates. These cannot be edited.</p> <pre><code>tile = map_manager.get_tile(0, 0)\ntile.i      # 85  (Same tile as when you do: map_manager.terrain[85])\ntile.x      # 5\ntile.y      # 8\ntile.xy     # (5, 8)  &lt;-- Tuple(5,8)\n</code></pre>"},{"location":"cheatsheets/map/#selection","title":"Selection","text":"<p>There's multiple ways to get access to the terrain tiles. The first thing you can do is get access to the entire terrain list through:</p> <pre><code>map_manager.terrain  # Returns a one dimensional list of TerrainTile objects\n</code></pre> <p>The list is the map stacked in a single list. The first entry in the list is the most <code>West</code> tile in the scenario. The second entry is the tile to the top right of the last one. The third is on the top right of that one. This continues until you hit the North East edge. Then it'll continue with the tile to the bottom right of the first tile and the tile after that is the tile to the top right of it. </p> <p>Below you can see a visualisation of a 10x10 map. The coords are <code>(X,Y)</code> coordinates and the blue line is the order in  which tiles are saved.</p> <p></p> <p>To get a tile based on it's XY coordinate (like <code>(5,8)</code>, as highlighted in the above image) you can use: </p> <pre><code>map_manager.get_tile(x=5, y=8)  # Get tile at x5,y8\nmap_manager.get_tile(i=85)      # Get the 86th tile (0 based, 0 is the 1st tile, 1 is the second tile etc.)\n</code></pre> <p>You can also get a square of tiles from the map. For this you can use the function <code>get_square_1d()</code> or  <code>get_square_2d()</code>. Both the functions will return the same tiles, but one will result in a list of tiles, the other in a  list of list with tiles.</p> <p>For example, if you want to turn a square of tiles into roads:</p> <pre><code>from AoE2ScenarioParser.datasets.terrains import TerrainId\n\n# Using: get_square_1d\nfor tile in map_manager.get_square_1d(x1=4, y1=4, x2=8, y2=8):\n    tile.terrain_id = TerrainId.ROAD\n\n# Using: get_square_2d\nfor tile_row in map_manager.get_square_2d(x1=4, y1=4, x2=8, y2=8):\n    for tile in tile_row:\n        tile.terrain_id = TerrainId.ROAD\n</code></pre> <p>This will turn the above map into:</p> <p></p>"},{"location":"cheatsheets/map/#elevation","title":"Elevation","text":"<p>You can also add hills to the map by using the <code>set_elevation</code> function. </p> <pre><code>map_manager.set_elevation(\n    elevation=2,\n    x1=3, \n    y1=3, \n    x2=5, \n    y2=5,\n)\n</code></pre> <p>Elevation is also zero based</p> <p>Elevation is zero based, 0 represents what Age2 calls elevation 1, 1 represents elevation 2 etc.</p> <p>This will create a hill of elevation 3 in the game. The top square of the hill will be 3x3 tiles. Because (3,3) to (5,5) shown in the function above represents the top of the hill. The entire hill, including the slopes, will start on: (1,1) to (7,7).</p> <p>Don't go too high!</p> <p>Using the parser you can basically go as high as you want, BUT above ~20 without UHD and ~15 with UHD the  camera starts clipping into the hill. </p>"},{"location":"cheatsheets/message/","title":"Messages","text":"<p>You can use the message manager to edit the text fields in the <code>Messages</code> tab in the in-game editor.</p>"},{"location":"cheatsheets/message/#editing","title":"Editing","text":"<p>Here's an example of how to edit all the fields in the message manager.</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# File &amp; Folder setup\n# Define paths to the scenario folder.\n# You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder'\nscenario_folder = \"your/path/to/the/scenario/folder/\"  # &lt;-- Final slash is important\nscenario_name = \"name_of_your_scenario\"\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(f\"{scenario_folder}{scenario_name}.aoe2scenario\")\n\nmessage_manager = scenario.message_manager\n\nmessage_manager.instructions  = \"Do this. Do that... please.\"\nmessage_manager.hints         = \"Don't build 3 Archery Ranges on a neutral island. \u00af\\_(\u30c4)_/\u00af\"\nmessage_manager.history       = \"* Old man voice * Back in my day we ..\"\nmessage_manager.loss          = \"Better luck next time!\"\nmessage_manager.scouts        = \"The amount of wood on this map... It's all I can see...\"\nmessage_manager.victory       = \"VICTORY IS OURS!\"\n\n# Write to same folder with name + '_output'\nscenario.write_to_file(f\"{scenario_folder}{scenario_name}_output.aoe2scenario\")\n</code></pre>"},{"location":"cheatsheets/players/","title":"Players","text":"<p>You can use the player manager to edit many player related attributes.</p>"},{"location":"cheatsheets/players/#editing","title":"Editing","text":"<p>Here's an example of how to view a player and edit their starting civilization, architecture and resources.</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\nfrom AoE2ScenarioParser.datasets.object_support import Civilization\nfrom AoE2ScenarioParser.datasets.players import PlayerId\n\n# File &amp; Folder setup\n# Define paths to the scenario folder.\n# You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder'\nscenario_folder = \"your/path/to/the/scenario/folder/\"  # &lt;-- Final slash is important\nscenario_name = \"name_of_your_scenario\"\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(f\"{scenario_folder}{scenario_name}.aoe2scenario\")\n\n# Save the player manager and the second player\nplayer_manager = scenario.player_manager\nplayer_two = player_manager.players[PlayerId.TWO]\n\nplayer_two.civilization = Civilization.BYZANTINES\nplayer_two.architecture_set = Civilization.BYZANTINES\nplayer_two.food = 550\nplayer_two.wood = 450\nplayer_two.gold = 350\nplayer_two.stone = 250\n\n# Write to same folder with name + '_output'\nscenario.write_to_file(f\"{scenario_folder}{scenario_name}_output.aoe2scenario\")\n</code></pre> <p>Players have many attributes, below is a list of most of their attributes which you can change.</p> Attribute name Type Dataset Attributes player_id int - Read only active bool - Read only starting_age int StartingAge lock_civ bool - population_cap int - food int - wood int - gold int - stone int - color int ColorId human bool - civilization int Civilization architecture_set int Civilization diplomacy List[int] - Non-GAIA initial_camera_x int - Non-GAIA initial_camera_y int - Non-GAIA allied_victory bool - Non-GAIA disabled_techs List[int] - Non-GAIA disabled_buildings List[int] - Non-GAIA disabled_units List[int] - Non-GAIA tribe_name str - Non-GAIA base_priority int - Non-GAIA string_table_name_id int - Non-GAIA"},{"location":"cheatsheets/players/#active-players","title":"Active Players","text":"<p>You can also set the active players with the player manager. Unfortunately, the game does not support enabling players in 'gaps'. If you want p4 enabled, you need to have p1, p2 and p3 enabled. This is why the 'active' attribute in the player object is read-only.</p> <p>You can set the active player like:</p> <pre><code>player_manager.active_players = 4  # Enables player 1, 2, 3 and 4\n</code></pre>"},{"location":"cheatsheets/players/#disables","title":"Disables","text":"<p>Disables are used to disable units, buildings and technologies for a certain player. For example, if you want to disable <code>archery ranges</code>, <code>stables</code> and <code>siege workshops</code> for player two, and you want to disable the <code>market</code>, the tech <code>loom</code> and <code>Paladins</code> for the fifth player, you can do so like this:</p> <pre><code>player_two = player_manager.players[PlayerId.TWO]\nplayer_two.disabled_buildings.extend([\n    BuildingInfo.ARCHERY_RANGE.ID,\n    BuildingInfo.STABLE.ID, \n    BuildingInfo.SIEGE_WORKSHOP.ID\n])\n\nplayer_five = player_manager.players[PlayerId.FIVE]\nplayer_five.disabled_buildings.append(BuildingInfo.MARKET.ID)\nplayer_five.disabled_techs.append(TechInfo.LOOM.ID)\nplayer_five.disabled_units.append(UnitInfo.PALADIN.ID)\n</code></pre> <p>You can also copy the list of units from one player to another:</p> <pre><code>player_two = player_manager.players[PlayerId.TWO]\nplayer_five = player_manager.players[PlayerId.FIVE]\n\nplayer_five.disabled_buildings = player_two.disabled_buildings.copy()\n</code></pre>"},{"location":"cheatsheets/players/#diplomacy","title":"Diplomacy","text":"<p>You can set diplomacy through the player manager or directly per player.</p>"},{"location":"cheatsheets/players/#set-diplomacy-teams","title":"Set diplomacy teams","text":"<p>If you want to quickly set the diplomacy in teams where everyone is allied to the rest of the team, you can use the <code>player_manager.set_diplomacy_teams</code> function. It accepts a list of lists with integers or <code>PlayerId</code> numbers.</p> <p>The code below creates four teams of two. This sets the players to ally as you can see with the final <code>diplomacy</code> argument.</p> <pre><code>player_manager.set_diplomacy_teams(\n    [1, 2], [3, 4], [5, 6], [7, 8], \n    diplomacy=DiplomacyState.ALLY\n)\n</code></pre>"},{"location":"cheatsheets/players/#set-diplomacy-directly","title":"Set diplomacy directly","text":"<p>You can also set the diplomacy directly for a single player.  For example, below you can see that player one is set to enemy with player 5 and player 2, 3 and 4 are set to ally.</p> <p>This is not mutual!</p> <p>These function calls will only set the diplomacy one-way. All 'target' players (2, 3, 4 and 5) are still on the default Enemy stance.</p> <pre><code>p1 = player_manager.players[PlayerId.ONE]\np1.set_player_diplomacy(5, DiplomacyState.ENEMY)\np1.set_player_diplomacy([2, 3, 4], DiplomacyState.ALLY)\n</code></pre>"},{"location":"cheatsheets/triggers/","title":"Triggers","text":"<p>You can use the trigger manager to add, remove edit and view triggers and variables.</p>"},{"location":"cheatsheets/triggers/#adding","title":"Adding","text":"<p>Here's an example of how to create (add) a trigger and add a condition and effect to it:</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\nfrom AoE2ScenarioParser.datasets.players import PlayerId\nfrom AoE2ScenarioParser.datasets.units import UnitInfo\n\n# File &amp; Folder setup\n# Define paths to the scenario folder.\n# You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder'\nscenario_folder = \"your/path/to/the/scenario/folder/\"  # &lt;-- Final slash is important\nscenario_name = \"name_of_your_scenario\"\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(f\"{scenario_folder}{scenario_name}.aoe2scenario\")\n\n# Add Trigger\ntrigger_manager = scenario.trigger_manager\ntrigger = trigger_manager.add_trigger(\"Trigger Name Here\")\n\n# Add Timer Condition\ntimer_condition = trigger.new_condition.timer(timer=20)\n\n# Add Create Object Effect\ncreate_paladin_effect = trigger.new_effect.create_object(\n    object_list_unit_id=UnitInfo.PALADIN.ID,\n    source_player=PlayerId.ONE,\n    location_x=5,\n    location_y=4,\n)\n\n# Write to same folder with name + '_output'\nscenario.write_to_file(f\"{scenario_folder}{scenario_name}_output.aoe2scenario\")\n</code></pre>"},{"location":"cheatsheets/triggers/#importing","title":"Importing","text":"<p>Instead of directly adding triggers you can also import triggers from another scenario:</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# Define Scenario files\nsource_scenario = AoE2DEScenario.from_file(path_to_the_source_file)\ntarget_scenario = AoE2DEScenario.from_file(path_to_the_target_file)\n\n# Define Trigger Managers\nsource_trigger_manager = source_scenario.trigger_manager\ntarget_trigger_manager = target_scenario.trigger_manager\n\n# Import the triggers\n# In this case all triggers from the source scenario are copied\n# You can optionally set the index to which the imported triggers are set at\n# Leaving this out will add the imported triggers to the end of the target scenario\n# In the example below, the source triggers will be added BEFORE the target triggers due to the 0\ntarget_trigger_manager.import_triggers(source_trigger_manager.triggers, 0)\n\ntarget_scenario.write_to_file(path_to_output_file)\n</code></pre>"},{"location":"cheatsheets/triggers/#selecting","title":"Selecting","text":"<p>Selecting a trigger can be done using the <code>get_trigger</code> function. The function accepts 1 argument, a <code>TriggerSelect</code> (Alias: <code>TS</code>) object.  </p> <p>For an index, just use an integer</p> <p>Instead of <code>TS.index(4)</code> you can just use <code>4</code>.  Integers are used in the same way as <code>TS.index(4)</code> for ease of use</p> <p>You can import <code>TS</code> (or <code>TriggerSelect</code>) like so:</p> <pre><code>from AoE2ScenarioParser.objects.support.trigger_select import TS\nfrom AoE2ScenarioParser.objects.support.trigger_select import TriggerSelect\n</code></pre> <p>The constructor of <code>TriggerSelect</code> accepts 3 arguments, <code>trigger_index</code>, <code>display_index</code> and <code>trigger</code>.</p> <ul> <li>The <code>trigger_index</code> expects the trigger     ID of a trigger. This is the a number related to the order of creation     starting from 0.</li> <li>The <code>display_index</code> expects the display ID of a     trigger. This is the a number related to the display order in the     in-game editor.</li> <li>The <code>trigger</code> expects a trigger object. Read further     below on how to create or select one.</li> </ul> <pre><code>TriggerSelect(trigger_index=...)\nTriggerSelect(display_index=...)\nTriggerSelect(trigger=...)\n\n# Use TS as alias &amp; class methods:\nTS.index(...)  # Short hand for: trigger_index\nTS.display(...)  # Short hand for: display_index\nTS.trigger(...)\n\n# Examples:\ntrigger = trigger_manager.get_trigger(TS.index(7))\ntrigger = trigger_manager.get_trigger(7)  # &lt;-- Same result as above, defaults to `TS.index(...)`\ntrigger = trigger_manager.get_trigger(TS.display(3))\n</code></pre> <p>You can use the <code>get_summary_as_string</code> function to view these values without opening the in-game editor. The code below includes the code above:</p> <pre><code>print(trigger_manager.get_summary_as_string())\n\n# Results in:\n\"\"\"\nTrigger Summary:\n    Trigger Name Here    [Index: 0, Display: 0] (conditions: 1,  effects: 1)\n\nVariables Summary:\n    &lt;&lt; No Variables &gt;&gt;\n\"\"\"\n</code></pre> <p>As you can see, the trigger and display index can be seen in the <code>[Index: x, Display: x]</code> part. These are the numbers you can use to select triggers. Which would look like:</p> <pre><code># Define Scenario file\nscenario = AoE2DEScenario.from_file(read_file)\n\n# Get Trigger\ntrigger_manager = scenario.trigger_manager\ntrigger = trigger_manager.get_trigger(0)\n</code></pre> <p>If you want to see the contents of the trigger you can do so by running the <code>get_content_as_string</code> function. This will result in the following (with the <code>create trigger</code> code):</p> <pre><code>print(trigger_manager.get_content_as_string())\n\n# Results in:\n\"\"\"\nTriggers:\n    'Trigger Name Here' [Index: 0, Display: 0]:\n        enabled: True\n        looping: False\n        conditions:\n            timer [Index: 0, Display: 0]:\n                timer: 20\n                inverted: 0\n        effects:\n            create_object [Index: 0, Display: 0]:\n                object_list_unit_id: UnitInfo.PALADIN.ID\n                source_player: PlayerId.ONE\n                location_x: 5\n                location_y: 4\n                facet: 0\n\nVariables:\n    &lt;&lt;No Variables&gt;&gt;\n\"\"\"\n</code></pre>"},{"location":"cheatsheets/triggers/#editing","title":"Editing","text":"<p>When opening a file that already contains triggers you might want to edit or even remove said triggers.</p> <p>You can edit a trigger like so:</p> <pre><code># Get the trigger_index or display_index using the content or summary methods above\ntrigger = trigger_manager.get_trigger(0)  # Or: TS.index(0)\ntrigger = trigger_manager.get_trigger(TS.display(0))\n\ntrigger.name = \"New Trigger Name\"\ntrigger.description = \"Awesome New Description!\"\n</code></pre>"},{"location":"cheatsheets/triggers/#copy","title":"Copy","text":"<p>Pretty simple and straigtforward. It copies a trigger adding it at the end of the trigger list. Selecting a trigger is done using the standard trigger_index, display_index and trigger reference. You can use it as follows:</p> <pre><code>copied_trigger = trigger_manager.copy_trigger(3)\n</code></pre> <p>This will result in a full (deep)copy of your trigger. The only parts that are edited are its <code>id</code> and the name (added <code>\" (copy)\"</code>).</p>"},{"location":"cheatsheets/triggers/#copy-per-player","title":"Copy per player","text":"<p>Just like the <code>copy_trigger</code> function, this trigger makes a (deep) copy of the given function. But, while copying, it'll change the everything player related. With this function comes great control. Below the usage is shown:</p> <pre><code>copied_triggers = trigger_manager.copy_trigger_per_player(\n    from_player=PlayerId.ONE,\n    trigger_select=3,\n    create_copy_for_players=[\n        PlayerId.TWO, PlayerId.THREE, PlayerId.FOUR  # Optional list\n    ]\n)\nprint(f\"New trigger for Player Two: {copied_triggers[PlayerId.TWO]}\")\n</code></pre>"},{"location":"cheatsheets/triggers/#copy-tree","title":"Copy tree","text":"<p>This function copies the given trigger and all that are linked to this one. The function searches all effects in the given trigger and selects all triggers linked to it. It gets all triggers by taking the ids from <code>(de)activate trigger</code> effects. This will result in the entire tree being copied:</p> <pre><code>trigger_manager.copy_trigger_tree(3)\n</code></pre>"},{"location":"cheatsheets/triggers/#copy-tree-per-player","title":"Copy tree per player","text":"<p>A combination of the <code>copy_trigger_per_player</code> and <code>copy_trigger_tree</code> functions. This function copies the entire tree per player. Besides the parameters that can be given to <code>copy_trigger_per_player</code> function, an additional <code>group_triggers_by</code> parameter is included. This way you can select in which order all the new triggers should be placed:</p> <pre><code>trigger_manager.copy_trigger_tree_per_player(\n    from_player=PlayerId.ONE,\n    trigger_select=3,  # Or: TS.index(3)\n    group_triggers_by=GroupBy.PLAYER,  # Other options: GroupBy.NONE and GroupBy.TRIGGER\n)\n</code></pre>"},{"location":"cheatsheets/triggers/#removing","title":"Removing","text":"<p>When removing a trigger you can select it the same way as when getting a trigger using the get_trigger function. But on top of that you can also use it's reference:</p> <pre><code>trigger_manager.remove_trigger(3)  # Or: TS.index(3)\ntrigger_manager.remove_trigger(TS.display(0))\ntrigger_manager.remove_trigger(TS.trigger(trigger))\n</code></pre> <p>For removing effects and conditions it's very similiar but the functions are accessed from the triggers themselves instead of the trigger_manager. You can select the effect or condition you want to remove using:</p> <ul> <li>it's index (the order by time of creation)</li> <li>display index (the order like the in-game editor)</li> <li>reference (the reference to that effect/condition object)</li> </ul> <pre><code>trigger = trigger_manager.get_trigger(0)\ntrigger.remove_effect(effect_index=0)\ntrigger.remove_effect(display_index=1)\ntrigger.remove_effect(effect=effect)\n\ntrigger.remove_condition(condition_index=0)\ntrigger.remove_condition(display_index=1)\ntrigger.remove_condition(condition=condition)\n</code></pre>"},{"location":"cheatsheets/units/","title":"Units","text":"<p>You can use the unit manager to add, edit and remove units. This includes buildings and heroes etc.</p>"},{"location":"cheatsheets/units/#adding","title":"Adding","text":"<p>Below you can find examples on how to add units to the scenario. This will add a conquistador for player 1 at (0, 0) which is the West corner of the map:</p> <pre><code>from AoE2ScenarioParser.datasets.players import PlayerId\nfrom AoE2ScenarioParser.datasets.units import UnitInfo\n\n# ... \n# Read scenario etc.\n# ...\n\n# Add Unit\nunit_manager = scenario.unit_manager\n\nunit = unit_manager.add_unit(\n    player=PlayerId.ONE,\n    unit_const=UnitInfo.CONQUISTADOR.ID,  # Units dataset\n    x=0.5,\n    y=0.5\n)\n\n# Or, with more detail:\nunit = unit_manager.add_unit(\n    player=PlayerId.ONE,\n    unit_const=UnitInfo.CONQUISTADOR.ID,\n    x=0.5,\n    y=0.5,\n    z=0,                # The 'height' of the unit. \n    rotation=0,         # Rotation in radians\n    animation_frame=0,  # The nth animation frame\n)\n</code></pre>"},{"location":"cheatsheets/units/#selecting","title":"Selecting","text":"<p>To select the units you want there are a couple options. You can select all the units from a certain player:</p> <pre><code>gaia_units = unit_manager.get_player_units(PlayerId.GAIA)\n</code></pre> <p>Or, get all units:</p> <pre><code>all_units = unit_manager.get_all_units()\n</code></pre> <p>If you want a more specific search, you can use the <code>get_units_in_area</code> function. This function is quite powerful. You can select an area using coordinates or using tiles. You can also use a whitelist of players or a blacklist of players to (not) select the units from. And, if you have, hand it your own list of units to filter through. You can see a couple examples below:</p> <pre><code>unit_manager.get_units_in_area(x1=0, y1=0, x2=10, y2=10)\n# Any unit within 0,0 =&gt; 10,10\n\nunit_manager.get_units_in_area(tile1=Tile(0, 0), tile2=Tile(10, 10))\n# Any unit within 0,0 =&gt; 11, 11 (Note the 11, 11)\n# This is because Tiles are squares (1x1). So: \n# &gt;&gt;&gt; Tile(0,0).x1 == 0\n# &gt;&gt;&gt; Tile(0,0).x2 == 1\n</code></pre> <p>For all other examples we'll be using the <code>[x, y]</code> notation. But you can use the <code>Tile</code> notation interchangeably:</p> <pre><code>unit_manager.get_units_in_area(x1=2, y1=3, x2=4, y2=5, players=[\n    PlayerId.ONE, PlayerId.TWO\n])\n# Any unit within 2,3 =&gt; 4,5 from Player 1 and 2.\n\nunit_manager.get_units_in_area(x1=2, y1=3, x2=4, y2=5, ignore_players=[\n    PlayerId.GAIA\n])\n# Any unit within 2,3 =&gt; 4,5 from any Player but GAIA.\n\nunit = unit_manager.add_unit(player=PlayerId.ONE, unit_const=UnitInfo.CONQUISTADOR.ID, x=5, y=1)\nunit2 = unit_manager.add_unit(player=PlayerId.TWO, unit_const=UnitInfo.CONQUISTADOR.ID, x=1, y=5)\n\nunit_manager.get_units_in_area(x1=0, y1=0, x2=9, y2=9, unit_list=[unit, unit2], players=[PlayerId.ONE])\n# Selects any unit from the given list that belongs to Player 1 within 0,0 =&gt; 9,9.\n</code></pre> <p>You can also filter certain units based on their <code>unit_const</code> value. For this you can use the <code>filter_units_by_const</code> function.</p> <pre><code># Get TC object of all players\nunit_manager.filter_units_by_const(unit_consts=[BuildingInfo.TOWN_CENTER.ID])\n# Get TC object of only player one and two\nunit_manager.filter_units_by_const(unit_consts=[BuildingInfo.TOWN_CENTER.ID], player_list=[PlayerId.ONE, PlayerId.TWO])\n# Get all objects of player one except for the villagers\nunit_manager.filter_units_by_const(\n    unit_consts=[UnitInfo.VILLAGER_MALE, UnitInfo.VILLAGER_FEMALE],\n    blacklist=True,  # &lt;-- When True, everything in the unit_consts list will be excluded instead of included\n    player_list=[PlayerId.ONE],\n)\n# Exclude all unique units from a given list\nunit_manager.filter_units_by_const(\n    unit_consts=UnitInfo.unique_units(),\n    blacklist=True,\n    unit_list=[some_list_with_Unit_objects]\n)\n</code></pre>"},{"location":"cheatsheets/units/#editing","title":"Editing","text":"<p>While adding units is fun, you might want to change existing units. You can, for example, change the location of any unit:</p> <pre><code>from AoE2ScenarioParser.objects.support.tile import Tile\n\n...\n\nunit.tile = Tile(0, 0)  # Will change the units location to the center of tile 0,0\n# Equivelant to:\nunit.x = 0.5\nunit.y = 0.5\n</code></pre> <p>Besides it's location you can also change the type of unit:</p> <pre><code>unit.unit_const = UnitInfo.MAN_AT_ARMS.ID    # Units dataset\n</code></pre> <p>You also might want to change the ownership of a unit. You can do this by  changing the <code>player</code> property in the unit object itself or calling  <code>change_ownership</code> from the unit manager.</p> <pre><code># Both are identical in functionality\nunit.player = PlayerId.THREE\nunit_manager.change_ownership(unit, PlayerId.THREE)\n</code></pre>"},{"location":"cheatsheets/units/#removing","title":"Removing","text":"<p>Two ways to delete a unit:</p> <p>Removing a unit using an object is faster</p> <p>Due to a unit object containing the player value it belongs to,  the unit can be found a lot faster. Which, when removing a lot of units, can save you some time.</p> <pre><code>unit_manager.remove_unit(unit=unit)\nunit_manager.remove_unit(reference_id=unit.reference_id)\n</code></pre> <p>If you want to remove all units from the map or a single player  you can also just set it to an empty list:</p> <pre><code># Remove all units from P3\nunit_manager.units[PlayerId.THREE] = []\n# Remove all units\nunit_manager.units = []\n</code></pre>"},{"location":"cheatsheets/units/#other-functions","title":"Other functions","text":"<p>Ever wanted to get rid of all the eye candy on the map? Now you can:</p> <pre><code>unit_manager.remove_eye_candy()\n</code></pre>"},{"location":"cheatsheets/xs/","title":"XS Script","text":"<p>For an introduction to the XS scripting language itself, you can check out the UGC Guide.</p>"},{"location":"cheatsheets/xs/#support","title":"Support","text":"<p>Since the introduction of the XS manager, there have been some improvements to the game supporting XS in multiplayer. Age of Empires 2 Definitive Edition is able to transfer manually referenced XS files (through the XS file field) to other players within your lobby. Unfortunately this support does not stretch to spectators. They will not be able to watch your games.</p> <p>To get around this, you can add your XS script to a <code>Script Call</code> effect. When you add the XS to such an effect, it  will, when loading the scenario, move all scripts from those calls to the <code>default0.xs</code> file. This does work in  multiplayer because it happens on every machine separately.</p> <p>So the XS support for the parser works with a dedicated trigger and a <code>Script Call</code> effect. In the in-game editor the  amount of text in a <code>Script Call</code> effect is limited to a certain number of characters. This limitation can be bypassed using the parser.</p>"},{"location":"cheatsheets/xs/#initialising-xs-trigger","title":"Initialising XS Trigger","text":"<p>You can use the XS manager to add XS to your scenarios. All these XS calls do indeed transfer in multiplayer lobbies as is explained above. You can use the XS manager like so:</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# File &amp; Folder setup\nscenario_folder = \"your/path/to/the/scenario/folder/\"\nread_file = scenario_folder + \"scenario_name.aoe2scenario\"\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(read_file)\n\nxs_manager = scenario.xs_manager\n</code></pre> <p>Because the <code>XS Manager</code> uses a trigger with a <code>Script Call</code> in the background, it needs to place the trigger somewhere. You can call the function below to create the trigger. You can also give it an index to insert it somewhere in the  scenario. Not adding an index to the call just adds the trigger at the end of the list.</p> <p>Warning</p> <p>Placing the trigger at the top of all triggers (<code>insert_index=0</code>) can take quite a lot of time if the map already  has a lot of triggers (For example over 1000 triggers).</p> <pre><code>xs_manager.initialise_xs_trigger()\n# Or place the XS trigger at the top of all triggers\nxs_manager.initialise_xs_trigger(insert_index=0)\n</code></pre> <p>You don't have to initialise the trigger</p> <p>Whenever you call the <code>add_script()</code> function (more about this below),  it will automatically initialise the trigger if it hasn't been already. The use of the <code>initialise_xs_trigger()</code> function is purely to control where the trigger is placed.</p>"},{"location":"cheatsheets/xs/#adding-xs","title":"Adding XS","text":"<p>You can add scripts to the trigger using the <code>add_script</code> function. This function accepts a path to an XS file and a  direct XS script string.</p> <p><pre><code># Add a file to the script. \n# Work on your XS script in a file and this will add it to the scenario\nxs_manager.add_script(xs_file_path=\"path/to/xs/script.xs\")\n\n# Add XS directly\nxs_script = \"\"\"\nint a = 1;\nint b = a + 4;\n\"\"\"\nxs_manager.add_script(xs_string=xs_script)\n</code></pre> You can use both <code>xs_file_path=...</code> and <code>xs_string=...</code> in the same <code>add_script</code> call too.</p>"},{"location":"community/projects/","title":"Community Projects","text":"<p>Below is a list of projects made by the community. Go and take a look to get inspired by these amazing scenarios!</p>"},{"location":"community/projects/#scenarios","title":"Scenarios","text":"<p>AoE2 Tetris</p> <p></p> <p>An implementation of Tetris that is playable as an Age of Empires II:DE scenario.</p> <p>Author: T-West ( Youtube / Twitch / GitHub ) Resources: Github Repo / Youtube Video / AoE2:DE Mod</p> <p>Perk Pandemonium AoE2DE</p> <p>Author: Alian713 ( GitHub ) Resources: Github Repo / AoE2:DE Mod</p>"},{"location":"community/resources/","title":"Community Resources","text":"<p>This page lists community made resources. These include written tutorials, examples and videos.</p>"},{"location":"community/resources/#setting-up-python-pycharm-and-the-parser","title":"Setting up Python, PyCharm and the Parser","text":"<p>Below you can find multiple community made resources about setting up Python, an IDE (PyCharm) and the parser.</p> <p>Resource: Age of Kings Heaven Post (By Bassefrom)</p> <p>A textual explanation including images and examples to showcase the installation process.</p> <p>Resource: Youtube video (By duyhung2h)</p> <p>A thorough video explaining and showcasing the installation process.</p>"},{"location":"community/resources/#community-examples","title":"Community Examples","text":"<p>Below you can find examples published by the community</p> <p>Resource: GitHub Repo (By duyhung2h)</p> <p>A GitHub repository with multiple examples showcasing all sorts of things you can do with the parser.  It also includes useful conventions and guidelines for using Python and Pycharm. Every example and guide is nicely documented with its own README file.</p>"},{"location":"community/tools/","title":"Community Tools","text":"<p>Below is a list of projects made by the community. Go and take a look to get inspired by these amazing community made  tools!</p>"},{"location":"community/tools/#tools","title":"Tools","text":"<p>AoE2ScenarioStringEditor</p> <p>This tool gives you the possibility to edit the text content of an aoe2scenario file from AoE2:DE outside the in-game editor. It can be used to translate scenarios in a quick and easy way or to make text changes after creating a scenario.</p> <p>Author: andistrasser ( GitHub ) Resources:  Github Repo</p>"},{"location":"examples/examples/","title":"Examples","text":"<p>These pages show questions I've been asked and my answers to said questions. These examples might help you get the hang of it a little faster.</p> <p>I will expand the pages whenever I get more questions (and have time to add them). If you have any questions, and the docs don't answer them, feel free to send them my way!</p> <p>Check the support page for up-to-date contact info.</p> <p>For a Hello World example, check out the Hello World page here. It includes a complete code block example at the bottom of the page.</p>"},{"location":"examples/operations/","title":"Operation examples","text":""},{"location":"examples/operations/#convert-a-scenario-to-or-from-a-return-of-rome-scenario","title":"Convert a scenario to or from a Return of Rome scenario","text":"<p>Convert a scenario from AoE2 to Return of Rome.  </p> <p>Return of Rome units</p> <p>When converting from or to a Return of Rome scenario, make sure units are valid for the target variant or  make sure there's no conflicting units on the map. </p> <p>Return of Rome version</p> <p>When converting from or to a Return of Rome scenario, make sure your scenario is on v1.49 or later.  To do this, open the scenario in the in-game editor and save it once.</p> <pre><code># Import the scenario object &amp; scenario variant dataset\nfrom AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\nfrom AoE2ScenarioParser.datasets.game_variant import ScenarioVariant\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(file_path_here)\n\n# To Return of Rome scenario:\nscenario.variant = ScenarioVariant.ROR  \n# To usual Age 2 scenario:\nscenario.variant = ScenarioVariant.AOE2  \n\nscenario.write_to_file(file_output_path_here)\n</code></pre>"},{"location":"examples/triggers/","title":"Trigger examples","text":""},{"location":"examples/triggers/#replace-all-sound-names-with-a-specific-name","title":"Replace all sound names with a specific name","text":"<p>How to replace all sound names in effects with the name: <code>OldName</code> to <code>NewName</code>?</p> <pre><code># Import the scenario object\nfrom AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# Define Scenario file\nscenario = AoE2DEScenario.from_file(file_path_here)\n\ntrigger_manager = scenario.trigger_manager\n\n# Loop through all triggers\nfor trigger in trigger_manager.triggers:\n    # Loop through all effects in a trigger\n    for effect in trigger.effects:\n        # Check if the sound_name attribute is equal to \"OldName\" and replace it with \"NewName\"\n        if effect.sound_name == \"OldName\":\n            effect.sound_name = \"NewName\"\n\nscenario.write_to_file(file_output_path_here)\n</code></pre>"},{"location":"examples/triggers/#importing-all-triggers-from-another-scenario","title":"Importing all triggers from another scenario","text":"<p>Get all triggers from one scenario and import them into another scenario.</p> <pre><code>from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario\n\n# Define Scenario files\nsource_scenario = AoE2DEScenario.from_file(path_to_the_source_file)\ntarget_scenario = AoE2DEScenario.from_file(path_to_the_target_file)\n\n# Define Trigger Managers\nsource_trigger_manager = source_scenario.trigger_manager\ntarget_trigger_manager = target_scenario.trigger_manager\n\n# Import the triggers\n# In this case all triggers from the source scenario are copied\n# You can optionally set the index to which the imported triggers are set at\n# Leaving this out will add the imported triggers to the end of the target scenario\n# In the example below, the source triggers will be added BEFORE the target triggers due to the 0\ntarget_trigger_manager.import_triggers(source_trigger_manager.triggers, 0)\n\ntarget_scenario.write_to_file(path_to_output_file)\n</code></pre>"}]}